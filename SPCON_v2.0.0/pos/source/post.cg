       !        
       !        Cray Inc. Decompilation
       !        WARNING - This output is provided for information only.
       !        
       !        Cray Inc. reserves the right to change the format of this
       !        information at any time and does not guarantee the
       !        readability or accuracy of this information.
       !        
       !        This information may not be compilable and corresponds to
       !        the internal representation of the program during the
       !        optimization phase of the compilation process.
       !        
       !        Source                :  post.f90
       !        File                  :  post.cg
       !        Format                :  Fortran
       !        Target                :  X86, 64-bit
       !        
    6.       
    6.       program globalmodelpostprocessing
   25.       0[loc( t$11 ),0] = 2
   25.       0[loc( t$12 ),0] = 0
   25.       0[loc( t$13 ),0] = 0
   25.       0[loc( t$8 ),0].L = int( loc( t$43 ), 8 )
   25.       0[loc( t$9 ),0].L = 0
   25.       0[loc( t$10 ),0].L = int( loc( t$7 ), 8 )
   25.       t$44 = __get_dynamic_type( 2, 0[loc( t$8 ),0].L, 0[loc( t$11 ),0], 1, 0[loc( t$9 ),0].L, 0[loc( t$10 ),0].L, 0[loc( t$12 ),0], 0[loc( t$13 ),0] )
   41.       $CS_wt_0 = loc( wt )
   41.       6[$CS_wt_0,0].L = 0
   41.       7[$CS_wt_0,0].L = 1
   41.       8[$CS_wt_0,0].L = 29
   41.       0[loc( $_allo_P0 ),0].L = 0x1000000000001L
   41.       1[loc( $_allo_P0 ),0].L = loc( wt )
   41.       $MR_wt_S4 = 2[$CS_wt_0,0].L
   41.       $MR_wt_S5 = or( 16, $MR_wt_S4 )
   41.       2[$CS_wt_0,0].L = $MR_wt_S5
   41.       call __allocate( $_allo_P0, 0, 0, _fcd( 0, 0 ) )
   41.       $LCS_wt_2 = 0[loc( wt ),0].L
   41.       $MR_wt_8 = $LCS_wt_2
   41.       $LCS_MR_wt_1 = int( $MR_wt_8, 8 )
   41.       1[$LCS_MR_wt_1,0].L = $_StaticDV_P1
   41.       1[int( 0[loc( wt ),0].L, 8 ),0].L = pointer to array[1] of real( 0 )
   41.       2[int( 0[loc( wt ),0].L, 8 ),0].L = 32
   41.       3[int( 0[loc( wt ),0].L, 8 ),0].L = or( 4, and( 0xffffffffffffffe0UL, 3[int( 0[loc( wt ),0].L, 8 ),0].L ) )
   41.       31[int( 0[loc( wt ),0].L, 8 )].B = 1
   41.       5[int( 0[loc( wt ),0].L, 8 ),0].L = 0
   41.       6[int( 0[loc( wt ),0].L, 8 ),0].L = 0
   41.       29[int( 0[loc( wt ),0].L, 8 )].B = 0
   41.       8[int( 0[loc( wt ),0].L, 8 ),0] = 12
   41.       7[int( 0[loc( wt ),0].L, 8 ),0].L = 1
   41.       8[int( 0[loc( wt ),0].L, 8 ),0].L = 0
   41.       9[int( 0[loc( wt ),0].L, 8 ),0].L = 1
   41.       10[$LCS_MR_wt_1,0].L = $_StaticDV_P2
   41.       10[int( 0[loc( wt ),0].L, 8 ),0].L = pointer to array[1] of real( 0 )
   41.       11[int( 0[loc( wt ),0].L, 8 ),0].L = 32
   41.       12[int( 0[loc( wt ),0].L, 8 ),0].L = or( 4, and( 0xffffffffffffffe0UL, 12[int( 0[loc( wt ),0].L, 8 ),0].L ) )
   41.       103[int( 0[loc( wt ),0].L, 8 )].B = 1
   41.       14[int( 0[loc( wt ),0].L, 8 ),0].L = 0
   41.       15[int( 0[loc( wt ),0].L, 8 ),0].L = 0
   41.       101[int( 0[loc( wt ),0].L, 8 )].B = 0
   41.       26[int( 0[loc( wt ),0].L, 8 ),0] = 12
   41.       16[int( 0[loc( wt ),0].L, 8 ),0].L = 1
   41.       17[int( 0[loc( wt ),0].L, 8 ),0].L = 0
   41.       18[int( 0[loc( wt ),0].L, 8 ),0].L = 1
   41.       19[$LCS_MR_wt_1,0].L = $_StaticDV_P3
   41.       19[int( 0[loc( wt ),0].L, 8 ),0].L = 0
   41.       20[int( 0[loc( wt ),0].L, 8 ),0].L = 16
   41.       21[int( 0[loc( wt ),0].L, 8 ),0].L = or( 4, and( 0xffffffffffffffe0UL, 21[int( 0[loc( wt ),0].L, 8 ),0].L ) )
   41.       175[int( 0[loc( wt ),0].L, 8 )].B = 1
   41.       23[int( 0[loc( wt ),0].L, 8 ),0].L = 0
   41.       24[int( 0[loc( wt ),0].L, 8 ),0].L = 0
   41.       173[int( 0[loc( wt ),0].L, 8 )].B = 0
   41.       44[int( 0[loc( wt ),0].L, 8 ),0] = 23
   41.       25[int( 0[loc( wt ),0].L, 8 ),0].L = 1
   41.       26[int( 0[loc( wt ),0].L, 8 ),0].L = 0
   41.       27[int( 0[loc( wt ),0].L, 8 ),0].L = 1
   41.       21[int( 0[loc( wt ),0].L, 8 ),0].L = or( 16448, and( -4294967265UL, 21[int( 0[loc( wt ),0].L, 8 ),0].L ) )
   41.       12[int( 0[loc( wt ),0].L, 8 ),0].L = or( 65600, and( -4294967265UL, 12[int( 0[loc( wt ),0].L, 8 ),0].L ) )
   41.       3[int( 0[loc( wt ),0].L, 8 ),0].L = or( 65600, and( -4294967265UL, 3[int( 0[loc( wt ),0].L, 8 ),0].L ) )
   43.       $Con_P19 = 1
   43.       $Con_P20 = 1
   43.       call createwatch( 0[int( $LCS_wt_2, 8 ),0].L, $Con_P19, $Con_P20 )
   44.       substr[t$21,0:9] = 'Time     '
   44.       $Con_P19 = 1
   44.       call namewatch( 0[int( 0[loc( wt ),0].L, 8 ),0].L, $Con_P19, substr[t$21,0:9] )
   48.       call initparameters
   49.       call initfiles
   50.       call initpostloop
   51.       call createprblsize
   52.       call createspectralrep
   53.       call creategaussrep
   54.       call createfft
   55.       call createlegtrans
   56.       call createconversion
   57.       call creategausssigma
   58.       call initareainterpolation
   61.       if ( tables_readed == .false. ) then
   61.          call init_tables( substr[datalib,0:128] )
   61.       endif
   63.       $CS_nfbeg_1 = loc( nfbeg )
   63.       $Unit_temp_O0 = 22[$CS_nfbeg_1,0]
   63.       $LCS_kmax_3 = loc( kmax )
   63.       $IOitem_O1 = -1 + 8[$LCS_kmax_3,0]
   63.       $_StackCntrl_O5 = $_StaticCntrl_O4
   63.       $MR_StackCntrl_S6 = loc( $Unit_temp_O0 )
   63.       1[loc( $_StackCntrl_O5 ),0].L = $MR_StackCntrl_S6
   63.       $_StackIolist_O8 = $_StaticIolist_O6
   63.       0[int( pointer to c_union Pointer_union( loc( 7[loc( $_StackIolist_O8 ),0].L ) ), 8 ),0].L = loc( $IOitem_O1 )
   63.       0[int( pointer to c_union Pointer_union( loc( 15[loc( $_StackIolist_O8 ),0].L ) ), 8 ),0].L = loc( 0[$LCS_kmax_3,0] )
   63.       _fwf( pointer to integer (kind=8)( loc( $_StackCntrl_O5 ) ), pointer to integer (kind=8)( loc( (&)0[loc( $_StackIolist_O8 ),0].L ) ), pointer to integer (kind=8)( loc( $_IO_Lib_Stack_O10 ) ) )
   67.       $LCS_nfbeg_4 = loc( nfbeg )
   67.       $t_S2 = 12[$LCS_nfbeg_4,0]
   67.       $t_S3 = 6[$LCS_nfbeg_4,0]
   67.       $LCS_t_5 = $t_S3 - $t_S2
   67.       if ( $LCS_t_5 >= 0 ) then
   67.          $I_L67_S7 = 0
   71.          $LIS_E2 = ( 1 + $LCS_t_5 )
   67.          $LIS_E0 = $t_S2
   67.          do
   67.             nfile = ( $LIS_E0 + $I_L67_S7 )
   68.             $MR_nfprt_S8 = 22[$LCS_nfbeg_4,0]
   68.             $Unit_temp_O2 = $MR_nfprt_S8
   68.             $_StackCntrl_O5 = $_StaticCntrl_O11
   68.             $MR_StackCntrl_S9 = loc( $Unit_temp_O2 )
   68.             1[loc( $_StackCntrl_O5 ),0].L = $MR_StackCntrl_S9
   68.             _fwf( pointer to integer (kind=8)( loc( $_StackCntrl_O5 ) ), pointer to integer (kind=8)( loc( (&)0[loc( $_StaticIolist_O12 ),0].L ) ), pointer to integer (kind=8)( loc( $_IO_Lib_Stack_O10 ) ) )
   69.             t$26 = ( $LIS_E0 + $I_L67_S7 )
   69.             call postgl( 12[$LCS_nfbeg_4,0], 0[$LCS_nfbeg_4,0], 6[$LCS_nfbeg_4,0], t$26 )
   70.             $MR_nfprt_S10 = 22[$LCS_nfbeg_4,0]
   70.             $Unit_temp_O3 = $MR_nfprt_S10
   70.             $_StackCntrl_O5 = $_StaticCntrl_O14
   70.             $MR_StackCntrl_S11 = loc( $Unit_temp_O3 )
   70.             1[loc( $_StackCntrl_O5 ),0].L = $MR_StackCntrl_S11
   70.             _fwf( pointer to integer (kind=8)( loc( $_StackCntrl_O5 ) ), pointer to integer (kind=8)( loc( (&)0[loc( $_StaticIolist_O15 ),0].L ) ), pointer to integer (kind=8)( loc( $_IO_Lib_Stack_O10 ) ) )
   71.             $I_L67_S7 = 1 + $I_L67_S7
   69.             if ( $I_L67_S7 >= $LIS_E2 ) exit
   69.          enddo
   69.       endif
   76.       substr[t$27,0:21] = 'TempoPosProcessamento'
   76.       call dumpwatch( 0[int( 0[loc( wt ),0].L, 8 ),0].L, 2[loc( nthreads ),0], substr[t$27,0:21] )
   77.       call destroywatch( 0[int( 0[loc( wt ),0].L, 8 ),0].L )
   81.       call _end
   81.       return
   81.       end
   81.       
