%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S u m m a r y   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compilation
-----------
File     : /scratch/p01211/oens-1.0.0/model/source/Sizes.f90
Compiled : 10/22/10  04:40:55
Compiler : Version 7.2.6
Target   : x86-64
Command  : /opt/cray/cce/7.2.6/cftn/x86-64/bin/ftn_driver.exe -hcpu=x86-64
           -hnetwork=seastar -hstatic -hbyteswapio -Rb -Onomodinline -emacdE
           -rmda -c -I/opt/cray/portals/2.2.0-1.0301.22647.20.8.ss/include
           -I/opt/cray/pmi/1.0-1.0000.7901.22.1.ss/include
           -I/opt/cray/cce/7.2.6/craylibs/x86-64/include
           -L/opt/cray/portals/2.2.0-1.0301.22647.20.8.ss/lib64
           -L/opt/cray/pmi/1.0-1.0000.7901.22.1.ss/lib64
           -L/opt/cray/cce/7.2.6/craylibs/x86-64
           -L/opt/acml/4.4.0/gfortran64/lib -lcraymath -lacml_mv -lgfortran
           -I/opt/acml/4.4.0/gfortran64/include -L/opt/gcc/4.1.2/snos/lib64
           -D__CRAYXT -D__CRAYXT_COMPUTE_LINUX_TARGET -D__TARGET_LINUX__
           -I/opt/cray/mpt/5.1.0/xt/seastar/mpich2-cray/include
           -I/opt/cray/mpt/5.1.0/xt/seastar/sma/include
           -I/opt/xt-libsci/10.4.9.4/cray/include
           -L/opt/cray/mpt/5.1.0/xt/seastar/mpich2-cray/lib
           -L/opt/cray/mpt/5.1.0/xt/seastar/sma/lib64
           -L/opt/xt-libsci/10.4.9.4/cray/lib/72 -lsci -lsma -lmpichf90 -lmpich
           -lrt -lpmi -lalpslli -lalpsutil -lportals -lm
           -L/usr/lib/alps Sizes.f90

ftnlx report
------------
Source   : /scratch/p01211/oens-1.0.0/model/source/Sizes.f90
Date     : 10/22/2010  04:41:04


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          O p t i o n s   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Options :  -O cache2,fp2,scalar2,thread2,vector2,nomodinline,ipa3,noaggress
           -O noautothread,nodwarf,fusion2,nomsgs,negmsgs,omp,nooverindex,patter
           n
           -O shortcircuit2,unroll2,nozeroinc
           -h cache2,fp2,thread2,noautothread,nocaf,cpu,nofunc_trace,network
           -h noomp_trace,omp,nopat_trace,nosecond_underscore
           -s default32 
           -eh 
           -eM 
           -d gjlnovwBDILPQRTZ 
           -e acdhkmpqyS        
           -Rb
           -f free
           -m3
           -S /tmp/pe_16082/Sizes.s


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S o u r c e   L i s t i n g
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


     %%%    L o o p m a r k   L e g e n d    %%%

     Primary Loop Type        Modifiers
     ------- ---- ----        ---------
     A - Pattern matched      a - vector atomic memory operation
                              b - blocked
     C - Collapsed            c - conditional and/or computed
     D - Deleted              f - fused
     E - Cloned                
     I - Inlined              i - interchanged
     M - Multithreaded        m - partitioned
     P - Parallel             p - partial
     R - Redundant            r - unrolled
                              s - shortloop
     V - Vectorized           t - array syntax temp used
                              w - unwound


    1.                 !
    2.                 !  $Author: pkubota $
    3.                 !  $Date: 2009/03/10 12:02:11 $
    4.                 !  $Revision: 1.14 $
    5.                 !
    6.                 MODULE Sizes   ! Version 0 of Nov 25th, 2001
    7.                 
    8.                 
    9.                 
   10.                   ! SINGLE REPOSITORY OF SIZES AND MAPPINGS OF GRID, FOURIER AND SPECTRAL
   11.                   ! FIELD REPRESENTATIONS. SHOULD BE USED BY ALL MODEL MODULES THAT REQUIRE
   12.                   ! SUCH INFORMATION.
   13.                   !
   14.                   ! Module exports three procedures:
   15.                   ! RegisterBasicSizes: set all repository values for spectral representation.
   16.                   !                     It also sets latitudes and maximum number of longitudes
   17.                   !                     for grid representation.
   18.                   ! RegisterOtherSizes: set remaining repository values.
   19.                   ! DumpSizes:          detailed dumping of repository values
   20.                   !
   21.                   ! Module exports a set of values and arrays, described bellow.
   22.                   !
   23.                   ! Notation used throughout the code:
   24.                   ! m  Legendre Order (also Fourier wave number). Goes from 1 to mMax.
   25.                   ! n  Legendre Degree. Goes from m to nMax on regular spectral fields
   26.                   !    and from m to nExtMax on extended spectral fields.
   27.                   ! mn index to store the spectral triangle (m,n) into a single dimension.
   28.                   ! k  vertical index, from 1 to kMax
   29.                   ! j  latitude index, from 1 to jMax (full field)
   30.                   !    or from 1 to jMaxHalf (hemisphere)
   31.                   ! i  longitude index, from 1 to iMax (gaussian grid) or
   32.                   !    from 1 to iMaxPerJ(j) (at latitude j of the reduced grid)
   33.                   ! ib index of a longitude on a block of longitudes packed in one
   34.                   !    dimension of grids;
   35.                   ! jb index for which block of longitudes to take, packed in another
   36.                   !    dimension of grids
   37.                 
   38.                   ! SPECTRAL REPRESENTATION:
   39.                   ! A regular spectral field should be dimensioned (2*mnMax,kMax), where
   40.                   ! the first dimension accomodates pairs of (real,imaginary) spectral
   41.                   ! coefficients for a fixed vertical and the second dimension varies
   42.                   ! verticals.
   43.                   ! Extended spectral fields should use (2*mnExtMax,kMax).
   44.                   ! This module provides mapping functions to map (m,n) into mn:
   45.                   ! For a regular spectral field with complex entries, Legendre Order m
   46.                   ! and Degree n has real coefficient at position 2*mnMap(m,n)-1 and
   47.                   ! imaginary coefficient at position 2*mnMap(m,n). Inverse mappings 
   48.                   ! (from mn to m and n) are also provided. Maps for the extended spectral 
   49.                   ! field are also provided.
   50.                 
   51.                   ! GRID REPRESENTATION:
   52.                   ! Since the number of longitudes per latitude may vary with latitude
   53.                   ! (on reduced grids), sets of latitudes (with all longitudes) 
   54.                   ! are packed together in the first dimension of Grids. 
   55.                   ! Near the pole, many latitudes are packed; near the equator, just a few. 
   56.                   ! Second dimension is vertical.
   57.                   ! Third dimension is the number of packed latitudes required to represent
   58.                   ! a full field.
   59.                   ! A grid field should be dimensioned (ibMax, kMax, jbMax).
   60.                   ! This module provides mapping functions to map latitude j and longitude
   61.                   ! i into (ib,jb).
   62.                   ! Map ibPerIJ(i,j) gives index of first dimension that stores longitude
   63.                   ! i of latitude j. Map jbPerIJ(i,j) gives index of third dimension that
   64.                   ! stores longitude i of latitude j. Consequently, the point of longitude
   65.                   ! i, latitude j and vertical k is stored at (ibPerIJ(i,j), k, jbPerIJ(i,j)).
   66.                   ! Inverse mappings (from (ib,jb) to (i,j)) are also provided.
   67.                 
   68.                   ! FOURIER REPRESENTATION:
   69.                   ! For the moment, Fourier fields are represented externally to the
   70.                   ! transform. That should not happen in the future.
   71.                   ! First dimension contains pairs of (real,imaginary) fourier 
   72.                   ! coefficients. Second dimension is latitude. Third dimension is
   73.                   ! vertical. A full fourier field should be dimensioned 
   74.                   ! (iMax+1, jMax, kMax)
   75.                 
   76.                   USE Constants, ONLY: &
   77.                        rk,  &
   78.                        i8,  &
   79.                        r8
   80.                 
   81.                   USE Options, ONLY: &
   82.                        nfprt,        &
   83.                        slagr,        &
   84.                        delt,         &
   85.                        reducedGrid,  &
   86.                        SL_twotime_scheme
   87.                 
   88.                   USE Parallelism, ONLY:&
   89.                        MsgDump,         &
   90.                        FatalError,      &
   91.                        mygroup_four,    &
   92.                        maxnodes,        &
   93.                        myId,            &
   94.                        maxnodes_four,   &
   95.                        myId_four,       &
   96.                        unitDump
   97.                 
   98.                   IMPLICIT NONE
   99.                 
  100.                 
  101.                   ! INTERNAL DATA STRUCTURE:
  102.                   ! Provision for MPI computation:
  103.                   !
  104.                   ! Domain Decomposition:
  105.                   ! There are maxNodes MPI processes, numbered from 0 to maxNodes - 1
  106.                   ! The number of this MPI process is myId, 0 <= myId <= maxNodes - 1
  107.                   ! SPECTRAL REPRESENTATION:
  108.                   ! mMax is the maximum Legendre Order (also maximum Fourier wave number).
  109.                   !      it is set to model truncation + 1 (Legendre Order 0 is m=1)
  110.                   ! nMax is the maximum Legendre Degree for regular spectral fields.
  111.                   !      it is set to model truncation + 1 (Legendre Degree 1 is n=1)
  112.                   ! mnMax is the amount of spectral coeficients per vertical, for 
  113.                   !       regular spectral fields. It is the number of points in the
  114.                   !       regular triangular spectral plane.
  115.                   ! mMap indexed by mn in [1:mnMax]; returns m at this mn for regular
  116.                   !      spectral fields;
  117.                   ! nMap indexed by mn in [1:mnMax]; returns n at this mn for regular
  118.                   !      spectral fields;
  119.                   ! mnMap indexed by (m,n); returns mn that stores spectral coefficient
  120.                   !       (m,n), when spectral coefficients are real (e.g. Associated 
  121.                   !       Legendre Functions). For complex spectral coefficients, 
  122.                   !       mn=2*mnMap(m,n) for the imaginary part and mn=2*mnMap(m,n)-1
  123.                   !       for the real part.
  124.                   ! Remaining variables with Ext extension have the same meaning, but
  125.                   ! for the extended spectral space (where nExtMax=trunc+2), that is,
  126.                   ! where each Legendre Order has one more Legendre Degree than usual.
  127.                 
  128.                   ! Spectral coefficients are spread across processes.
  129.                   ! The set of values of m is partitioned among processes.
  130.                   ! Consequently, all values of n for some values of m are stored
  131.                   ! at each process. Each value of m is stored at a single process.
  132.                   !
  133.                   ! Array nodeHasM(m) has which MPI process stores m, 1 <= m <= mMax
  134.                   !
  135.                   ! Variable myMMax (0 <= myMMax <= mMax) has how many m's are
  136.                   ! stored at this node.
  137.                   !
  138.                   ! Array lm2m(l), l=1,...,myMMax has the m's stored at this
  139.                   ! node. That is,
  140.                   ! it maps local m (lm) into global m (m).
  141.                 
  142.                 
  143.                   INTEGER              :: mMax=-1
  144.                   INTEGER              :: nMax=-1
  145.                   INTEGER              :: mnMax=-1
  146.                   INTEGER, ALLOCATABLE :: mMap(:)
  147.                   INTEGER, ALLOCATABLE :: nMap(:)
  148.                   INTEGER, ALLOCATABLE :: mnMap(:,:)
  149.                   INTEGER              :: nExtMax=-1
  150.                   INTEGER              :: mnExtMax=-1
  151.                   INTEGER, ALLOCATABLE :: mExtMap(:)
  152.                   INTEGER, ALLOCATABLE :: nExtMap(:)
  153.                   INTEGER, ALLOCATABLE :: mnExtMap(:,:)
  154.                 
  155.                   INTEGER, ALLOCATABLE :: nodeHasM(:,:)
  156.                   INTEGER, ALLOCATABLE :: lm2m(:)
  157.                   INTEGER, ALLOCATABLE :: msInProc(:,:)
  158.                   INTEGER, ALLOCATABLE :: msPerProc(:)
  159.                 
  160.                   INTEGER              :: myMMax
  161.                   INTEGER              :: mMaxLocal
  162.                   INTEGER              :: mnMaxLocal
  163.                   INTEGER              :: mnExtMaxLocal
  164.                   INTEGER              :: myMNMax
  165.                   INTEGER              :: myMNExtMax
  166.                   LOGICAL              :: HaveM1
  167.                 
  168.                   INTEGER, ALLOCATABLE :: myMMap(:)
  169.                   INTEGER, ALLOCATABLE :: myNMap(:)
  170.                   INTEGER, ALLOCATABLE :: mnsPerProc(:)
  171.                   INTEGER, ALLOCATABLE :: mnsExtPerProc(:)
  172.                   INTEGER, ALLOCATABLE :: myMNMap(:,:)
  173.                   INTEGER, ALLOCATABLE :: myMExtMap(:)
  174.                   INTEGER, ALLOCATABLE :: myNExtMap(:)
  175.                   INTEGER, ALLOCATABLE :: myMNExtMap(:,:)
  176.                 
  177.                   !
  178.                   !  Spectral representation and division to be used in the semi-implicit part
  179.                   !  -------------------------------------------------------------------------
  180.                 
  181.                   INTEGER              :: nsends_si 
  182.                   INTEGER              :: nrecs_si 
  183.                   INTEGER              :: MNMax_si
  184.                 
  185.                   INTEGER, ALLOCATABLE :: mysends_si(:)
  186.                   INTEGER, ALLOCATABLE :: myrecs_si(:)
  187.                   INTEGER, ALLOCATABLE :: mnProcmap_si(:)
  188.                   INTEGER, ALLOCATABLE :: mnsendsmap_si(:)
  189.                   INTEGER, ALLOCATABLE :: mnsinProc_si(:)
  190.                   INTEGER, ALLOCATABLE :: myMNMap_si(:)
  191.                   INTEGER, ALLOCATABLE :: myNMap_si(:)
  192.                   INTEGER, ALLOCATABLE :: inibr_si(:)
  193.                   INTEGER, ALLOCATABLE :: inibs_si(:)
  194.                   INTEGER, ALLOCATABLE :: maps_si(:)
  195.                   INTEGER, ALLOCATABLE :: mapr_si(:)
  196.                 
  197.                   ! LATITUDES REPRESENTATION:
  198.                   ! jMax is the number of latitudes for full Fourier and Grid representations.
  199.                   ! jMaxHalf is the number of latitudes at each hemisphere.
  200.                   ! mMaxPerJ is an array indexed by latitudes that stores the maximum value
  201.                   !          of m at each latitude. Consequently, the contribution of 
  202.                   !          latitude j for the Legendre Transform should be taken only
  203.                   !          up to Legendre Order mMaxPerJ(j). By the same token, 
  204.                   !          FFTs at latitude j should be computed only up to 
  205.                   !          Fourier wave number mMaxPerJ(j).
  206.                   !          For regular grids, mMaxPerJ(j) = mMax for all j.
  207.                   ! jMinPerM is the inverse mapping - an array indexed by Legendre Orders (m)
  208.                   !          containing the smallest latitude (value of j) that has that
  209.                   !          order. Latitudes that contain Legendre Order (and Fourier
  210.                   !          wave number) m are jMinPerM(m) <= j <= jMax-jMinPerM(m)+1
  211.                   !          For regular grids, jMinPerM(m) = 1 for all m.
  212.                 
  213.                   
  214.                 
  215.                 
  216.                   INTEGER              :: jMax=-1
  217.                   INTEGER              :: jMaxHalf=-1
  218.                   INTEGER, ALLOCATABLE :: mMaxPerJ(:)
  219.                   INTEGER, ALLOCATABLE :: jMinPerM(:)
  220.                   INTEGER, ALLOCATABLE :: jMaxPerM(:)
  221.                 
  222.                 
  223.                 
  224.                   ! LONGITUDES REPRESENTATION:
  225.                   ! iMax is the maximum number of longitudes per latitude;
  226.                   !      it is the number of longitudes per latitude for all latitudes
  227.                   !      on regular grids;
  228.                   !      it is only the maximum number of longitudes per latitude on 
  229.                   !      reduced grids; it is the actual number of longitudes per latitude
  230.                   !      close to the equator on reduced grids;
  231.                   ! ijMax is the number of horizontal grid points at regular or reduced
  232.                   !       grids.
  233.                   ! iMaxPerJ is the actual number of longitudes per latitude on regular
  234.                   !          and reduced grids; latitude j has iMaxPerJ(j) longitudes.
  235.                 
  236.                 
  237.                 
  238.                   INTEGER              :: iMax=-1
  239.                   INTEGER              :: ijMax=-1
  240.                   INTEGER              :: ijMaxGauQua=-1
  241.                   INTEGER, ALLOCATABLE :: iMaxPerJ(:)
  242.                 
  243.                 
  244.                 
  245.                   ! GRID REPRESENTATION:
  246.                   ! All longitudes of a set of latitudes are packed together in the
  247.                   ! first dimension of grids. That decreases the waste of memory when
  248.                   ! comparing to store one latitude only, for the case of reduced
  249.                   ! grid. 
  250.                   ! ibMax is the maximum number of longitudes packed into the first dimension
  251.                   !       of grids. The actual number of longitudes vary with the third
  252.                   !       dimension of the grid representation.
  253.                   ! jbMax is the number of sets of longitudes required to store an
  254.                   !       entire field.
  255.                   ! ibPerIJ maps longitude i and latitude j into the first dimension
  256.                   !         of grid representation. It is indexed ibPerIJ(i,j).
  257.                   ! jbPerIJ maps longitude i and latitude j into the third dimension
  258.                   !         of grid representation. It is indexed jbPerIJ(i,j).
  259.                   ! iPerIJB gives which longitude is stored at first dimension index
  260.                   !         i and third dimension index j of Grid representations.
  261.                   !         It is indexed iPerIJB(i,j)
  262.                   ! jPerIJB gives which latitude is stored at first dimension index
  263.                   !         i and third dimension index j of Grid representations.
  264.                   !         It is indexed jPerIJB(i,j)
  265.                   ! ibMaxPerJB gives how many latitudes are actually stored at third
  266.                   !            dimension jb. Since the number of longitudes vary with
  267.                   !            latitudes, the amount of space actually used in the first
  268.                   !            dimension of grid representations vary with the third
  269.                   !            dimension. Array ibMaxPerJB, indexed by jb, accounts for
  270.                   !            such variation.
  271.                 
  272.                   ! Grid Point Decomposition
  273.                   !
  274.                   ! Blocks of surface points are spreaded across processes.
  275.                   ! Each process has all longitudes of a set of latitudes (block)
  276.                   !
  277.                 
  278.                   !
  279.                   !  decomposition in Fourier space
  280.                   !
  281.                   
  282.                   INTEGER, ALLOCATABLE :: ibMaxPerJB(:)
  283.                   INTEGER, ALLOCATABLE :: firstlatinproc_f(:)
  284.                   INTEGER, ALLOCATABLE :: lastlatinproc_f(:)
  285.                   INTEGER, ALLOCATABLE :: nlatsinproc_f(:)
  286.                   INTEGER, ALLOCATABLE :: nodeHasJ_f(:)
  287.                   INTEGER, ALLOCATABLE :: kfirst_four(:)
  288.                   INTEGER, ALLOCATABLE :: klast_four(:)
  289.                   INTEGER, ALLOCATABLE :: nlevperg_four(:)
  290.                   INTEGER, ALLOCATABLE :: npperg_four(:)
  291.                   INTEGER, ALLOCATABLE :: map_four(:,:)
  292.                   INTEGER, ALLOCATABLE :: first_proc_four(:)
  293.                   INTEGER, ALLOCATABLE :: nlatsinproc_d(:)
  294.                   INTEGER, ALLOCATABLE :: messages_f(:,:)
  295.                   INTEGER, ALLOCATABLE :: messages_g(:,:)
  296.                   INTEGER, ALLOCATABLE :: messproc_f(:,:)
  297.                   INTEGER, ALLOCATABLE :: messproc_g(:,:)
  298.                   INTEGER, ALLOCATABLE :: nodeHasJ(:)
  299.                   INTEGER, ALLOCATABLE :: nset(:)
  300.                 
  301.                   INTEGER              :: myfirstlat_f
  302.                   INTEGER              :: mylastlat_f
  303.                   INTEGER              :: myfirstlev
  304.                   INTEGER              :: mylastlev
  305.                   INTEGER              :: myJMax_f
  306.                   INTEGER              :: ngroups_four
  307.                   INTEGER              :: nprocmax_four
  308.                   INTEGER              :: JMaxlocal_f
  309.                   INTEGER              :: kMaxloc 
  310.                   INTEGER              :: nrecs_f 
  311.                   INTEGER              :: nrecs_g 
  312.                   LOGICAL              :: havesurf
  313.                 
  314.                   !
  315.                   ! grid decomposition 
  316.                   !
  317.                   
  318.                   INTEGER              :: ibMax=-1
  319.                   INTEGER              :: jbMax=-1
  320.                   INTEGER              :: jbMax_ext
  321.                   INTEGER              :: myfirstlat
  322.                   INTEGER              :: mylastlat
  323.                   INTEGER              :: nrecs_gr 
  324.                   INTEGER              :: nsends_gr
  325.                   INTEGER              :: nrecs_diag
  326.                   INTEGER              :: nsends_diag
  327.                   INTEGER              :: myfirstlat_diag
  328.                   INTEGER              :: mylastlat_diag
  329.                   INTEGER              :: myJMax_d
  330.                   INTEGER              :: jovlap
  331.                   INTEGER, ALLOCATABLE :: firstandlastlat(:,:)
  332.                   INTEGER, ALLOCATABLE :: myfirstlon(:)
  333.                   INTEGER, ALLOCATABLE :: mylastlon(:)
  334.                   INTEGER, ALLOCATABLE :: firstlon(:,:)
  335.                   INTEGER, ALLOCATABLE :: lastlon(:,:)
  336.                   INTEGER, ALLOCATABLE :: firstlat(:)
  337.                   INTEGER, ALLOCATABLE :: lastlat(:)
  338.                   INTEGER, ALLOCATABLE :: ibPerIJ(:,:)
  339.                   INTEGER, ALLOCATABLE :: jbPerIJ(:,:)
  340.                   INTEGER, ALLOCATABLE :: iPerIJB(:,:)
  341.                   INTEGER, ALLOCATABLE :: jPerIJB(:,:)
  342.                   INTEGER, ALLOCATABLE :: pointsinproc(:)
  343.                   INTEGER, ALLOCATABLE :: myrecsgr(:,:)
  344.                   INTEGER, ALLOCATABLE :: myrecspr(:,:)
  345.                   INTEGER, ALLOCATABLE :: mysendsgr(:,:)
  346.                   INTEGER, ALLOCATABLE :: mysendspr(:,:)
  347.                   INTEGER, ALLOCATABLE :: myrecs_diag(:,:)
  348.                   INTEGER, ALLOCATABLE :: myrecspr_diag(:,:)
  349.                   INTEGER, ALLOCATABLE :: mysends_diag(:,:)
  350.                   INTEGER, ALLOCATABLE :: mysendspr_diag(:,:)
  351.                   INTEGER, ALLOCATABLE :: gridmap(:,:)
  352.                 
  353.                   INTEGER              :: kMax=-1
  354.                 
  355.                   REAL(KIND=r8), ALLOCATABLE :: ci(:)      ! 1 - sigma each level (level 1 at surface)
  356.                   REAL(KIND=r8), ALLOCATABLE :: si(:)      ! sigma
  357.                   REAL(KIND=r8), ALLOCATABLE :: del(:)     ! layer thickness (in sigma)
  358.                   REAL(KIND=r8), ALLOCATABLE :: delcl(:)     ! layer thickness (in cl)
  359.                   REAL(KIND=r8), ALLOCATABLE :: rdel2(:)
  360.                   REAL(KIND=r8), ALLOCATABLE :: sl(:)      ! sigma at layer midpoint
  361.                   REAL(KIND=r8), ALLOCATABLE :: cl(:)      ! 1.0 - sl
  362.                   REAL(KIND=r8), ALLOCATABLE :: rpi(:)     ! 'pi' ratios at adjacent layers
  363.                   LOGICAL, PARAMETER, PRIVATE :: dumpLocal=.FALSE.
  364.                 
  365.                 CONTAINS
  366.                 
  367.                 
  368.                 
  369.                   SUBROUTINE RegisterBasicSizes(trunc, nLat, nLon, vert)
  370.                     INTEGER, INTENT(IN) :: trunc
  371.                     INTEGER, INTENT(IN) :: nLat
  372.                     INTEGER, INTENT(IN) :: nLon
  373.                     INTEGER, INTENT(IN) :: vert
  374.                     INTEGER :: m, n, mn
  375.                     CHARACTER(LEN=*), PARAMETER :: h="**(RegisterBasicSizes)**"
  376.                 
  377.                     jMax     = nLat
  378.                     jMaxHalf = nLat/2
  379.                 
  380.                     iMax     = nLon
  381.                 
  382.                     kMax     = vert
  383.                 
  384.                     mMax     = trunc + 1
  385.                     nMax     = mMax
  386.                     nExtMax  = mMax + 1
  387.                     mnExtMax = (nExtMax+2)*(nExtMax-1)/2
  388.                     ALLOCATE (mExtMap(mnExtMax))
  389.                     ALLOCATE (nExtMap(mnExtMax))
  390.                     ALLOCATE (mnExtMap(mMax,nExtMax))
  391.  V-----------<>     nExtMap = -1  ! flag mapping error
  392.  V-----------<>     mExtMap = -1  ! flag mapping error
  393.  V-----------<>     mnExtMap = -1 ! flag mapping error
  394.                     mn = 0
  395.  1------------<     DO m = 1, mMax
  396.  1 Vpr4-------<        DO n = m, mMax+1
  397.  1 Vpr4                   mn = mn + 1
  398.  1 Vpr4                   mnExtMap(m,n) = mn
  399.  1 Vpr4                   mExtMap(mn)   = m
  400.  1 Vpr4                   nExtMap(mn)   = n
  401.  1 Vpr4------->        END DO
  402.  1------------>     END DO
  403.                     mnMax = (mMax * (nMax+1))/2
  404.                     ALLOCATE (mnMap(mMax,nMax))
  405.                     ALLOCATE (mMap(mnMax))
  406.                     ALLOCATE (nMap(mnMax))
  407.  V-----------<>     mnMap = -1  ! flag mapping error
  408.  V-----------<>     mMap = -1   ! flag mapping error
  409.  V-----------<>     nMap = -1   ! flag mapping error
  410.                     mn = 0
  411.  1------------<     DO m = 1, mMax
  412.  1 Vpr4-------<        DO n = m, mMax
  413.  1 Vpr4                   mn = mn + 1
  414.  1 Vpr4                   mnMap(m,n) = mn
  415.  1 Vpr4                   mMap(mn)   = m
  416.  1 Vpr4                   nMap(mn)   = n
  417.  1 Vpr4------->        END DO
  418.  1------------>     END DO
  419.                     IF (dumpLocal) THEN
  420.                        CALL MsgDump(h, ' Dump at the end ')
  421.                        CALL DumpSizes()
  422.                     END IF
  423.                 
  424.                     ijMaxGauQua = iMax*jMax
  425.                 
  426.                   END SUBROUTINE RegisterBasicSizes
  427.                 
  428.                 
  429.                 
  430.                   SUBROUTINE VerticalGroups(givenfouriergroups,nproc_vert)
  431.                     LOGICAL, INTENT(IN) :: givenfouriergroups
  432.                     INTEGER, INTENT(IN) :: nproc_vert
  433.                     CHARACTER(LEN=*), PARAMETER :: h="**(RegisterOtherSizes)**"
  434.                     INTEGER :: i, n, nlp, nrest, ipar, ng, npsq, nl, nn, np, nlg
  435.                     INTEGER :: next, k, m, nprest, l
  436.                     !
  437.                     !  Compute vertical decomposition of fourier groups
  438.                     !
  439.                     IF (givenfouriergroups) THEN
  440.                        ng = nproc_vert
  441.                      ELSE
  442.                        npsq = SQRT(REAL(maxnodes))
  443.  1------------<        DO nl=1,kmax
  444.  1                        nn = nl*maxnodes/kmax
  445.  1                        IF(nn.ge.npsq) EXIT
  446.  1------------>        ENDDO
  447.                        ng = kmax / nl
  448.                        IF (nl*ng.lt.kmax) ng = ng + 1
  449.                     ENDIF
  450.                     ngroups_four = ng
  451.                     nl = kmax / ng
  452.                     IF (nl*ng.lt.kmax) nl = nl + 1
  453.                     nrest = nl * ng - kmax
  454.                     ALLOCATE(kfirst_four(0:maxnodes))
  455.                     ALLOCATE(klast_four(0:maxnodes))
  456.                     ALLOCATE(npperg_four(ng))
  457.                     ALLOCATE(nlevperg_four(ng))
  458.                     ALLOCATE(first_proc_four(ng))
  459.                     np = 0
  460.  r8-----------<     DO i=1,ng
  461.  r8                    IF (i.le.nrest) THEN 
  462.  r8                       nlg = nl - 1
  463.  r8                     ELSE
  464.  r8                       nlg = nl
  465.  r8                    ENDIF
  466.  r8                    nlevperg_four(i) = nlg
  467.  r8                    npperg_four(i) = nlg * maxnodes / kmax
  468.  r8                    np = np + npperg_four(i)
  469.  r8----------->     ENDDO
  470.                     nprest = maxnodes - np
  471.                     next = nprest / ng
  472.                     nprest = nprest - ng * next
  473.  Vr4----------<     DO i=1,ng
  474.  Vr4                   IF (i.le.nprest) THEN
  475.  Vr4                      npperg_four(i) = npperg_four(i) + next + 1
  476.  Vr4                    ELSE
  477.  Vr4                      npperg_four(i) = npperg_four(i) + next
  478.  Vr4                   ENDIF
  479.  Vr4---------->     ENDDO
  480.                     ALLOCATE(nset(ng))
  481.                     ALLOCATE(map_four(ng,0:MAXVAL(npperg_four)-1))
  482.                     n = 0
  483.  V-----------<>     nset = 0
  484.  1------------<     DO
  485.  1 2----------<        DO i=1,ngroups_four
  486.  1 2                      IF (nset(i).lt.npperg_four(i)) THEN
  487.  1 2                         IF (myid.eq.n) THEN
  488.  1 2                            mygroup_four = i
  489.  1 2                            maxnodes_four = npperg_four(i)
  490.  1 2                            myid_four = nset(i)
  491.  1 2                         ENDIF
  492.  1 2                         map_four(i,nset(i)) = n
  493.  1 2                         nset(i) = nset(i) + 1
  494.  1 2                         n = n + 1
  495.  1 2                      ENDIF
  496.  1 2---------->        END DO
  497.  1                     IF (n.ge.maxnodes) EXIT
  498.  1------------>     END DO
  499.                     m = 0
  500.  1------------<     DO i=1,ngroups_four
  501.  1 2----------<        DO k=0,npperg_four(i)-1
  502.  1 2                      l = map_four(i,k)
  503.  1 2                      kfirst_four(l) = m + 1
  504.  1 2                      klast_four(l) = m + nlevperg_four(i)
  505.  1 2---------->        ENDDO
  506.  1                     m = m + nlevperg_four(i)
  507.  1------------>     ENDDO
  508.  Vr4----------<     DO i=1,ngroups_four
  509.  Vr4                   first_proc_four(i) = i - 1
  510.  Vr4---------->     ENDDO
  511.                     kmaxloc = klast_four(myid) - kfirst_four(myid) + 1
  512.                     myfirstlev = kfirst_four(myid)
  513.                     mylastlev = klast_four(myid)
  514.                 
  515.                   END SUBROUTINE VerticalGroups
ftn-5002 ftn: NOTE File = Sizes.f90, Line = 515 
  Local variable "IPAR" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 515 
  Local variable "NLP" is declared but neither defined nor used.

ftn-5008 ftn: NOTE File = Sizes.f90, Line = 515 
  Named Constant "H" is not used.

  516.                 
  517.                 
  518.                 
  519.                   SUBROUTINE RegisterOtherSizes(iMaxPerLat, mPerLat, myid, maxnodes)
  520.                     INTEGER, INTENT(IN) :: iMaxPerLat(jMax)
  521.                     INTEGER, INTENT(IN) :: mPerLat(jMax)
  522.                     INTEGER, INTENT(IN) :: myid
  523.                     INTEGER, INTENT(IN) :: maxnodes
  524.                     CHARACTER(LEN=*), PARAMETER :: h="**(RegisterOtherSizes)**"
  525.                     INTEGER :: MinLatPerBlk
  526.                     !$ INTEGER, EXTERNAL ::  OMP_GET_MAX_THREADS
  527.                     INTEGER :: i, j, k, l, jk, m, ib, jb, jh, cnt, imp2
  528.                     INTEGER :: meanl, meanp, jlast, jused, jfirst
  529.                     INTEGER :: mfirst(maxnodes_four), mlast(maxnodes_four)
  530.                     INTEGER :: npoints(maxnodes_four)
  531.                     INTEGER :: mlast1(maxnodes_four), npoints1(maxnodes_four)
  532.                     INTEGER :: maxpoints, maxpointsold, nproc, nlp, nrest
  533.                     LOGICAL :: improved, done
  534.                 
  535.                     ALLOCATE (mMaxPerJ(jMax))
  536.  V-----------<>     mMaxPerJ = mPerLat
  537.                     ALLOCATE (iMaxPerJ(jMax))
  538.  V-----------<>     iMaxPerJ = iMaxPerLat
  539.                     IF (iMax < MAXVAL(iMaxPerJ)) THEN
  540.                        STOP ' imax and imaxperj disagree'
  541.                     END IF
  542.  V-----------<>     ijMax = SUM(iMaxPerJ)
  543.                 
  544.                     ALLOCATE (firstlatinproc_f(0:maxNodes_four-1))
  545.                     ALLOCATE (lastlatinproc_f(0:maxNodes_four-1))
  546.                     ALLOCATE (nlatsinproc_f(0:maxNodes_four-1))
  547.                     ALLOCATE (nodeHasJ_f(jMax))
  548.                 
  549.                     nproc = maxnodes_four
  550.                     IF (reducedGrid) THEN
  551.                        meanl = ijMax / jMax
  552.                        meanp = ijMax / nproc
  553.                 
  554.  A-----------<>        mlast = 0
  555.  A-----------<>        npoints = 0
  556.  A-----------<>        mlast1 = 0
  557.  A-----------<>        npoints1 = 0
  558.                        jlast = jmax
  559.                        !
  560.                        !  compute first possible partition
  561.                        !
  562.  1------------<        DO i=nproc,1,-1
  563.  1 2----------<           DO j=jlast,1,-1
  564.  1 2                         IF (npoints(i).lt.meanp) THEN
  565.  1 2                            npoints(i) = npoints(i) + iMaxPerJ(j)
  566.  1 2                            IF (mlast(i).eq.0) mlast(i) = j
  567.  1 2                            jused = j
  568.  1 2                           ELSE
  569.  1 2                            EXIT
  570.  1 2                         ENDIF
  571.  1 2---------->           ENDDO
  572.  1                        jlast = jused  - 1
  573.  1------------>        ENDDO
  574.                        maxpointsold = MAXVAL(npoints)
  575.                        !
  576.                        !  improve the partition while possible
  577.                        !
  578.  1------------<        DO
  579.  1                        jlast = jmax
  580.  1 2----------<           DO i=nproc,1,-1
  581.  1 2 3--------<              DO j=jlast,1,-1
  582.  1 2 3                          IF (npoints1(i)+iMaxPerJ(j).lt.maxpointsold) THEN
  583.  1 2 3                             npoints1(i) = npoints1(i) + iMaxPerJ(j)
  584.  1 2 3                             IF (mlast1(i).eq.0) mlast1(i) = j
  585.  1 2 3                             jused = j
  586.  1 2 3                            ELSE
  587.  1 2 3                             EXIT
  588.  1 2 3                          ENDIF
  589.  1 2 3-------->              ENDDO
  590.  1 2                         jlast = jused - 1
  591.  1 2---------->           ENDDO
  592.  1                        IF (jlast.eq.0) THEN 
  593.  1                           maxpoints = MAXVAL(npoints1)
  594.  1                          ELSE
  595.  1                           EXIT
  596.  1                        ENDIF
  597.  1                        IF (maxpoints.lt.maxpointsold) THEN
  598.  1 A---------<>              npoints = npoints1
  599.  1 A---------<>              npoints1 = 0
  600.  1 A---------<>              mlast = mlast1
  601.  1 A---------<>              mlast1 = 0
  602.  1                           maxpointsold = maxpoints
  603.  1                          ELSE
  604.  1                           EXIT
  605.  1                        ENDIF
  606.  1------------>        ENDDO
  607.                        !
  608.                        !  make the partition more uniform
  609.                        !
  610.  1------------<        DO i=1,nproc
  611.  1                       IF(mlast(i).ge.i) THEN
  612.  1                         jused = i
  613.  1                         EXIT
  614.  1                       ENDIF
  615.  1------------>        ENDDO
  616.  Vr4----------<        DO i=1,jused-1
  617.  Vr4                      mlast(i)=i
  618.  Vr4                      npoints(i) = imaxperj(i)
  619.  Vr4---------->        ENDDO
  620.                        npoints(jused) = 0
  621.  Vr4----------<        DO i=jused,mlast(jused)
  622.  Vr4                      npoints(jused) = npoints(jused) + imaxperj(i)
  623.  Vr4---------->        ENDDO
  624.  A-----------<>        mfirst = 0
  625.                        IF (npoints(1).gt.0) mfirst(1)=1   
  626.  1------------<        DO i=2,nproc
  627.  1                        IF (npoints(i).gt.0) mfirst(i) = mlast(i-1)+1
  628.  1------------>        ENDDO
  629.  1------------<        DO
  630.  1                        improved = .false.
  631.  1 2----------<           DO i=1,nproc-1
  632.  1 2                         IF (npoints(i)-npoints(i+1).gt.imaxperj(mlast(i))) THEN
  633.  1 2                            npoints(i) = npoints(i) - imaxperj(mlast(i))
  634.  1 2                            npoints(i+1) = npoints(i+1) + imaxperj(mlast(i))
  635.  1 2                            IF (mlast(i+1).eq.0) mlast(i+1) = mlast(i)
  636.  1 2                            mlast(i) = mlast(i) - 1
  637.  1 2                            improved = .true.
  638.  1 2                          ELSEIF (npoints(i+1)-npoints(i).gt.imaxperj(mfirst(i+1))) THEN
  639.  1 2                            npoints(i) = npoints(i) + imaxperj(mfirst(i+1))
  640.  1 2                            npoints(i+1) = npoints(i+1) - imaxperj(mfirst(i+1))
  641.  1 2                            mlast(i) = mfirst(i+1)
  642.  1 2                            mfirst(i+1) = mfirst(i+1) + 1
  643.  1 2                            IF (mfirst(i).eq.0) mfirst(i) = mlast(i)
  644.  1 2                            improved = .true.
  645.  1 2                         ENDIF
  646.  1 2---------->           ENDDO
  647.  1                        IF (.not.improved) EXIT
  648.  1------------>        ENDDO
  649.                 
  650.                      ELSE
  651.                        
  652.                        nlp = jmax / nproc
  653.                        nrest = jmax - nproc * nlp
  654.  Vpr4---------<        DO i=1,nproc-nrest
  655.  Vpr4                     mfirst(i) = (i-1)*nlp + 1
  656.  Vpr4                     mlast(i) = mfirst(i) + nlp - 1
  657.  Vpr4                     npoints(i) = imaxperj(1)*nlp
  658.  Vpr4--------->        ENDDO
  659.  r4-----------<        DO i=nproc-nrest+1,nproc
  660.  r4                       mfirst(i) = mlast(i-1) + 1
  661.  r4                       mlast(i) = mfirst(i) + nlp
  662.  r4                       npoints(i) = imaxperj(1)*(nlp+1)
  663.  r4----------->        ENDDO
  664.                 
  665.                     ENDIF
  666.                 
  667.                     IF (ANY(npoints(:) <= 0)) THEN
  668.                        CALL FatalError(h//" Too many MPI processes; "//&
  669.                             &"there are processes with 0 latitudes")
  670.                        STOP
  671.                     END IF
  672.                 
  673.                     myfirstlat_f = mfirst(myid_four+1)
  674.                     mylastlat_f = mlast(myid_four+1)
  675.                     jMaxlocal_f = 0
  676.  V-----------<>     nodeHasJ_f=-1
  677.  1------------<     DO k=0,maxNodes_four-1
  678.  1                     firstlatinproc_f(k) = mfirst(k+1)
  679.  1                     lastlatinproc_f(k) = mlast(k+1)
  680.  1                     nlatsinproc_f(k) = mlast(k+1)-mfirst(k+1)+1
  681.  1 Vr4--------<        DO j=firstlatinproc_f(k),lastlatinproc_f(k)
  682.  1 Vr4                    nodeHasJ_f(j) = k
  683.  1 Vr4-------->        ENDDO
  684.  1------------>     ENDDO
  685.                     jMaxlocal_f = MAXVAL(nlatsinproc_f)
  686.                     myJMax_f = mylastlat_f - myfirstlat_f + 1
  687.                 
  688.                     ALLOCATE (jMinPerM(mMax))
  689.                     ALLOCATE (jMaxPerM(mMax))
  690.  V-----------<>     jMinPerM = jMaxHalf
  691.  1------------<     DO j = 1, jMaxHalf
  692.  1                     m = mMaxPerJ(j)
  693.  1                     jMinPerM(1:m) = MIN(j, jMinPerM(1:m))
  694.  1------------>     END DO
  695.  V-----------<>     jMaxPerM = jMax - jMinPerM + 1
  696.                 
  697.                 
  698.                     ! OpenMP parallelism
  699.                 
  700.                     IF (dumpLocal) THEN
  701.                        CALL MsgDump(h, ' Dump at the end ')
  702.                        CALL DumpSizes()
  703.                     END IF
  704.                   END SUBROUTINE RegisterOtherSizes
ftn-5001 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "MEANL" is assigned a value but never used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "JB" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "IMP2" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "IB" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "JFIRST" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "DONE" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "JH" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "MINLATPERBLK" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "JK" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "CNT" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 704 
  Local variable "L" is declared but neither defined nor used.

ftn-5004 ftn: NOTE File = Sizes.f90, Line = 704 
  Dummy Argument "MAXNODES" is not referenced or defined.

ftn-5004 ftn: NOTE File = Sizes.f90, Line = 704 
  Dummy Argument "MYID" is not referenced or defined.

  705.                 
  706.                 
  707.                 
  708.                 
  709.                 
  710.                 
  711.                   SUBROUTINE DumpSizes()
  712.                     CHARACTER(LEN=*), PARAMETER :: h="**(DumpSizes)**"
  713.                     CHARACTER(LEN=10) :: c1, c2, c3, c4
  714.                     CHARACTER(LEN=256) :: line
  715.                     INTEGER :: j, jStart, jEnd, o, p, pStart, pEnd, nNodes
  716.                     LOGICAL :: op
  717.                 
  718.                     ! since using unitDump directly (instead of using MsgDump),
  719.                     ! check if unitDump in open
  720.                 
  721.                     INQUIRE(unitDump, opened=op)
  722.                     IF (.NOT. op) THEN
  723.                        CALL FatalError(h//" unitDump not opened; CreateParallelism not invoked")
  724.                     END IF
  725.                 
  726.                     ! dump
  727.                 
  728.                     IF (mMax == -1) THEN
  729.                        WRITE(unitDump,"(a,' Sizes not created')") h
  730.                     ELSE
  731.                        WRITE(c1,"(i10)") mMax
  732.                        WRITE(c2,"(i10)") nMax
  733.                        WRITE(c3,"(i10)") mnMax
  734.                        WRITE(c4,"(i10)") mnExtMax
  735.                        WRITE(unitDump,"(a,' mMax=',a,'; nMax=',a,'; mnMax=',a,'; mnExtMax=',a)") &
  736.                             h, TRIM(ADJUSTL(c1)), TRIM(ADJUSTL(c2)), TRIM(ADJUSTL(c3)), &
  737.                             TRIM(ADJUSTL(c4))
  738.                        WRITE(c1,"(i10)") jMax
  739.                        WRITE(c2,"(i10)") jMaxHalf
  740.                        WRITE(unitDump,"(a,' jMax=',a,'; jMaxHalf=',a)") &
  741.                             h, TRIM(ADJUSTL(c1)), TRIM(ADJUSTL(c2))
  742.                        WRITE(c1,"(i10)") iMax
  743.                        WRITE(c2,"(i10)") kMax
  744.                        WRITE(c3,"(i10)") ijMax
  745.                        IF (ijMax == -1) THEN
  746.                           WRITE(unitDump,"(a,' iMax=',a,'; kMax=',a)") h, &
  747.                                TRIM(ADJUSTL(c1)), TRIM(ADJUSTL(c2))
  748.                           WRITE(unitDump,"(a,' Sizes not fully created')") h
  749.                        ELSE
  750.                           WRITE(unitDump,"(a,' iMax=',a,'; kMax=',a,'; ijMax=',a)") h, &
  751.                                TRIM(ADJUSTL(c1)), TRIM(ADJUSTL(c2)), TRIM(ADJUSTL(c3))
  752.                 
  753.                 
  754.                 
  755.                           CALL MsgDump(h," latitude domain decomposition:")
  756.                           WRITE(c1,"(i10)") myJMax_f
  757.                           WRITE(c2,"(i10)") myFirstLat_f
  758.                           WRITE(c3,"(i10)") myLastLat_f
  759.                           CALL MsgDump(h," myJmax_f="//TRIM(ADJUSTL(c1))//&
  760.                                "; myFirstLat_f="//TRIM(ADJUSTL(c2))//&
  761.                                "; myLastLat_f="//TRIM(ADJUSTL(c3)))
  762.                 
  763.                 
  764.                 
  765.                           nNodes = SIZE(firstLatInProc_f)
  766.                           CALL MsgDump(h," latitudes per processor:")
  767.                           CALL MsgDump(h," firstLatInProc_f:lastLatInProc_f(nLatsInProc_f)")
  768.  1------------<           DO pStart = 0, nNodes-1, 5
  769.  1                           pEnd = MIN(pStart+4, nNodes-1)
  770.  1                           line = " procs XXXX to XXXX ="
  771.  1                           WRITE(line(08:11),"(i4)") pStart
  772.  1                           WRITE(line(16:19),"(i4)") pEnd
  773.  1 2----------<              DO p = pStart, pEnd
  774.  1 2                            o = p-pStart
  775.  1 2                            WRITE(line(22+15*o:21+15*(o+1)),"(i4,a1,i4,a1,i4,a1)") &
  776.  1 2                               firstLatInProc_f(p),":",lastLatInProc_f(p),"(",nLatsInProc_f(p),")"
  777.  1 2---------->              END DO
  778.  1                           CALL MsgDump(h,TRIM(line))
  779.  1------------>           END DO
  780.                           
  781.                 
  782.                           CALL MsgDump(h," which processor has each latitude:")
  783.  1------------<           DO jStart = 1, jMax, 10
  784.  1                           jEnd = MIN(jStart+9, jMax)
  785.  1                           line = " nodeHasJ(    :    )="
  786.  1                           WRITE(line(11:14),"(i4)") jStart
  787.  1                           WRITE(line(16:19),"(i4)") jEnd
  788.  1 2----------<              DO j = jStart, jEnd
  789.  1 2                            o = j-jStart
  790.  1 2                            WRITE(line(22+5*o:21+5*(o+1)),"(i5)") nodeHasJ_f(j)
  791.  1 2---------->              END DO
  792.  1                           CALL MsgDump(h,TRIM(line))
  793.  1------------>           END DO
  794.                        END IF
  795.                     END IF
  796.                   END SUBROUTINE DumpSizes
  797.                 
  798.                 
  799.                 
  800.                 
  801.                   ! SpectralDomainDecomp: spectral domain decomposition
  802.                 
  803.                 
  804.                 
  805.                 
  806.                   SUBROUTINE SpectralDomainDecomp()
  807.                 
  808.                     INTEGER :: m
  809.                     INTEGER :: n
  810.                     INTEGER :: mn
  811.                     INTEGER :: mBase
  812.                     INTEGER :: mMid
  813.                     INTEGER :: lm
  814.                     INTEGER :: mm
  815.                     INTEGER :: mng
  816.                     INTEGER :: k 
  817.                     INTEGER :: rest
  818.                     INTEGER :: mnsperproc_si
  819.                     INTEGER :: is
  820.                     INTEGER :: i
  821.                     INTEGER :: MaxN, ns, ip, inc, mngiv
  822.                     INTEGER :: ierr
  823.                     INTEGER, ALLOCATABLE :: ini(:), sends(:)
  824.                     CHARACTER(LEN=8) :: c0
  825.                     CHARACTER(LEN=*), PARAMETER :: h="**(SpectralDomainDecomp)**"
  826.                 
  827.                 
  828.                 
  829.                     ! DOMAIN DECOMPOSITION OF FOURIER WAVE NUMBERS (m's)
  830.                 
  831.                 
  832.                 
  833.                     ! any MPI process has at most mMaxLocal m's (may have less)
  834.                     ! mMaxLocal is used to dimension arrays over all MPI processes
  835.                 
  836.                     mMaxLocal = mMax / maxNodes_four
  837.                     IF (mMax-mMaxLocal*maxNodes_four.ne.0) mMaxLocal = mMaxLocal + 1
  838.                 
  839.                 
  840.                     ! msPerProc: how many m's at each MPI process
  841.                 
  842.                     ALLOCATE(msPerProc(0:maxNodes_four-1), stat=ierr)
  843.                     IF (ierr /= 0) THEN
  844.                        WRITE(c0,"(i8)") ierr
  845.                        CALL FatalError(h//" allocate msPerProc returned stat="//TRIM(ADJUSTL(c0)))
  846.                     END IF
  847.                 
  848.                     ! msInProc: which m's are at each MPI process
  849.                     ! note that indexing is restricted to
  850.                     ! msInProc(1:msPerProc(pId), pId), with pId=0,maxNodes-1
  851.                 
  852.                     ALLOCATE(msInProc(mMaxLocal,0:maxNodes_four-1), stat=ierr)
  853.                     IF (ierr /= 0) THEN
  854.                        WRITE(c0,"(i8)") ierr
  855.                        CALL FatalError(h//" allocate msInProc returned stat="//TRIM(ADJUSTL(c0)))
  856.                     END IF
  857.                 
  858.                     ! nodeHasM: which process has a particular value of m.
  859.                     ! Values of nodeHasM for p processes are:
  860.                     ! (0, 1, 2, ..., p-1, p-1, ..., 2, 1, 0, 0, 1, 2, ...)
  861.                     ! This distribution tries to spread evenly load across
  862.                     ! processes, leaving uneven load to the smaller m's.
  863.                 
  864.                     ALLOCATE(nodeHasM(mMax,ngroups_four), stat=ierr)
  865.                     IF (ierr /= 0) THEN
  866.                        WRITE(c0,"(i8)") ierr
  867.                        CALL FatalError(h//" allocate nodeHasM returned stat="//TRIM(ADJUSTL(c0)))
  868.                     END IF
  869.                 
  870.                     ! domain decomposition of m's
  871.                 
  872.  1------------<     DO i=1,ngroups_four
  873.  1                     maxN = npperg_four(i)
  874.  1                     mm = 1
  875.  1 2----------<        DO mBase = 1, mMax, 2*maxN
  876.  1 2                      mMid = mBase+maxN-1
  877.  1 2 Vr4------<           DO m = mBase, MIN(mMid, mMax)
  878.  1 2 Vr4                     nodeHasM(m,i) = m - mBase
  879.  1 2 Vr4------>           END DO
  880.  1 2                      mm = mm + 1
  881.  1 2 Vr4------<           DO m = mMid+1, MIN(mMid+maxN, mMax)
  882.  1 2 Vr4                     nodeHasM(m,i) = maxN + mMid - m
  883.  1 2 Vr4------>           END DO
  884.  1 2                      mm = mm + 1
  885.  1 2---------->        END DO
  886.  1------------>     END DO
  887.                     IF (nodeHasM(1,mygroup_four)==myid_four) THEN
  888.                        haveM1 = .TRUE.
  889.                      ELSE
  890.                        haveM1 = .FALSE.
  891.                     ENDIF
  892.                     havesurf = .FALSE.
  893.                     IF (mygroup_four.eq.1) havesurf = .TRUE.
  894.                     mm = 1
  895.  V-----------<>     msPerProc = 0
  896.                     i = mygroup_four
  897.  1------------<     DO mBase = 1, mMax, 2*maxNodes_four
  898.  1                     mMid = mBase+maxNodes_four-1
  899.  1 r4---------<        DO m = mBase, MIN(mMid, mMax)
  900.  1 r4                     msPerProc(nodeHasM(m,i)) = msPerProc(nodeHasM(m,i)) + 1
  901.  1 r4                     msInProc(mm,nodeHasM(m,i)) = m
  902.  1 r4--------->        END DO
  903.  1                     mm = mm + 1
  904.  1 r4---------<        DO m = mMid+1, MIN(mMid+maxNodes_four, mMax)
  905.  1 r4                     msPerProc(nodeHasM(m,i)) = msPerProc(nodeHasM(m,i)) + 1
  906.  1 r4                     msInProc(mm,nodeHasM(m,i)) = m
  907.  1 r4--------->        END DO
  908.  1                     mm = mm + 1
  909.  1------------>     END DO
  910.                 
  911.                     ! current parallelism restricts the number of MPI processes 
  912.                     ! to truncation + 1
  913.                 
  914.                     IF (ANY(msPerProc <= 0)) THEN
  915.                        CALL FatalError(h//" Too many MPI processes; "//&
  916.                             &"there are processes with 0 Fourier waves")
  917.                        STOP
  918.                     END IF
  919.                 
  920.                     ! myMMax: scalar containing how many m's at this MPI process
  921.                 
  922.                     myMMax = msPerProc(myId_four)
  923.                 
  924.                     ! lm2m: maps local indexing of m to global indexing of m,
  925.                     ! that is, maps (1:myMMax) to (1:mMax)
  926.                 
  927.                     ALLOCATE(lm2m(myMMax), stat=ierr)
  928.                     IF (ierr /= 0) THEN
  929.                        WRITE(c0,"(i8)") ierr
  930.                        CALL FatalError(h//" allocate lm2m returned stat="//TRIM(ADJUSTL(c0)))
  931.                     END IF
  932.  V-----------<>     lm2m(1:mymmax) = msInProc(1:mymmax,myid_four)
  933.                 
  934.                 
  935.                 
  936.                 
  937.                     ! DOMAIN DECOMPOSITION OF SPECTRAL COEFFICIENTS (mn's)
  938.                     ! all mn's of a single m belongs to  a unique process
  939.                 
  940.                 
  941.                 
  942.                 
  943.                     ! mnsPerProc: how many mn's at each MPI process
  944.                 
  945.                     ALLOCATE(mnsPerProc(0:maxNodes_four-1), stat=ierr)
  946.                     IF (ierr /= 0) THEN
  947.                        WRITE(c0,"(i8)") ierr
  948.                        CALL FatalError(h//" allocate mnsPerProc returned stat="//TRIM(ADJUSTL(c0)))
  949.                     END IF
  950.                 
  951.                     ! mnsExtPerProc: how many mnExt's at each MPI process
  952.                 
  953.                     ALLOCATE(mnsExtPerProc(0:maxNodes_four-1), stat=ierr)
  954.                     IF (ierr /= 0) THEN
  955.                        WRITE(c0,"(i8)") ierr
  956.                        CALL FatalError(h//" allocate mnsPerProc returned stat="//TRIM(ADJUSTL(c0)))
  957.                     END IF
  958.                 
  959.                     ! domain decomposition of mn's and mnExt's
  960.                 
  961.                     mm = 1
  962.  V-----------<>     mnsPerProc = 0
  963.  V-----------<>     mnsExtPerProc = 0
  964.                     i = mygroup_four
  965.  1------------<     DO mBase = 1, mMax, 2*maxNodes_four
  966.  1                     mMid = mBase+maxNodes_four-1
  967.  1 r2---------<        DO m = mBase, MIN(mMid, mMax)
  968.  1 r2                     mnsPerProc(nodeHasM(m,i)) =  mnsPerProc(nodeHasM(m,i)) + mmax - m + 1
  969.  1 r2                     mnsExtPerProc(nodeHasM(m,i)) =  mnsExtPerProc(nodeHasM(m,i)) + mmax - m + 2
  970.  1 r2--------->        END DO
  971.  1                     mm = mm + 1
  972.  1 r2---------<        DO m = mMid+1, MIN(mMid+maxNodes_four, mMax)
  973.  1 r2                     mnsPerProc(nodeHasM(m,i)) =  mnsPerProc(nodeHasM(m,i)) + mmax - m + 1
  974.  1 r2                     mnsExtPerProc(nodeHasM(m,i)) =  mnsExtPerProc(nodeHasM(m,i)) + mmax - m + 2
  975.  1 r2--------->        END DO
  976.  1                     mm = mm + 1
  977.  1------------>     END DO
  978.                 
  979.                     ! any MPI process has at most mnMaxLocal mn's (may have less) and
  980.                     ! at most mnExtMaxLocal mnExt's (may have less).
  981.                     ! mnMaxLocal and mnExtMaxLocal are used to dimension arrays over all MPI processes
  982.                 
  983.                     mnMaxLocal = MAXVAL(mnsPerProc)
  984.                     mnExtMaxLocal = MAXVAL(mnsExtPerProc)
  985.                 
  986.                     ! myMNMax: scalar containing how many mn's at this MPI process
  987.                     ! myMNExtMax: scalar containing how many mnExt's at this MPI process
  988.                 
  989.                     myMNMax = mnsPerProc(myId_four)
  990.                     myMNExtMax = mnsExtPerProc(myId_four)
  991.                 
  992.                 
  993.                 
  994.                 
  995.                     ! MAPPINGS OF LOCAL INDICES mn TO (localm,n) 
  996.                 
  997.                 
  998.                 
  999.                 
 1000.                     ! Mapping Local pairs (lm,n) to 1D for Regular Spectral:
 1001.                     ! (1) myMMap(mn): which lm is stored at this position
 1002.                     ! (2) myNMap(mn): which  n is stored at this position
 1003.                     ! (3) myMNMap(lm,n): position storing pair (lm,n)
 1004.                 
 1005.                     ALLOCATE (myMNMap(myMMax,nMax))
 1006.                     ALLOCATE (myMMap(myMNMax))
 1007.                     ALLOCATE (myNMap(myMNMax))
 1008.  V-----------<>     myMNMap = -1  ! flag mapping error
 1009.  V-----------<>     myMMap = -1   ! flag mapping error
 1010.  V-----------<>     myNMap = -1   ! flag mapping error
 1011.                     mn = 0
 1012.  1------------<     DO lm = 1, myMMax
 1013.  1 Vpr4-------<        DO n = lm2m(lm), mMax
 1014.  1 Vpr4                   mn = mn + 1
 1015.  1 Vpr4                   myMNMap(lm,n) = mn
 1016.  1 Vpr4                   myMMap(mn)    = lm
 1017.  1 Vpr4                   myNMap(mn)    = n
 1018.  1 Vpr4------->        END DO
 1019.  1------------>     END DO
 1020.                 
 1021.                 
 1022.                     ! Mapping Local pairs (lm,n) to 1D for Extended Spectral:
 1023.                     ! (1) myMExtMap(mn): which lm is stored at this position
 1024.                     ! (2) myNExtMap(mn): which  n is stored at this position
 1025.                     ! (3) myMNExtMap(lm,n): position storing pair (lm,n)
 1026.                 
 1027.                     ALLOCATE (myMExtMap(myMNExtMax))
 1028.                     ALLOCATE (myNExtMap(myMNExtMax))
 1029.                     ALLOCATE (myMNExtMap(myMMax,nExtMax))
 1030.  V-----------<>     myMExtMap = -1  ! flag mapping error
 1031.  V-----------<>     myNExtMap = -1  ! flag mapping error
 1032.  V-----------<>     myMNExtMap = -1 ! flag mapping error
 1033.                     mn = 0
 1034.  1------------<     DO lm = 1, myMMax
 1035.  1 Vpr4-------<        DO n = lm2m(lm), mMax+1
 1036.  1 Vpr4                   mn = mn + 1
 1037.  1 Vpr4                   myMNExtMap(lm,n) = mn
 1038.  1 Vpr4                   myMExtMap(mn)    = lm
 1039.  1 Vpr4                   myNExtMap(mn)    = n
 1040.  1 Vpr4------->        END DO
 1041.  1------------>     END DO
 1042.                 
 1043.                 !   IF (ngroups_four.eq.1) THEN
 1044.                 !      IF (dumpLocal) THEN
 1045.                 !         CALL DumpSpecDecomp(maxNodes)
 1046.                 !      END IF
 1047.                 !      RETURN
 1048.                 !   END IF
 1049.                   !   spectral decomposition for semi-implicit computations
 1050.                   !
 1051.                 
 1052.                     ALLOCATE (mnsinProc_si(0:maxnodes-1))
 1053.                     ALLOCATE (mnProcmap_si(mnmax))
 1054.                 
 1055.                     mnsperproc_si = mnmax / maxnodes
 1056.                     rest = mnmax - mnsperproc_si * maxnodes
 1057.  r4-----------<     DO k=0,maxnodes-1
 1058.  r4                    IF (rest.ge.1) THEN
 1059.  r4                       mnsinProc_si(k) = mnsperproc_si + 1
 1060.  r4                       rest = rest - 1
 1061.  r4                     ELSE
 1062.  r4                       mnsinProc_si(k) = mnsperproc_si
 1063.  r4                    ENDIF
 1064.  r4             !      mnProcmap_si(mn+1:mn+mnsinProc_si(k)) = k
 1065.  r4             !      mn = mn+mnsinProc_si(k)
 1066.  r4----------->     END DO
 1067.                 
 1068.                     ALLOCATE (ini(0:maxnodes))
 1069.                     mn = 0
 1070.                     ip = 0
 1071.                     inc = 1
 1072.  V-----------<>     ini = 0
 1073.  1------------<     DO m=1,mmax
 1074.  1                     ns = mmax - m + 1
 1075.  1 2----------<        DO
 1076.  1 2                      mngiv = MIN(mnsinProc_si(ip)-ini(ip),ns)
 1077.  1 2 V-------<>           mnProcmap_si(mn+1:mn+mngiv) = ip
 1078.  1 2                      mn = mn + mngiv
 1079.  1 2                      ns = ns - mngiv
 1080.  1 2                      ini(ip) = ini(ip) + mngiv
 1081.  1 2                      ip = ip + inc
 1082.  1 2                      IF (ip.eq.maxnodes) THEN
 1083.  1 2                         inc = -1
 1084.  1 2                         ip = maxnodes - 1
 1085.  1 2                        ELSEIF (ip.eq.-1) THEN
 1086.  1 2                         inc = 1
 1087.  1 2                         ip = 0
 1088.  1 2                      ENDIF
 1089.  1 2                      IF (ns.eq.0) EXIT
 1090.  1 2---------->        END DO
 1091.  1------------>     END DO
 1092.                 
 1093.                 
 1094.                     MNMax_si = mnsinProc_si(myid)
 1095.                 !   myfirstmn_si = SUM(mnsinProc_si(0:myid-1)) + 1
 1096.                 !   mylastmn_si = myfirstmn_si + MNMax_si - 1
 1097.                     
 1098.                     ALLOCATE (mynMap_si(MNMax_si))
 1099.                     ALLOCATE (mymnMap_si(MNMax_si))
 1100.                     
 1101.                     mn = 1
 1102.  1------------<     DO mng=1,MNMax
 1103.  1                     IF (mnProcmap_si(mng).eq.myid) THEN
 1104.  1                        mymnMap_si(mn) = mng
 1105.  1                        mynMap_si(mn) = nMap(mng)
 1106.  1                        mn = mn + 1
 1107.  1                     ENDIF
 1108.  1------------>     ENDDO
 1109.                        
 1110.                 
 1111.                     ALLOCATE (mnsendsmap_si(mymnmax))
 1112.                 
 1113.  1------------<     DO mn=1,mymnmax
 1114.  1                     m = lm2m(mymmap(mn))
 1115.  1                     n = mynmap(mn)
 1116.  1                     mng = mnmap(m,n)
 1117.  1                     mnsendsmap_si(mn) = mnProcmap_si(mng)
 1118.  1------------>     END DO
 1119.                 
 1120.                     ALLOCATE (maps_si(0:maxnodes-1))
 1121.                     ALLOCATE (mapr_si(0:maxnodes-1))
 1122.                     ALLOCATE (sends(maxnodes))
 1123.                     
 1124.                     sends(1) = mnsendsmap_si(1)
 1125.                     nsends_si = 1
 1126.                     ini(1) = 1
 1127.                     maps_si(sends(1)) = 1
 1128.  1------------<     DO mn=2,mymnmax
 1129.  1                     IF (ALL(sends(1:nsends_si).ne.mnsendsmap_si(mn))) THEN
 1130.  1                        nsends_si = nsends_si + 1
 1131.  1                        sends(nsends_si) = mnsendsmap_si(mn)
 1132.  1                        maps_si(mnsendsmap_si(mn)) = nsends_si
 1133.  1                     ENDIF
 1134.  1                     ini(maps_si(mnsendsmap_si(mn))) = ini(maps_si(mnsendsmap_si(mn))) + 1
 1135.  1------------>     END DO
 1136.                     ini(0) = 1
 1137.  r4-----------<     DO k=1,nsends_si
 1138.  r4                    ini(k) = ini(k-1) + 2 * ini(k) * (1+3*kmaxloc)
 1139.  r4----------->     ENDDO
 1140.                 
 1141.                     ALLOCATE (mysends_si(nsends_si))
 1142.                     ALLOCATE (inibs_si(1:nsends_si+1))
 1143.  V-----------<>     inibs_si(1:nsends_si+1) = ini(0:nsends_si)
 1144.  V-----------<>     mysends_si(1:nsends_si) = sends(1:nsends_si)
 1145.                 
 1146.                     DEALLOCATE(ini)
 1147.                     DEALLOCATE(sends)
 1148.                 
 1149.                     IF (dumpLocal) THEN
 1150.                        CALL DumpSpecDecomp(maxNodes)
 1151.                     END IF
 1152.                   END SUBROUTINE SpectralDomainDecomp
ftn-5002 ftn: NOTE File = Sizes.f90, Line = 1152 
  Local variable "IS" is declared but neither defined nor used.

 1153.                 
 1154.                   SUBROUTINE DumpSpecDecomp(maxNodes)
 1155.                     INTEGER, INTENT(IN) :: maxNodes
 1156.                 
 1157.                     INTEGER :: mStart, mEnd, m, o
 1158.                     INTEGER :: peStart, peEnd, pe
 1159.                     CHARACTER(LEN=256) :: line
 1160.                     CHARACTER(LEN=*), PARAMETER :: h="**(DumpSpecDecomp)**"
 1161.                 
 1162.                     CALL MsgDump(h," local sizes of m, mn and mnExt:")
 1163.                     line = " myMMax=    ; myMNMax=        ; myMNExtMax=        "
 1164.                     WRITE(line(9:12),"(i4)") myMMax
 1165.                     WRITE(line(23:30),"(i8)") myMNMax
 1166.                     WRITE(line(44:51),"(i8)") myMNExtMax
 1167.                     CALL MsgDump(h,TRIM(line))
 1168.                 
 1169.                     CALL MsgDump(h," mapping of local m to global m:")
 1170.  1------------<     DO mStart = 1, myMMax, 10
 1171.  1                     mEnd = MIN(mStart+9, myMMax)
 1172.  1                     line = " lm2m(    :    )="
 1173.  1                     WRITE(line( 7:10),"(i4)") mStart
 1174.  1                     WRITE(line(12:15),"(i4)") mEnd
 1175.  1 2----------<        DO m = mStart, mEnd
 1176.  1 2                      o = m-mStart
 1177.  1 2                      WRITE(line(18+5*o:17+5*(o+1)),"(i5)") lm2m(m)
 1178.  1 2---------->        END DO
 1179.  1                     CALL MsgDump(h,TRIM(line))
 1180.  1------------>     END DO
 1181.                 
 1182.                     CALL MsgDump(h," how many ms per process:")
 1183.  1------------<     DO peStart = 0, maxNodes-1, 10
 1184.  1                     peEnd = MIN(peStart+9, maxNodes-1)
 1185.  1                     line = " msPerProc(    :    )="
 1186.  1                     WRITE(line(12:15),"(i4)") peStart
 1187.  1                     WRITE(line(17:20),"(i4)") peEnd
 1188.  1 2----------<        DO pe = peStart, peEnd
 1189.  1 2                      o = pe-peStart
 1190.  1 2                      WRITE(line(23+5*o:22+5*(o+1)),"(i5)") msPerProc(pe)
 1191.  1 2---------->        END DO
 1192.  1                     CALL MsgDump(h,TRIM(line))
 1193.  1------------>     END DO
 1194.                 
 1195.                     CALL MsgDump(h," which node has each m:")
 1196.  1------------<     DO mStart = 1, mMax, 10
 1197.  1                     mEnd = MIN(mStart+9, mMax)
 1198.  1                     line = " nodeHasM(    :    )="
 1199.  1                     WRITE(line(11:14),"(i4)") mStart
 1200.  1                     WRITE(line(16:19),"(i4)") mEnd
 1201.  1 2----------<        DO m = mStart, mEnd
 1202.  1 2                      o = m-mStart
 1203.  1 2                      WRITE(line(22+5*o:21+5*(o+1)),"(i5)") nodeHasM(m,mygroup_four)
 1204.  1 2---------->        END DO
 1205.  1                     CALL MsgDump(h,TRIM(line))
 1206.  1------------>     END DO
 1207.                   END SUBROUTINE DumpSpecDecomp
 1208.                 
 1209.                 
 1210.                 
 1211.                 
 1212.                 
 1213.                 
 1214.                   SUBROUTINE ThreadDecomp(firstInd, lastInd, minInd, maxInd, msg)
 1215.                     INTEGER, INTENT(IN ) :: firstInd
 1216.                     INTEGER, INTENT(IN ) :: lastInd
 1217.                     INTEGER, INTENT(OUT) :: minInd
 1218.                     INTEGER, INTENT(OUT) :: maxInd
 1219.                     CHARACTER(LEN=*), INTENT(IN) :: msg
 1220.                     INTEGER :: chunk
 1221.                     INTEGER :: left
 1222.                     INTEGER :: nTrd
 1223.                     INTEGER :: iTrd
 1224.                     INTEGER :: length
 1225.                     LOGICAL :: inParallel
 1226.                     LOGICAL :: op
 1227.                     CHARACTER(LEN=*), PARAMETER :: h="**(ThreadDecomp)**"
 1228.                     !$ INTEGER, EXTERNAL :: OMP_GET_NUM_THREADS
 1229.                     !$ INTEGER, EXTERNAL :: OMP_GET_THREAD_NUM
 1230.                     !$ LOGICAL, EXTERNAL :: OMP_IN_PARALLEL
 1231.                 
 1232.                     inParallel = .FALSE.
 1233.                     nTrd=1
 1234.                     iTrd=0
 1235.                     !$ inParallel = OMP_IN_PARALLEL()
 1236.                     IF (inParallel) THEN
 1237.                        !$ nTrd = OMP_GET_NUM_THREADS()
 1238.                        !$ iTrd = OMP_GET_THREAD_NUM()
 1239.                        length = lastInd - firstInd + 1
 1240.                        chunk = length/nTrd
 1241.                        left  = length - chunk*nTrd
 1242.                        IF (iTrd < left) THEN
 1243.                           minInd =  iTrd   *(chunk+1) + firstInd
 1244.                           maxInd = (iTrd+1)*(chunk+1) + firstInd - 1
 1245.                        ELSE
 1246.                           minInd =  iTrd   *(chunk) + left + firstInd
 1247.                           maxInd = (iTrd+1)*(chunk) + left + firstInd - 1
 1248.                        END IF
 1249.                     ELSE
 1250.                        minInd = firstInd
 1251.                        maxInd = lastInd
 1252.                     END IF
 1253.                 
 1254.                     IF (dumpLocal) THEN
 1255.                 
 1256.                        ! since using unitDump directly (instead of using MsgDump),
 1257.                        ! check if unitDump in open
 1258.                        
 1259.                        INQUIRE(unitDump, opened=op)
 1260.                        IF (.NOT. op) THEN
 1261.                           CALL FatalError(h//" unitDump not opened; CreateParallelism not invoked")
 1262.                        END IF
 1263.                 
 1264.                        IF (inParallel) THEN
 1265.                           WRITE(unitDump,"(a,' thread ',i2,' got [',i8,':',i8,&
 1266.                                &'] from [',i8,':',i8,'] in parallel region at ',a)") &
 1267.                                h, iTrd, minInd, maxInd, firstInd, lastInd, msg
 1268.                        ELSE
 1269.                           WRITE(unitDump,"(a,' kept domain [',i8,':',i8,&
 1270.                                &'] since not in parallel region at ',a)") &
 1271.                                h, minInd, maxInd, msg
 1272.                        END IF
 1273.                     END IF
 1274.                   END SUBROUTINE ThreadDecomp
 1275.                 
 1276.                 
 1277.                   SUBROUTINE ThreadDecompms(m, myms, nms)
 1278.                     INTEGER, INTENT(IN ) :: m 
 1279.                     INTEGER, INTENT(INOUT) :: myms(m)
 1280.                     INTEGER, INTENT(OUT) :: nms   
 1281.                     INTEGER :: i, j, k
 1282.                     INTEGER :: nTrd
 1283.                     INTEGER :: iTrd
 1284.                     LOGICAL :: inParallel
 1285.                     !$ INTEGER, EXTERNAL :: OMP_GET_NUM_THREADS
 1286.                     !$ INTEGER, EXTERNAL :: OMP_GET_THREAD_NUM
 1287.                     !$ LOGICAL, EXTERNAL :: OMP_IN_PARALLEL
 1288.                 
 1289.                     inParallel = .FALSE.
 1290.                     nTrd=1
 1291.                     iTrd=0
 1292.                     !$ inParallel = OMP_IN_PARALLEL()
 1293.                     IF (inParallel) THEN
 1294.                        !$ nTrd = OMP_GET_NUM_THREADS()
 1295.                        !$ iTrd = OMP_GET_THREAD_NUM() + 1
 1296.                        nms = 0
 1297.                        i = 1
 1298.                        j = 1
 1299.  r4-----------<        DO k=1,m
 1300.  r4                       IF (i.eq.iTrd) THEN
 1301.  r4                         nms = nms + 1
 1302.  r4                         myms(nms) = k
 1303.  r4                       ENDIF
 1304.  r4                       i = i + j
 1305.  r4                       IF (i.eq.nTrd+1) THEN
 1306.  r4                         j = -1
 1307.  r4                         i = nTrd
 1308.  r4                       ENDIF
 1309.  r4                       IF (i.eq.0) THEN
 1310.  r4                         j = 1
 1311.  r4                         i = 1
 1312.  r4                       ENDIF
 1313.  r4----------->        ENDDO
 1314.                     ELSE
 1315.  Vr4----------<        DO k=1,m
 1316.  Vr4                      myms(k) = k
 1317.  Vr4---------->        ENDDO
 1318.                        nms = m
 1319.                     END IF
 1320.                 
 1321.                   END SUBROUTINE ThreadDecompms
 1322.                 
 1323.                 
 1324.                   SUBROUTINE InitVerSizes (si_in, sl_in, del_in)
 1325.                 
 1326.                     REAL(KIND=r8), INTENT(IN) :: si_in(:)
 1327.                     REAL(KIND=r8), INTENT(IN) :: sl_in(:)
 1328.                     REAL(KIND=r8), INTENT(Out) :: del_in(:)
 1329.                 
 1330.                     INTEGER :: kMaxsl
 1331.                     INTEGER :: k
 1332.                     REAL(KIND=r8)    :: rk1, sirk, sirk1, dif
 1333.                 
 1334.                     kMaxsl = SIZE(sl_in)
 1335.                     IF (kMaxsl /= kMax) STOP ' Error in InitVerSizes: kMaxsl=SIZE(sl) /= kMax '
 1336.                     ALLOCATE(del(kMax))
 1337.                     ALLOCATE(delcl(kMax-1))
 1338.                     ALLOCATE(rdel2(kMax))
 1339.                     ALLOCATE(ci(kMax+1))
 1340.                     ALLOCATE(si(kMax+1))
 1341.                     ALLOCATE(sl(kMax))
 1342.                     ALLOCATE(cl(kMax))
 1343.                     ALLOCATE(rpi(kMax-1))
 1344.                 
 1345.  Vpr4---------<     DO k=1, kMax
 1346.  Vpr4                  del(k)=si_in(k)-si_in(k+1)
 1347.  Vpr4--------->     END DO
 1348.  V-----------<>     del_in=del
 1349.  V-----------<>     rdel2 = 0.5_r8/del
 1350.                 
 1351.                     rk1 = rk + 1.0_r8
 1352.                 
 1353.                     !cdir novector
 1354.                     ci(1) = 0.0_r8
 1355.  r4-----------<     DO k=1, kMax-1
 1356.  r4                    ci(k+1)=ci(k)+del(k)
 1357.  r4----------->     END DO
 1358.                     ci(kMax+1)=1.0_r8
 1359.                 
 1360.  Vr4----------<     DO k=1, kMax+1
 1361.  Vr4                   si(k) = 1.0_r8 - ci(k)
 1362.  Vr4---------->     END DO
 1363.                 
 1364.  V------------<     DO k=1, kMax
 1365.  V                     sirk =EXP(rk1*LOG(si(k)))
 1366.  V                     IF(k.LE.kMax-1) THEN
 1367.  V                        sirk1=EXP(rk1*LOG(si(k+1)))
 1368.  V                     ELSE
 1369.  V                        sirk1=0.0_r8
 1370.  V                     END IF
 1371.  V                     dif = sirk-sirk1
 1372.  V                     dif = dif / (rk1*(si(k)-si(k+1)))
 1373.  V                     sl(k) = EXP(LOG(dif)/rk)
 1374.  V                     cl(k) = 1.0_r8 - sl(k)
 1375.  V------------>     END DO
 1376.  Vfr4---------<     DO k = 1, kMax-1
 1377.  Vfr4                  delcl(k) = cl(k+1) - cl(k)
 1378.  Vfr4--------->     END DO
 1379.                     !     
 1380.                     !     compute pi ratios for temp. matrix.
 1381.                     !
 1382.  f------------<     DO k=1, kMax-1
 1383.  f                     rpi(k) = EXP(rk*LOG(sl(k+1)/sl(k)))
 1384.  f------------>     END DO
 1385.                 
 1386.                   END SUBROUTINE InitVerSizes
 1387.                 
 1388.                 
 1389.                   SUBROUTINE GridDecomposition(ibmax,jbmax,jbmax_ext,nproc,myid,vmax_est)
 1390.                     INTEGER, INTENT(IN) :: ibmax
 1391.                     INTEGER, INTENT(OUT) :: jbmax
 1392.                     INTEGER, INTENT(OUT) :: jbmax_ext
 1393.                     INTEGER, INTENT(IN) :: nproc
 1394.                     INTEGER, INTENT(IN) :: myid
 1395.                     REAL (KIND=r8), INTENT(IN) :: vmax_est
 1396.                     INTEGER :: np2, np1, np, ngroups, npperg, nrest, npr
 1397.                     INTEGER :: ngptotal, lat, usedinlat, next, ndim, jbdim
 1398.                     INTEGER :: ngpperproc, n, imp2, ndim_f, iovmax, iadd
 1399.                     INTEGER :: ipar, i1, i2, il1, il2, j1, j2, ij, ij1, ind, aux(4)
 1400.                     INTEGER :: firstextlat, lastextlat, iex, mygridpoints
 1401.                     INTEGER :: i, k, iproc, j, jlo(1), ib, jb, ijb, jh
 1402.                     INTEGER, ALLOCATABLE :: lon(:), iovlap(:)
 1403.                     INTEGER, ALLOCATABLE :: nprocsingroup(:)
 1404.                     INTEGER, ALLOCATABLE :: npointsingroup(:)
 1405.                     INTEGER, ALLOCATABLE :: firstlatingroup(:)
 1406.                     INTEGER, ALLOCATABLE :: lastlatingroup(:)
 1407.                     INTEGER, ALLOCATABLE :: firstloningroup(:)
 1408.                     INTEGER, ALLOCATABLE :: lastloningroup(:)
 1409.                     INTEGER, ALLOCATABLE :: jbmaxingroup(:)
 1410.                     INTEGER, ALLOCATABLE :: procingroup(:)
 1411.                     INTEGER, ALLOCATABLE :: iaux(:,:)
 1412.                     REAL (KIND=r8) :: hj, ifirst, ilast
 1413.                     CHARACTER(LEN=*), PARAMETER :: h="**(GridDecomposition)**"
 1414.                 
 1415.                     IF (nproc.le.3) THEN
 1416.                        ngroups = nproc
 1417.                        npperg = 1
 1418.                        nrest = 0
 1419.                        iex = 0
 1420.                      ELSE 
 1421.                        IF (nproc.le.5) THEN 
 1422.                           ngroups = 1
 1423.                           npperg = nproc-1
 1424.                           nrest = 0
 1425.                           iex = 1
 1426.                         ELSE
 1427.                           np2 = nproc / 2
 1428.                           np = SQRT(REAL(np2))
 1429.                           IF (np*(np+1).lt.np2) THEN
 1430.                              ngroups = np+1
 1431.                            ELSE
 1432.                              ngroups = np
 1433.                           ENDIF
 1434.                           npperg = nproc / ngroups
 1435.                           nrest = nproc - npperg * ngroups
 1436.                           IF (npperg.le.8) THEN
 1437.                              iex = 1
 1438.                            ELSE
 1439.                              iex = 2
 1440.                           ENDIF
 1441.                        ENDIF
 1442.                     ENDIF
 1443.                     hj = ACOS(-1._r8) / jmax
 1444.                     ALLOCATE (gridmap(1:iMax,1:jMax))
 1445.                     ALLOCATE (procingroup(0:nproc-1))
 1446.                     ALLOCATE (nprocsingroup(ngroups+2*iex))
 1447.                     nprocsingroup(1)= 1
 1448.                     nprocsingroup(ngroups+2*iex)= 1
 1449.                     IF (iex.eq.2) THEN
 1450.                        npr = SQRT(REAL(npperg))
 1451.                        nprocsingroup(iex) = npr + 1
 1452.                        nprocsingroup(iex+1) = npperg - npr - 2
 1453.                        nprocsingroup(ngroups+3) = npr + 1
 1454.                        nprocsingroup(ngroups+iex) = npperg - npr - 2
 1455.                      ELSE
 1456.                        IF (iex.eq.1) THEN
 1457.                           nprocsingroup(2) = npperg - 1
 1458.                           nprocsingroup(ngroups+1) = npperg - 1
 1459.                        ENDIF
 1460.                     ENDIF
 1461.  V-----------<>     nprocsingroup(2+iex:ngroups+iex-1) = npperg
 1462.  Vr4----------<     DO k=1,nrest
 1463.  Vr4                   nprocsingroup(1+iex+k) = nprocsingroup(1+iex+k) + 1
 1464.  Vr4---------->     ENDDO
 1465.                     ngroups = ngroups +2*iex
 1466.                     i = -1
 1467.  1------------<     DO k=1,ngroups
 1468.  1 V---------<>        procingroup(i+1:i+nprocsingroup(k))=k
 1469.  1                     i = i+nprocsingroup(k)
 1470.  1------------>     ENDDO
 1471.                     ALLOCATE (npointsingroup(ngroups))
 1472.                     ALLOCATE (pointsinproc(0:nproc-1))
 1473.                     ALLOCATE (firstlatingroup(ngroups))
 1474.                     ALLOCATE (firstloningroup(ngroups))
 1475.                     ALLOCATE (lastlatingroup(ngroups))
 1476.                     ALLOCATE (lastloningroup(ngroups))
 1477.                     ALLOCATE (jbmaxingroup(ngroups))
 1478.  V-----------<>     ngptotal = SUM(imaxperj(1:jmax))
 1479.                     ngpperproc = ngptotal / nproc
 1480.                     nrest = ngptotal - ngpperproc * nproc
 1481.  V-----------<>     pointsinproc(0:nrest-1) = ngpperproc + 1
 1482.  V-----------<>     pointsinproc(nrest:nproc-1) = ngpperproc
 1483.                     lat = 1
 1484.                     usedinlat = 0
 1485.                     iproc = 0
 1486.  1------------<     DO k=1,ngroups
 1487.  1                     next = MIN(nrest,nprocsingroup(k))
 1488.  1                     npointsingroup(k) = ngpperproc * nprocsingroup(k) + next
 1489.  1                     nrest = nrest - next
 1490.  1                     firstlatingroup(k) = lat
 1491.  1                     firstloningroup(k) = usedinlat + 1
 1492.  1                     np = imaxperj(lat) - usedinlat
 1493.  1 2----------<        DO 
 1494.  1 2                      IF (np.ge.npointsingroup(k)) EXIT
 1495.  1 2                      lat = lat + 1
 1496.  1 2                      np = np + imaxperj(lat)
 1497.  1 2---------->        ENDDO
 1498.  1                     lastlatingroup(k) = lat
 1499.  1                     usedinlat = imaxperj(lat) - np + npointsingroup(k)
 1500.  1                     lastloningroup(k) = usedinlat
 1501.  1                     IF (usedinlat.eq.imaxperj(lat)) THEN
 1502.  1                        lat = lat +1
 1503.  1                        usedinlat = 0
 1504.  1                     ENDIF 
 1505.  1------------>     ENDDO
 1506.  V-----------<>     jbmaxingroup = lastlatingroup - firstlatingroup + 1
 1507.                     jbdim = MAXVAL(jbmaxingroup)
 1508.                     IF (SL_twotime_scheme) THEN
 1509.                        jovlap = (delt*vmax_est*imax)/40024000._r8 + 2
 1510.                      ELSE
 1511.                        jovlap = (2._r8*delt*vmax_est*imax)/40024000._r8 + 2
 1512.                     ENDIF
 1513.                     IF (.not.slagr) jovlap = 0
 1514.                     ndim = 4*jbdim+2*jovlap*npperg
 1515.                     ALLOCATE (mysendsgr(4,ndim))
 1516.                     ALLOCATE (mysendspr(2,nproc))
 1517.                     ALLOCATE (myrecsgr(4,ndim))
 1518.                     ALLOCATE (myrecspr(2,nproc))
 1519.                     ALLOCATE (firstlat(0:nproc-1))
 1520.                     ALLOCATE (firstlon(jbdim,0:nproc-1))
 1521.                     ALLOCATE (lastlat(0:nproc-1))
 1522.                     ALLOCATE (lastlon(jbdim,0:nproc-1))
 1523.                     ALLOCATE (lon(jbdim))
 1524.                 
 1525.                     iproc = 0
 1526.  1------------<     DO k=1,ngroups
 1527.  1                     firstlon(1,iproc) = firstloningroup(k)
 1528.  1 V---------<>        firstlon(2:jbmaxingroup(k),iproc) = 1
 1529.  1 V---------<>        lastlon(1:jbmaxingroup(k),iproc) = 0
 1530.  1 V---------<>        lon(1:jbmaxingroup(k)) = firstlon(1:jbmaxingroup(k),iproc)
 1531.  1 2----------<        DO n=1,nprocsingroup(k)
 1532.  1 2 Vcr4-----<           DO np=1,pointsinproc(iproc)
 1533.  1 2 Vcr4 w--<>              jlo = MINLOC(REAL(lon(1:jbmaxingroup(k))) &
 1534.  1 2 Vcr4                    / REAL(imaxperj(firstlatingroup(k):lastlatingroup(k))) )
 1535.  1 2 Vcr4                    j = jlo(1)
 1536.  1 2 Vcr4                    lastlon(j,iproc) = lon(j)
 1537.  1 2 Vcr4                    gridmap(lon(j),j+firstlatingroup(k)-1) = iproc
 1538.  1 2 Vcr4                    lon(j) = lon(j)+1
 1539.  1 2 Vcr4                    IF (j.eq.jbmaxingroup(k).and.lon(j).gt.lastloningroup(k)) &
 1540.  1 2 Vcr4                       lon(j) = imaxperj(lastlatingroup(k))+1
 1541.  1 2 Vcr4----->           ENDDO
 1542.  1 2                      IF (lastlon(1,iproc).eq.0) THEN 
 1543.  1 2                         firstlat(iproc) = firstlatingroup(k)+1
 1544.  1 2                       ELSE
 1545.  1 2                         firstlat(iproc) = firstlatingroup(k)
 1546.  1 2                      ENDIF
 1547.  1 2                      IF (lastlon(jbmaxingroup(k),iproc).eq.0) THEN 
 1548.  1 2                         lastlat(iproc) = lastlatingroup(k)-1
 1549.  1 2                       ELSE 
 1550.  1 2                         lastlat(iproc) = lastlatingroup(k)
 1551.  1 2                      ENDIF
 1552.  1 2                      iproc = iproc + 1
 1553.  1 2                      IF (iproc.ne.nproc) THEN
 1554.  1 2 V-------<>              firstlon(1:jbmaxingroup(k),iproc) = lon(1:jbmaxingroup(k))
 1555.  1 2 V-------<>              lastlon(1:jbmaxingroup(k),iproc) = 0
 1556.  1 2                      ENDIF
 1557.  1 2---------->        ENDDO
 1558.  1------------>     ENDDO
 1559.                 !   if (myid.eq.0) then
 1560.                 !   do iproc=0,nproc-1
 1561.                 !      write(*,*) 'proc ',iproc,' first and last lat ',firstlat(iproc),lastlat(iproc)
 1562.                 !      do j=firstlat(iproc),lastlat(iproc)
 1563.                 !         j1 =j-firstlatingroup(procingroup(iproc))+1
 1564.                 !          write(*,*) 'line ',j,' from ',firstlon(j1,iproc),' to ',lastlon(j1,iproc)
 1565.                 !      enddo
 1566.                 !   enddo
 1567.                 !   endif
 1568.                     mygridpoints = pointsinproc(myid)
 1569.                 
 1570.                     jbmax = mygridpoints / ibmax 
 1571.                     if(jbmax*ibmax.lt.mygridpoints) jbmax = jbmax + 1
 1572.                     ALLOCATE (iPerIJB(ibmax,jbmax))
 1573.                     ALLOCATE (jPerIJB(ibmax,jbmax))
 1574.                     ALLOCATE (ibMaxPerJB(jbmax))
 1575.                 
 1576.                     myfirstlat = firstlat(myid)
 1577.                     mylastlat = lastlat(myid)
 1578.                     firstextlat = MAX(myfirstlat-jovlap,1)
 1579.                     lastextlat = MIN(mylastlat+jovlap,jmax)
 1580.                     ALLOCATE (myfirstlon(firstextlat:lastextlat))
 1581.                     ALLOCATE (mylastlon(firstextlat:lastextlat))
 1582.                     ALLOCATE (iovlap(firstextlat:lastextlat))
 1583.  Vpr4---------<     DO j=firstextlat,lastextlat
 1584.  Vpr4                  i = nint(jovlap*imaxperj(j)/(imax*SIN((j-.5_r8)*hj)))
 1585.  Vpr4                  iovlap(j) = i + 1
 1586.  Vpr4--------->     enddo
 1587.                     IF (slagr) THEN
 1588.                        iovmax = 2
 1589.                      ELSE
 1590.                        iovmax = 0
 1591.                     ENDIF
 1592.                 
 1593.                     ALLOCATE (ibPerIJ(1-iovmax:iMax+iovmax,-1:jMax+2 ))
 1594.                     ALLOCATE (jbPerIJ(1-iovmax:iMax+iovmax,-1:jMax+2 ))
 1595.  V-----------<>     ibPerIJ = 0
 1596.  V-----------<>     jbPerIJ = 0
 1597.                 
 1598.  V-----------<>     myfirstlon(myfirstlat:mylastlat) = &
 1599.                       firstlon(1+myfirstlat-firstlatingroup(procingroup(myid)): &
 1600.                       jbmaxingroup(procingroup(myid))-lastlatingroup(procingroup(myid)) &
 1601.                       + mylastlat,myid)
 1602.  V-----------<>     mylastlon(myfirstlat:mylastlat) = &
 1603.                       lastlon(1+myfirstlat-firstlatingroup(procingroup(myid)): &
 1604.                       jbmaxingroup(procingroup(myid))-lastlatingroup(procingroup(myid)) &
 1605.                       + mylastlat,myid)
 1606.  V-----------<>     ifirst = MINVAL(REAL(myfirstlon(myfirstlat:mylastlat)) &
 1607.                                      / REAL(imaxperj(myfirstlat:mylastlat)) )
 1608.  V-----------<>     ilast  = MAXVAL(REAL(mylastlon(myfirstlat:mylastlat)) &
 1609.                                      / REAL(imaxperj(myfirstlat:mylastlat)) )
 1610.                 
 1611.                     !  interior domain
 1612.                     !  ---------------
 1613.                     ijb = 0
 1614.  1------------<     DO j=myfirstlat,mylastlat
 1615.  1 2----------<        DO i=myfirstlon(j),mylastlon(j)
 1616.  1 2                      ib = MOD(ijb,ibmax)+1
 1617.  1 2                      jb = ijb / ibmax + 1
 1618.  1 2                      ijb = ijb + 1
 1619.  1 2                      iPerIJB(ib,jb) = i
 1620.  1 2                      jPerIJB(ib,jb) = j
 1621.  1 2                      ibPerIJ(i,j) = ib
 1622.  1 2                      jbPerIJ(i,j) = jb
 1623.  1 2---------->        ENDDO
 1624.  1------------>     ENDDO
 1625.  V-----------<>     ibMaxPerJB(1:jbmax-1) = ibmax
 1626.                     ibMaxPerJB(jbmax) = ib
 1627.                     jbmax_ext = jb
 1628.                 
 1629.                     IF (slagr) THEN
 1630.                 
 1631.                        ALLOCATE (iaux(1:iMax,1:jMax))
 1632.  V-----------<>        iaux = -1
 1633.                        !
 1634.                        ! extension zones
 1635.                        ! ---------------
 1636.                        ipar = 0
 1637.                        j1 = myfirstlat - jovlap
 1638.                        j2 = mylastlat + jovlap
 1639.  1------------<        DO jb=j1,j2
 1640.  1                        j = jb
 1641.  1                        iadd = 0
 1642.  1                        IF(jb.lt.1) j = 1 - jb
 1643.  1                        IF (jb.gt.jmax) j = jmax - (jb-jmax-1)
 1644.  1                        IF (j.ne.jb) iadd = imaxperj(j) / 2
 1645.  1                        i1 = NINT(ifirst*imaxperj(j)) - iovlap(j)
 1646.  1                        i2 = NINT(ilast*imaxperj(j)) + iovlap(j)
 1647.  1                        IF (i2-i1+1.ge.imaxperj(j)) THEN
 1648.  1                           i1 = 1
 1649.  1                           i2 = imaxperj(j)
 1650.  1                        ENDIF
 1651.  1 2----------<           DO i=i1+iadd,i2+iadd
 1652.  1 2                         ij = mod(i+imaxperj(j)-1,imaxperj(j)) + 1
 1653.  1 2                         IF (gridmap(ij,j).ne.myid) iaux(ij,j) = gridmap(ij,j)
 1654.  1 2---------->           ENDDO
 1655.  1------------>        ENDDO
 1656.                        jb = jbmax_ext
 1657.  1------------<        DO j=firstextlat,lastextlat
 1658.  1 2----------<           DO i=1,imaxperj(j)
 1659.  1 2                         IF (iaux(i,j).ne.-1) THEN
 1660.  1 2                            ib = MOD(ijb,ibmax)+1
 1661.  1 2                            jb = ijb / ibmax + 1
 1662.  1 2                            ijb = ijb + 1
 1663.  1 2                            ibPerIJ(i,j) = ib
 1664.  1 2                            jbPerIJ(i,j) = jb
 1665.  1 2                         ENDIF
 1666.  1 2---------->           ENDDO
 1667.  1                        i2 = 0
 1668.  1 r2---------<           DO i=1,imaxperj(j)
 1669.  1 r2                        IF (i2.eq.1) THEN
 1670.  1 r2                           IF (iaux(i,j).ne.myrecsgr(4,ipar)) THEN
 1671.  1 r2                              myrecsgr(2,ipar) = i - 1
 1672.  1 r2                              i2 = 0
 1673.  1 r2                              IF (iaux(i,j).ne.-1) THEN
 1674.  1 r2                                 ipar = ipar + 1
 1675.  1 r2                                 myrecsgr(1,ipar) = i
 1676.  1 r2                                 myrecsgr(2,ipar) = imaxperj(j)
 1677.  1 r2                                 myrecsgr(3,ipar) = j
 1678.  1 r2                                 myrecsgr(4,ipar) = iaux(i,j)
 1679.  1 r2                                 i2 = 1
 1680.  1 r2                              ENDIF
 1681.  1 r2                           ENDIF
 1682.  1 r2                         ELSE
 1683.  1 r2                           IF (iaux(i,j).ne.-1) THEN
 1684.  1 r2                              ipar = ipar + 1
 1685.  1 r2                              myrecsgr(1,ipar) = i
 1686.  1 r2                              myrecsgr(2,ipar) = imaxperj(j)
 1687.  1 r2                              myrecsgr(3,ipar) = j
 1688.  1 r2                              myrecsgr(4,ipar) = iaux(i,j)
 1689.  1 r2                              i2 = 1
 1690.  1 r2                           ENDIF
 1691.  1 r2                        ENDIF
 1692.  1 r2--------->           ENDDO
 1693.  1------------>        ENDDO
 1694.                 
 1695.                        jbmax_ext = jb
 1696.                        IF (ipar.gt.ndim) THEN
 1697.                           WRITE(nfprt,*) ' ndim, ipar  ',ndim,ipar
 1698.                           WRITE(nfprt,"(a, ' dimensioning of segment messages insufficient')") h
 1699.                           STOP h
 1700.                        ENDIF
 1701.                 
 1702.                        ! Extensions to use in interpolation
 1703.                 
 1704.                        jh = max(2,jovlap)
 1705.                        IF (-1.ge.myfirstlat-jh) THEN
 1706.                           imp2 = iMaxPerJ(2) / 2
 1707.  V-----------<>           ibPerIJ(   1:   imp2, -1) =  ibPerIJ(imp2+1:iMaxPerJ(2),2)
 1708.  V-----------<>           ibPerIJ(imp2+1:iMaxPerJ(2), -1) =  ibPerIJ(1:imp2,2)
 1709.  V-----------<>           jbPerIJ(   1:   imp2, -1) =  jbPerIJ(imp2+1:iMaxPerJ(2),2)
 1710.  V-----------<>           jbPerIJ(imp2+1:iMaxPerJ(2), -1) =  jbPerIJ(1:imp2,2)
 1711.                        ENDIF 
 1712.                           
 1713.                        IF (0.ge.myfirstlat-jh) THEN
 1714.                           imp2 = iMaxPerJ(1) / 2
 1715.  V-----------<>           ibPerIJ(   1:   imp2, 0) =  ibPerIJ(imp2+1:iMaxPerJ(1),1)
 1716.  V-----------<>           ibPerIJ(imp2+1:iMaxPerJ(1), 0) =  ibPerIJ(1:imp2,1)
 1717.  V-----------<>           jbPerIJ(   1:   imp2, 0) =  jbPerIJ(imp2+1:iMaxPerJ(1),1)
 1718.  V-----------<>           jbPerIJ(imp2+1:iMaxPerJ(1), 0) =  jbPerIJ(1:imp2,1)
 1719.                        ENDIF 
 1720.                 
 1721.                        IF (jmax+1.le.mylastlat+jh) THEN
 1722.                           imp2 = iMaxPerJ(jmax) / 2
 1723.  V-----------<>           ibPerIJ(   1:   imp2, jmax+1) =  ibPerIJ(imp2+1:iMaxPerJ(jmax),jmax)
 1724.  V-----------<>           ibPerIJ(imp2+1:iMaxPerJ(jmax),jmax+1) =  ibPerIJ(1:imp2,jmax)
 1725.  V-----------<>           jbPerIJ(   1:   imp2, jmax+1) =  jbPerIJ(imp2+1:iMaxPerJ(jmax),jmax)
 1726.  V-----------<>           jbPerIJ(imp2+1:iMaxPerJ(jmax),jmax+1) =  jbPerIJ(1:imp2,jmax)
 1727.                        ENDIF 
 1728.                    
 1729.                        IF (jmax+2.le.mylastlat+jh) THEN
 1730.                           imp2 = iMaxPerJ(jmax-1) / 2
 1731.  V-----------<>           ibPerIJ(   1:   imp2, jmax+2) =  ibPerIJ(imp2+1:iMaxPerJ(jmax-1),jmax-1)
 1732.  V-----------<>           ibPerIJ(imp2+1:iMaxPerJ(jmax-1),jmax+2) =  ibPerIJ(1:imp2,jmax-1)
 1733.  V-----------<>           jbPerIJ(   1:   imp2, jmax+2) =  jbPerIJ(imp2+1:iMaxPerJ(jmax-1),jmax-1)
 1734.  V-----------<>           jbPerIJ(imp2+1:iMaxPerJ(jmax-1),jmax+2) =  jbPerIJ(1:imp2,jmax-1)
 1735.                        ENDIF 
 1736.                 
 1737.                 
 1738.  1------------<        DO j = MAX(-1,myfirstlat-jovlap),MIN(mylastlat+jovlap,jmax+2)
 1739.  1                        jb = j
 1740.  1                        if (j.eq.-1) jb =2
 1741.  1                        if (j.eq.0) jb =1
 1742.  1                        if (j.eq.jmax+1) jb =jmax
 1743.  1                        if (j.eq.jmax+2) jb =jmax-1
 1744.  1                        ib = iMaxPerJ(jb)
 1745.  1                        ibPerIJ(   0,  j) = ibPerIJ(ib,j)
 1746.  1                        ibPerIJ(  -1,  j) = ibPerIJ(ib-1,j)
 1747.  1                        ibPerIJ(ib+1,j) = ibPerIJ(   1,  j)
 1748.  1                        ibPerIJ(ib+2,j) = ibPerIJ(   2,  j)
 1749.  1                        jbPerIJ(   0,  j) = jbPerIJ(ib,j)
 1750.  1                        jbPerIJ(  -1,  j) = jbPerIJ(ib-1,j)
 1751.  1                        jbPerIJ(ib+1,j) = jbPerIJ(   1,  j)
 1752.  1                        jbPerIJ(ib+2,j) = jbPerIJ(   2,  j)
 1753.  1------------>        END DO
 1754.                 
 1755.                        !sort messages by processors
 1756.                        !---------------------------
 1757.  1------------<        DO i=2,ipar
 1758.  1 2----------<           DO j=i,2,-1
 1759.  1 2                         IF(myrecsgr(4,j).lt.myrecsgr(4,j-1)) THEN
 1760.  1 2 Vsf-----<>                 aux = myrecsgr(:,j-1)
 1761.  1 2 f-------<>                 myrecsgr(:,j-1) = myrecsgr(:,j)
 1762.  1 2 f-------<>                 myrecsgr(:,j) = aux
 1763.  1 2                           ELSE
 1764.  1 2                            EXIT
 1765.  1 2                         ENDIF
 1766.  1 2---------->           ENDDO
 1767.  1------------>        ENDDO
 1768.                        myrecspr(1,1) = myrecsgr(4,1)
 1769.                        nrecs_gr = 1
 1770.  1------------<        DO i=2,ipar
 1771.  1                        IF(myrecsgr(4,i).ne.myrecsgr(4,i-1)) THEN
 1772.  1                           nrecs_gr = nrecs_gr + 1
 1773.  1                           myrecspr(2,nrecs_gr-1) = i - 1
 1774.  1                           myrecspr(1,nrecs_gr) = myrecsgr(4,i)
 1775.  1                        ENDIF
 1776.  1------------>        ENDDO
 1777.                        myrecspr(2,nrecs_gr) = ipar
 1778.                        IF (ipar.eq.0) THEN
 1779.                           nrecs_gr = 0
 1780.                           nsends_gr = 0
 1781.                        ENDIF
 1782.                 
 1783.                     ENDIF
 1784.                 
 1785.                     ! define messages to be exchanged between fourier and grid computations
 1786.                     ! ---------------------------------------------------------------------
 1787.                     ndim_f = jMaxlocal_f*(MAXVAL(nprocsingroup)+3)
 1788.                     ALLOCATE (messages_f(4,ndim_f))
 1789.                     ALLOCATE (messproc_f(2,0:nproc))
 1790.                     ALLOCATE (messages_g(4,ndim_f))
 1791.                     ALLOCATE (messproc_g(2,0:nproc))
 1792.                     ipar = 1
 1793.  1------------<     DO j=myfirstlat_f,mylastlat_f
 1794.  1                     messages_f(1,ipar) = 1
 1795.  1                     messages_f(3,ipar) = j
 1796.  1                     messages_f(4,ipar) = gridmap(1,j)
 1797.  1 r2---------<        DO i=2,imaxperj(j)
 1798.  1 r2                     IF (gridmap(i,j).ne.messages_f(4,ipar)) THEN
 1799.  1 r2                        messages_f(2,ipar) = i-1
 1800.  1 r2                        IF(messages_f(4,ipar).ne.myid) ipar = ipar + 1
 1801.  1 r2                        messages_f(1,ipar) = i
 1802.  1 r2                        messages_f(3,ipar) = j
 1803.  1 r2                        messages_f(4,ipar) = gridmap(i,j)
 1804.  1 r2                     ENDIF
 1805.  1 r2                     IF (i.eq.imaxperj(j)) THEN
 1806.  1 r2                        messages_f(2,ipar) = i
 1807.  1 r2                        IF(messages_f(4,ipar).ne.myid) ipar = ipar + 1
 1808.  1 r2                     ENDIF
 1809.  1 r2--------->        ENDDO
 1810.  1------------>     ENDDO
 1811.                     ipar = ipar - 1
 1812.                     IF (ipar.gt.ndim_f) THEN
 1813.                        WRITE(nfprt,*) ' ndim_f, ipar  ',ndim_f,ipar
 1814.                        WRITE(nfprt,"(a, ' dimensioning of segment messages insufficient')") h
 1815.                        STOP h
 1816.                     ENDIF
 1817.                 
 1818.                     !sort messages by processors
 1819.                     !---------------------------
 1820.  1------------<     DO i=2,ipar
 1821.  1 2----------<        DO j=i,2,-1
 1822.  1 2                      IF(messages_f(4,j).lt.messages_f(4,j-1)) THEN
 1823.  1 2 Vsf-----<>              aux = messages_f(:,j-1)
 1824.  1 2 f-------<>              messages_f(:,j-1) = messages_f(:,j)
 1825.  1 2 f-------<>              messages_f(:,j) = aux
 1826.  1 2                        ELSE
 1827.  1 2                         EXIT
 1828.  1 2                      ENDIF
 1829.  1 2---------->        ENDDO
 1830.  1------------>     ENDDO
 1831.                     messproc_f(2,0) = 0
 1832.                     IF (ipar.gt.0) THEN
 1833.                        messproc_f(1,1) = messages_f(4,1)
 1834.                        nrecs_f = 1
 1835.  1------------<        DO i=2,ipar
 1836.  1                        IF(messages_f(4,i).ne.messages_f(4,i-1)) THEN
 1837.  1                           nrecs_f = nrecs_f + 1
 1838.  1                           messproc_f(2,nrecs_f-1) = i - 1
 1839.  1                           messproc_f(1,nrecs_f) = messages_f(4,i)
 1840.  1                        ENDIF
 1841.  1------------>        ENDDO
 1842.                        messproc_f(2,nrecs_f) = ipar
 1843.                      ELSE
 1844.                        nrecs_f = 0
 1845.                     ENDIF
 1846.                 
 1847.                     !  set communication structure for grid diagnostics
 1848.                     !  ------------------------------------------------
 1849.                     ALLOCATE(firstandlastlat(2,0:maxnodes-1))
 1850.                     ALLOCATE (nlatsinproc_d(0:maxNodes-1))
 1851.                     lat = jmax / maxnodes
 1852.                     nrest = jmax - lat * maxnodes
 1853.                     np = nrest / 2
 1854.                     np1 = nrest - np
 1855.                     n = 0
 1856.  r4-----------<     DO i=0,maxnodes-1
 1857.  r4                    firstandlastlat(1,i) = n + 1
 1858.  r4                    IF (i.lt.np.or.i.ge.maxnodes-np1) THEN
 1859.  r4                       n = n + lat + 1
 1860.  r4                      ELSE
 1861.  r4                       n = n + lat
 1862.  r4                    ENDIF
 1863.  r4                    firstandlastlat(2,i) = n
 1864.  r4----------->     ENDDO
 1865.  V-----------<>     nlatsinproc_d = firstandlastlat(2,:) - firstandlastlat(1,:) + 1
 1866.                     myfirstlat_diag = firstandlastlat(1,myid)
 1867.                     mylastlat_diag = firstandlastlat(2,myid)
 1868.                     myJMax_d = mylastlat_diag - myfirstlat_diag + 1
 1869.                          
 1870.                     ndim = (5+MAXVAL(nprocsingroup))*(lat+1)
 1871.                     ALLOCATE (mysends_diag(4,ndim))
 1872.                     ALLOCATE (mysendspr_diag(2,0:nproc))
 1873.                     ALLOCATE (myrecs_diag(4,ndim))
 1874.                     ALLOCATE (myrecspr_diag(2,0:nproc))
 1875.                 
 1876.                     ij = 0
 1877.  1------------<     DO j=myfirstlat_diag,mylastlat_diag
 1878.  1                     ij = ij + 1
 1879.  1                     myrecs_diag(1,ij) = 1
 1880.  1                     myrecs_diag(3,ij) = j
 1881.  1                     myrecs_diag(4,ij) = gridmap(1,j)
 1882.  1 r4---------<        DO i=2,imaxperj(j)
 1883.  1 r4                     IF (gridmap(i,j).ne.myrecs_diag(4,ij)) THEN
 1884.  1 r4                        myrecs_diag(2,ij) = i-1
 1885.  1 r4                        ij = ij + 1
 1886.  1 r4                        myrecs_diag(1,ij) = i
 1887.  1 r4                        myrecs_diag(3,ij) = j
 1888.  1 r4                        myrecs_diag(4,ij) = gridmap(i,j)
 1889.  1 r4                     ENDIF
 1890.  1 r4--------->        ENDDO
 1891.  1                     myrecs_diag(2,ij) = imaxperj(j)
 1892.  1------------>     ENDDO
 1893.                 
 1894.                     !sort messages by processors
 1895.                     !---------------------------
 1896.  1------------<     DO i=2,ij   
 1897.  1 2----------<        DO j=i,2,-1
 1898.  1 2                      IF(myrecs_diag(4,j).lt.myrecs_diag(4,j-1)) THEN
 1899.  1 2 Vsf-----<>              aux = myrecs_diag(:,j-1)
 1900.  1 2 f-------<>              myrecs_diag(:,j-1) = myrecs_diag(:,j)
 1901.  1 2 f-------<>              myrecs_diag(:,j) = aux
 1902.  1 2                        ELSE
 1903.  1 2                         EXIT
 1904.  1 2                      ENDIF
 1905.  1 2---------->        ENDDO
 1906.  1------------>     ENDDO
 1907.                     n = 0
 1908.                     i1 = 0
 1909.  1------------<     DO i=1,ij 
 1910.  1                     IF(myrecs_diag(4,i).eq.myid) THEN
 1911.  1                       i1 = i
 1912.  1                       n = n + 1
 1913.  1                     ENDIF
 1914.  1------------>     ENDDO
 1915.                     ij = ij - n
 1916.  1------------<     DO i=i1-n+1,ij
 1917.  1 Vs--------<>        myrecs_diag(:,i) = myrecs_diag(:,i+n)
 1918.  1------------>     ENDDO
 1919.                     myrecspr_diag(2,0) = 0
 1920.                     IF (ij.gt.0) THEN
 1921.                        myrecspr_diag(1,1) = myrecs_diag(4,1)
 1922.                        nrecs_diag = 1
 1923.  1------------<        DO i=2,ij
 1924.  1                        IF(myrecs_diag(4,i).ne.myrecs_diag(4,i-1)) THEN
 1925.  1                           nrecs_diag = nrecs_diag + 1
 1926.  1                           myrecspr_diag(2,nrecs_diag-1) = i - 1
 1927.  1                           myrecspr_diag(1,nrecs_diag) = myrecs_diag(4,i)
 1928.  1                        ENDIF
 1929.  1------------>        ENDDO
 1930.                        myrecspr_diag(2,nrecs_diag) = ij
 1931.                      ELSE
 1932.                        nrecs_diag = 0
 1933.                     ENDIF
 1934.                 
 1935.                   END SUBROUTINE GridDecomposition
ftn-5002 ftn: NOTE File = Sizes.f90, Line = 1935 
  Local variable "IND" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 1935 
  Local variable "IL1" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 1935 
  Local variable "IJ1" is declared but neither defined nor used.

ftn-5002 ftn: NOTE File = Sizes.f90, Line = 1935 
  Local variable "IL2" is declared but neither defined nor used.

 1936.                 
 1937.                 END MODULE Sizes

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 391 
  A loop starting at line 391 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 392 
  A loop starting at line 392 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 393 
  A loop starting at line 393 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 395 
  A loop starting at line 395 was not vectorized because a recurrence was found on "MN" at line 397.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 396 
  A loop starting at line 396 was unrolled 4 times.

ftn-6209 ftn: VECTOR File = Sizes.f90, Line = 396 
  A loop starting at line 396 was partially vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 407 
  A loop starting at line 407 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 408 
  A loop starting at line 408 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 409 
  A loop starting at line 409 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 411 
  A loop starting at line 411 was not vectorized because a recurrence was found on "MN" at line 413.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 412 
  A loop starting at line 412 was unrolled 4 times.

ftn-6209 ftn: VECTOR File = Sizes.f90, Line = 412 
  A loop starting at line 412 was partially vectorized.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 420 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 421 
  Routine _INQUIRE was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3149 ftn: IPA File = Sizes.f90, Line = 421 
  Routine DUMPSIZES was not inlined because it is a leaf routine which is too large to expand. 

ftn-6250 ftn: VECTOR File = Sizes.f90, Line = 443 
  A loop starting at line 443 was not vectorized for an unspecified reason.

ftn-6327 ftn: VECTOR File = Sizes.f90, Line = 460 
  A loop starting at line 460 was not vectorized because it required a vector test not supported on this architecture.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 460 
  A loop starting at line 460 was unrolled 8 times.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 473 
  A loop starting at line 473 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 473 
  A loop starting at line 473 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 483 
  A loop starting at line 483 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 484 
  A loop starting at line 484 was not vectorized because a recurrence was found on "N" at line 494.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 485 
  A loop starting at line 485 was not vectorized because it contains a reference to a non-vector intrinsic on line 489.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 500 
  A loop starting at line 500 was not vectorized because a recurrence was found on "M" at line 506.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 501 
  A loop starting at line 501 was not vectorized because it contains a reference to a non-vector intrinsic on line 503.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 508 
  A loop starting at line 508 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 508 
  A loop starting at line 508 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 536 
  A loop starting at line 536 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 538 
  A loop starting at line 538 was vectorized.

ftn-6332 ftn: VECTOR File = Sizes.f90, Line = 539 
  A loop starting at line 539 was not vectorized because it does not map well onto the target architecture.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 542 
  A loop starting at line 542 was vectorized.

ftn-6202 ftn: VECTOR File = Sizes.f90, Line = 554 
  A loop starting at line 554 was replaced by a library call.

ftn-6202 ftn: VECTOR File = Sizes.f90, Line = 555 
  A loop starting at line 555 was replaced by a library call.

ftn-6202 ftn: VECTOR File = Sizes.f90, Line = 556 
  A loop starting at line 556 was replaced by a library call.

ftn-6202 ftn: VECTOR File = Sizes.f90, Line = 557 
  A loop starting at line 557 was replaced by a library call.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 562 
  A loop starting at line 562 was not vectorized because a recurrence was found on "JLAST" at line 572.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 563 
  A loop starting at line 563 was not vectorized because a recurrence was found on "NPOINTS" at line 565.

ftn-6332 ftn: VECTOR File = Sizes.f90, Line = 574 
  A loop starting at line 574 was not vectorized because it does not map well onto the target architecture.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 578 
  A loop starting at line 578 was not vectorized because a recurrence was found on "MAXPOINTSOLD" at line 602.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 580 
  A loop starting at line 580 was not vectorized because a recurrence was found on "JLAST" at line 590.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 581 
  A loop starting at line 581 was not vectorized because a recurrence was found on "NPOINTS1" at line 583.

ftn-6332 ftn: VECTOR File = Sizes.f90, Line = 593 
  A loop starting at line 593 was not vectorized because it does not map well onto the target architecture.

ftn-6202 ftn: VECTOR File = Sizes.f90, Line = 598 
  A loop starting at line 598 was replaced by a library call.

ftn-6202 ftn: VECTOR File = Sizes.f90, Line = 599 
  A loop starting at line 599 was replaced by a library call.

ftn-6202 ftn: VECTOR File = Sizes.f90, Line = 600 
  A loop starting at line 600 was replaced by a library call.

ftn-6202 ftn: VECTOR File = Sizes.f90, Line = 601 
  A loop starting at line 601 was replaced by a library call.

ftn-6250 ftn: VECTOR File = Sizes.f90, Line = 610 
  A loop starting at line 610 was not vectorized for an unspecified reason.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 616 
  A loop starting at line 616 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 616 
  A loop starting at line 616 was vectorized.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 621 
  A loop starting at line 621 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 621 
  A loop starting at line 621 was vectorized.

ftn-6202 ftn: VECTOR File = Sizes.f90, Line = 624 
  A loop starting at line 624 was replaced by a library call.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 626 
  A loop starting at line 626 was not vectorized because it contains a reference to a non-vector intrinsic on line 627.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 629 
  A loop starting at line 629 was not vectorized because a recurrence was found on "MLAST" at line 635.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 631 
  A loop starting at line 631 was not vectorized because a recurrence was found on "MLAST" at line 635.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 654 
  A loop starting at line 654 was unrolled 4 times.

ftn-6209 ftn: VECTOR File = Sizes.f90, Line = 654 
  A loop starting at line 654 was partially vectorized.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 659 
  A loop starting at line 659 was unrolled 4 times.

ftn-6289 ftn: VECTOR File = Sizes.f90, Line = 659 
  A loop starting at line 659 was not vectorized because a recurrence was found on "MLAST" between lines 660 and 661.

ftn-6250 ftn: VECTOR File = Sizes.f90, Line = 667 
  A loop starting at line 667 was not vectorized for an unspecified reason.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 668 
  Routine FATALERROR was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 676 
  A loop starting at line 676 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 677 
  A loop starting at line 677 was not vectorized because a recurrence was found on "NODEHASJ_F" at line 682.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 681 
  A loop starting at line 681 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 681 
  A loop starting at line 681 was vectorized.

ftn-6332 ftn: VECTOR File = Sizes.f90, Line = 685 
  A loop starting at line 685 was not vectorized because it does not map well onto the target architecture.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 690 
  A loop starting at line 690 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 691 
  A loop starting at line 691 was not vectorized because a recurrence was found on "JMINPERM" at line 693.

ftn-6332 ftn: VECTOR File = Sizes.f90, Line = 693 
  A loop starting at line 693 was not vectorized because it does not map well onto the target architecture.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 695 
  A loop starting at line 695 was vectorized.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 701 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 702 
  Routine _INQUIRE was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3149 ftn: IPA File = Sizes.f90, Line = 702 
  Routine DUMPSIZES was not inlined because it is a leaf routine which is too large to expand. 

ftn-3021 ftn: IPA File = Sizes.f90, Line = 723 
  Routine FATALERROR was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 755 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 759 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 766 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 767 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-6286 ftn: VECTOR File = Sizes.f90, Line = 768 
  A loop starting at line 768 was not vectorized because it contains input/output operations at line 771.

ftn-6262 ftn: VECTOR File = Sizes.f90, Line = 773 
  A loop starting at line 773 was not vectorized because it contains a call to a subroutine or function on line 776.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 778 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 782 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-6286 ftn: VECTOR File = Sizes.f90, Line = 783 
  A loop starting at line 783 was not vectorized because it contains input/output operations at line 786.

ftn-6262 ftn: VECTOR File = Sizes.f90, Line = 788 
  A loop starting at line 788 was not vectorized because it contains a call to a subroutine or function on line 790.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 792 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 845 
  Routine FATALERROR was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 855 
  Routine FATALERROR was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 867 
  Routine FATALERROR was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-6306 ftn: VECTOR File = Sizes.f90, Line = 872 
  A loop starting at line 872 was not vectorized because the iteration space is too irregular.

ftn-6289 ftn: VECTOR File = Sizes.f90, Line = 875 
  A loop starting at line 875 was not vectorized because a recurrence was found on "NODEHASM" between lines 878 and 882.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 877 
  A loop starting at line 877 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 877 
  A loop starting at line 877 was vectorized.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 881 
  A loop starting at line 881 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 881 
  A loop starting at line 881 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 895 
  A loop starting at line 895 was vectorized.

ftn-6289 ftn: VECTOR File = Sizes.f90, Line = 897 
  A loop starting at line 897 was not vectorized because a recurrence was found on "MSPERPROC" between lines 900 and 905.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 899 
  A loop starting at line 899 was unrolled 4 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 899 
  A loop starting at line 899 was not vectorized because a recurrence was found on "MSPERPROC" at line 900.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 904 
  A loop starting at line 904 was unrolled 4 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 904 
  A loop starting at line 904 was not vectorized because a recurrence was found on "MSPERPROC" at line 905.

ftn-6250 ftn: VECTOR File = Sizes.f90, Line = 914 
  A loop starting at line 914 was not vectorized for an unspecified reason.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 915 
  Routine FATALERROR was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 930 
  Routine FATALERROR was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 932 
  A loop starting at line 932 was vectorized.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 948 
  Routine FATALERROR was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 956 
  Routine FATALERROR was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 962 
  A loop starting at line 962 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 963 
  A loop starting at line 963 was vectorized.

ftn-6289 ftn: VECTOR File = Sizes.f90, Line = 965 
  A loop starting at line 965 was not vectorized because a recurrence was found on "MNSPERPROC" between lines 968 and 973.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 967 
  A loop starting at line 967 was unrolled 2 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 967 
  A loop starting at line 967 was not vectorized because a recurrence was found on "MNSPERPROC" at line 968.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 972 
  A loop starting at line 972 was unrolled 2 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 972 
  A loop starting at line 972 was not vectorized because a recurrence was found on "MNSPERPROC" at line 973.

ftn-6332 ftn: VECTOR File = Sizes.f90, Line = 983 
  A loop starting at line 983 was not vectorized because it does not map well onto the target architecture.

ftn-6332 ftn: VECTOR File = Sizes.f90, Line = 984 
  A loop starting at line 984 was not vectorized because it does not map well onto the target architecture.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1008 
  A loop starting at line 1008 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1009 
  A loop starting at line 1009 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1010 
  A loop starting at line 1010 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1012 
  A loop starting at line 1012 was not vectorized because a recurrence was found on "MN" at line 1014.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1013 
  A loop starting at line 1013 was unrolled 4 times.

ftn-6209 ftn: VECTOR File = Sizes.f90, Line = 1013 
  A loop starting at line 1013 was partially vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1030 
  A loop starting at line 1030 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1031 
  A loop starting at line 1031 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1032 
  A loop starting at line 1032 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1034 
  A loop starting at line 1034 was not vectorized because a recurrence was found on "MN" at line 1036.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1035 
  A loop starting at line 1035 was unrolled 4 times.

ftn-6209 ftn: VECTOR File = Sizes.f90, Line = 1035 
  A loop starting at line 1035 was partially vectorized.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1057 
  A loop starting at line 1057 was unrolled 4 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1057 
  A loop starting at line 1057 was not vectorized because a recurrence was found on "REST" at line 1060.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1072 
  A loop starting at line 1072 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1073 
  A loop starting at line 1073 was not vectorized because a recurrence was found on "MN" at line 1078.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1075 
  A loop starting at line 1075 was not vectorized because a recurrence was found on "IP" at line 1081.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1077 
  A loop starting at line 1077 was vectorized.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 1102 
  A loop starting at line 1102 was not vectorized because it contains a reference to a non-vector intrinsic on line 1104.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 1113 
  A loop starting at line 1113 was not vectorized because it contains a reference to a non-vector intrinsic on line 1114.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1128 
  A loop starting at line 1128 was not vectorized because a recurrence was found on "SENDS" at line 1131.

ftn-6250 ftn: VECTOR File = Sizes.f90, Line = 1129 
  A loop starting at line 1129 was not vectorized for an unspecified reason.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1137 
  A loop starting at line 1137 was unrolled 4 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1137 
  A loop starting at line 1137 was not vectorized because a recurrence was found on "INI" at line 1138.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1143 
  A loop starting at line 1143 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1144 
  A loop starting at line 1144 was vectorized.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1150 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3149 ftn: IPA File = Sizes.f90, Line = 1150 
  Routine DUMPSPECDECOMP was not inlined because it is a leaf routine which is too large to expand. 

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1162 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1167 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1169 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-6286 ftn: VECTOR File = Sizes.f90, Line = 1170 
  A loop starting at line 1170 was not vectorized because it contains input/output operations at line 1173.

ftn-6262 ftn: VECTOR File = Sizes.f90, Line = 1175 
  A loop starting at line 1175 was not vectorized because it contains a call to a subroutine or function on line 1177.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1179 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1182 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-6286 ftn: VECTOR File = Sizes.f90, Line = 1183 
  A loop starting at line 1183 was not vectorized because it contains input/output operations at line 1186.

ftn-6262 ftn: VECTOR File = Sizes.f90, Line = 1188 
  A loop starting at line 1188 was not vectorized because it contains a call to a subroutine or function on line 1190.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1192 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1195 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-6286 ftn: VECTOR File = Sizes.f90, Line = 1196 
  A loop starting at line 1196 was not vectorized because it contains input/output operations at line 1199.

ftn-6262 ftn: VECTOR File = Sizes.f90, Line = 1201 
  A loop starting at line 1201 was not vectorized because it contains a call to a subroutine or function on line 1203.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1205 
  Routine MSGDUMP was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1235 
  Routine OMP_IN_PARALLEL was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1237 
  Routine OMP_GET_NUM_THREADS was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1238 
  Routine OMP_GET_THREAD_NUM was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1261 
  Routine FATALERROR was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1292 
  Routine OMP_IN_PARALLEL was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1294 
  Routine OMP_GET_NUM_THREADS was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-3021 ftn: IPA File = Sizes.f90, Line = 1295 
  Routine OMP_GET_THREAD_NUM was not inlined because the compiler was unable to locate the routine to expand it inline.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1299 
  A loop starting at line 1299 was unrolled 4 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1299 
  A loop starting at line 1299 was not vectorized because a recurrence was found on "I" at line 1304.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1315 
  A loop starting at line 1315 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1315 
  A loop starting at line 1315 was vectorized.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1345 
  A loop starting at line 1345 was unrolled 4 times.

ftn-6209 ftn: VECTOR File = Sizes.f90, Line = 1345 
  A loop starting at line 1345 was partially vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1348 
  A loop starting at line 1348 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1349 
  A loop starting at line 1349 was vectorized.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1355 
  A loop starting at line 1355 was unrolled 4 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1355 
  A loop starting at line 1355 was not vectorized because a recurrence was found on "CI" at line 1356.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1360 
  A loop starting at line 1360 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1360 
  A loop starting at line 1360 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1364 
  A loop starting at line 1364 was vectorized.

ftn-6010 ftn: SCALAR File = Sizes.f90, Line = 1373 
  A divide was turned into a multiply by a reciprocal

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1376 
  A loop starting at line 1376 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1376 
  A loop starting at line 1376 was vectorized.

ftn-6004 ftn: SCALAR File = Sizes.f90, Line = 1382 
  A loop starting at line 1382 was fused with the loop starting at line 1376.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1461 
  A loop starting at line 1461 was vectorized.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1462 
  A loop starting at line 1462 was unrolled 4 times.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1462 
  A loop starting at line 1462 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1467 
  A loop starting at line 1467 was not vectorized because a recurrence was found on "I" at line 1469.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1468 
  A loop starting at line 1468 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1478 
  A loop starting at line 1478 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1481 
  A loop starting at line 1481 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1482 
  A loop starting at line 1482 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1486 
  A loop starting at line 1486 was not vectorized because a recurrence was found on "USEDINLAT" at line 1499.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1493 
  A loop starting at line 1493 was not vectorized because a recurrence was found on "LAT" at line 1495.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1506 
  A loop starting at line 1506 was vectorized.

ftn-6332 ftn: VECTOR File = Sizes.f90, Line = 1507 
  A loop starting at line 1507 was not vectorized because it does not map well onto the target architecture.

ftn-6010 ftn: SCALAR File = Sizes.f90, Line = 1509 
  A divide was turned into a multiply by a reciprocal

ftn-6010 ftn: SCALAR File = Sizes.f90, Line = 1511 
  A divide was turned into a multiply by a reciprocal

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1526 
  A loop starting at line 1526 was not vectorized because a recurrence was found on "FIRSTLON" at line 1527.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1528 
  A loop starting at line 1528 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1529 
  A loop starting at line 1529 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1530 
  A loop starting at line 1530 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1531 
  A loop starting at line 1531 was not vectorized because a recurrence was found on "LON" at line 1538.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1532 
  A loop starting at line 1532 was unrolled 4 times.

ftn-6213 ftn: VECTOR File = Sizes.f90, Line = 1532 
  A loop starting at line 1532 was conditionally vectorized.

ftn-6008 ftn: SCALAR File = Sizes.f90, Line = 1533 
  A loop starting at line 1533 was unwound.

ftn-6270 ftn: VECTOR File = Sizes.f90, Line = 1533 
  A loop starting at line 1533 was not vectorized because it contains conditional code which is more efficient if executed in
  scalar mode.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1554 
  A loop starting at line 1554 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1555 
  A loop starting at line 1555 was vectorized.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1583 
  A loop starting at line 1583 was unrolled 4 times.

ftn-6209 ftn: VECTOR File = Sizes.f90, Line = 1583 
  A loop starting at line 1583 was partially vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1595 
  A loop starting at line 1595 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1596 
  A loop starting at line 1596 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1598 
  A loop starting at line 1598 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1602 
  A loop starting at line 1602 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1606 
  A loop starting at line 1606 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1608 
  A loop starting at line 1608 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1614 
  A loop starting at line 1614 was not vectorized because a recurrence was found on "IJB" at line 1618.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 1615 
  A loop starting at line 1615 was not vectorized because it contains a reference to a non-vector intrinsic on line 1619.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1625 
  A loop starting at line 1625 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1632 
  A loop starting at line 1632 was vectorized.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1639 
  A loop starting at line 1639 was not vectorized because a recurrence was found on "IAUX" at line 1653.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 1651 
  A loop starting at line 1651 was not vectorized because it contains a reference to a non-vector intrinsic on line 1653.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1657 
  A loop starting at line 1657 was not vectorized because a recurrence was found on "IJB" at line 1662.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 1658 
  A loop starting at line 1658 was not vectorized because it contains a reference to a non-vector intrinsic on line 1663.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1668 
  A loop starting at line 1668 was unrolled 2 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1668 
  A loop starting at line 1668 was not vectorized because a recurrence was found on "I2" at line 1672.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1707 
  A loop starting at line 1707 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1708 
  A loop starting at line 1708 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1709 
  A loop starting at line 1709 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1710 
  A loop starting at line 1710 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1715 
  A loop starting at line 1715 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1716 
  A loop starting at line 1716 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1717 
  A loop starting at line 1717 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1718 
  A loop starting at line 1718 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1723 
  A loop starting at line 1723 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1724 
  A loop starting at line 1724 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1725 
  A loop starting at line 1725 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1726 
  A loop starting at line 1726 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1731 
  A loop starting at line 1731 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1732 
  A loop starting at line 1732 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1733 
  A loop starting at line 1733 was vectorized.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1734 
  A loop starting at line 1734 was vectorized.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 1738 
  A loop starting at line 1738 was not vectorized because it contains a reference to a non-vector intrinsic on line 1744.

ftn-6306 ftn: VECTOR File = Sizes.f90, Line = 1757 
  A loop starting at line 1757 was not vectorized because the iteration space is too irregular.

ftn-6315 ftn: VECTOR File = Sizes.f90, Line = 1758 
  A loop starting at line 1758 was not vectorized because the target array (AUX) would require rank expansion.

ftn-6205 ftn: VECTOR File = Sizes.f90, Line = 1760 
  A loop starting at line 1760 was vectorized with a single vector iteration.

ftn-6004 ftn: SCALAR File = Sizes.f90, Line = 1761 
  A loop starting at line 1761 was fused with the loop starting at line 1760.

ftn-6004 ftn: SCALAR File = Sizes.f90, Line = 1762 
  A loop starting at line 1762 was fused with the loop starting at line 1760.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 1770 
  A loop starting at line 1770 was not vectorized because it contains a reference to a non-vector intrinsic on line 1773.

ftn-6332 ftn: VECTOR File = Sizes.f90, Line = 1787 
  A loop starting at line 1787 was not vectorized because it does not map well onto the target architecture.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1793 
  A loop starting at line 1793 was not vectorized because a recurrence was found on "IPAR" at line 1800.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1797 
  A loop starting at line 1797 was unrolled 2 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1797 
  A loop starting at line 1797 was not vectorized because a recurrence was found on "MESSAGES_F" at line 1799.

ftn-6306 ftn: VECTOR File = Sizes.f90, Line = 1820 
  A loop starting at line 1820 was not vectorized because the iteration space is too irregular.

ftn-6315 ftn: VECTOR File = Sizes.f90, Line = 1821 
  A loop starting at line 1821 was not vectorized because the target array (AUX) would require rank expansion.

ftn-6205 ftn: VECTOR File = Sizes.f90, Line = 1823 
  A loop starting at line 1823 was vectorized with a single vector iteration.

ftn-6004 ftn: SCALAR File = Sizes.f90, Line = 1824 
  A loop starting at line 1824 was fused with the loop starting at line 1823.

ftn-6004 ftn: SCALAR File = Sizes.f90, Line = 1825 
  A loop starting at line 1825 was fused with the loop starting at line 1823.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 1835 
  A loop starting at line 1835 was not vectorized because it contains a reference to a non-vector intrinsic on line 1838.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1856 
  A loop starting at line 1856 was unrolled 4 times.

ftn-6289 ftn: VECTOR File = Sizes.f90, Line = 1856 
  A loop starting at line 1856 was not vectorized because a recurrence was found on "N" between lines 1857 and 1858.

ftn-6204 ftn: VECTOR File = Sizes.f90, Line = 1865 
  A loop starting at line 1865 was vectorized.

ftn-6332 ftn: VECTOR File = Sizes.f90, Line = 1870 
  A loop starting at line 1870 was not vectorized because it does not map well onto the target architecture.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1877 
  A loop starting at line 1877 was not vectorized because a recurrence was found on "IJ" at line 1878.

ftn-6005 ftn: SCALAR File = Sizes.f90, Line = 1882 
  A loop starting at line 1882 was unrolled 4 times.

ftn-6254 ftn: VECTOR File = Sizes.f90, Line = 1882 
  A loop starting at line 1882 was not vectorized because a recurrence was found on "MYRECS_DIAG" at line 1884.

ftn-6306 ftn: VECTOR File = Sizes.f90, Line = 1896 
  A loop starting at line 1896 was not vectorized because the iteration space is too irregular.

ftn-6315 ftn: VECTOR File = Sizes.f90, Line = 1897 
  A loop starting at line 1897 was not vectorized because the target array (AUX) would require rank expansion.

ftn-6205 ftn: VECTOR File = Sizes.f90, Line = 1899 
  A loop starting at line 1899 was vectorized with a single vector iteration.

ftn-6004 ftn: SCALAR File = Sizes.f90, Line = 1900 
  A loop starting at line 1900 was fused with the loop starting at line 1899.

ftn-6004 ftn: SCALAR File = Sizes.f90, Line = 1901 
  A loop starting at line 1901 was fused with the loop starting at line 1899.

ftn-6270 ftn: VECTOR File = Sizes.f90, Line = 1909 
  A loop starting at line 1909 was not vectorized because it contains conditional code which is more efficient if executed in
  scalar mode.

ftn-6294 ftn: VECTOR File = Sizes.f90, Line = 1916 
  A loop starting at line 1916 was not vectorized because a better candidate was found at line 1917.

ftn-6205 ftn: VECTOR File = Sizes.f90, Line = 1917 
  A loop starting at line 1917 was vectorized with a single vector iteration.

ftn-6263 ftn: VECTOR File = Sizes.f90, Line = 1923 
  A loop starting at line 1923 was not vectorized because it contains a reference to a non-vector intrinsic on line 1926.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                  C r o s s   R e f e r e n c e   for   SIZES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Name                            Storage                           Attributes
----                            -------                           ----------

ACOS                                                              Function, REAL, Implicit type, INTRINSIC
  Decl
  Set 
  Used    1443

ADJUSTL                                                           Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0       0       0       0     737     747     759     761     845     855     867     930     948     956

ALL                                                               Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used    1129

ANY                                                               Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0     914

AUX                             Stack                             INTEGER, DIMENSION(4)
  Decl    1399
  Set     1760    1823    1899
  Used    1762    1825    1901

C0                              Stack                             CHARACTER(8)
  Decl     824
  Set 
  Used     844     854     866     929     947     955

C1                              Stack                             CHARACTER(10)
  Decl     713
  Set 
  Used     731     738     742     756

C2                              Stack                             CHARACTER(10)
  Decl     713
  Set 
  Used     732     739     743     757

C3                              Stack                             CHARACTER(10)
  Decl     713
  Set 
  Used     733     744     758

C4                              Stack                             CHARACTER(10)
  Decl     713
  Set 
  Used     734

CHUNK                           Stack                             INTEGER
  Decl    1220
  Set     1240
  Used    1241    1243    1244    1246    1247

CI                              Heap                              REAL(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE
  Decl     355
  Set     1354    1356    1358
  Used    1339    1361

CL                              Heap                              REAL(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE
  Decl     361
  Set     1374
  Used    1342    1377

CNT                             Stack                             INTEGER
  Decl     527
  Set 
  Used

CONSTANTS                                                         Module
  Decl
  Set 
  Used      76

DEL                             Heap                              REAL(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE
  Decl     357
  Set     1346
  Used    1336    1348    1349    1356

DELCL                           Heap                              REAL(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE
  Decl     358
  Set     1377
  Used    1337

DELT                            Use assoc                         REAL(KIND=8), From module OPTIONS, SAVE
  Decl
  Set 
  Used    1509    1511

DEL_IN                          Dummy Arg                         REAL(KIND=8), DIMENSION(:), INTENT(OUT)
  Decl    1324    1328
  Set     1348
  Used

DIF                             Stack                             REAL(KIND=8)
  Decl    1332
  Set     1371    1372
  Used    1373

DONE                            Stack                             LOGICAL
  Decl     533
  Set 
  Used

DUMPLOCAL                                                         LOGICAL, PARAMETER, PRIVATE
  Decl     363
  Set 
  Used     419     700    1149    1254

DUMPSIZES                                                         Subroutine, Module procedure
  Decl     711
  Set 
  Used       0     702

DUMPSPECDECOMP                                                    Subroutine, Module procedure
  Decl    1154
  Set 
  Used    1150

EXP                                                               Function, REAL, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0    1365    1373    1383

FATALERROR                      Use assoc                         Subroutine, From module PARALLELISM, Module procedure
  Decl
  Set 
  Used       0       0       0     723     855     915     930     948     956    1261

FATALERROR                      Use assoc                         Subroutine, From module PARALLELISM, Module procedure
  Decl
  Set 
  Used       0       0       0     723     855     915     930     948     956    1261

FIRSTANDLASTLAT                 Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     331
  Set     1857    1863
  Used    1849    1865    1866    1867

FIRSTEXTLAT                     Stack                             INTEGER
  Decl    1400
  Set     1578
  Used

FIRSTIND                        Dummy Arg                         INTEGER, INTENT(IN)
  Decl    1214    1215
  Set 
  Used    1239    1243    1244    1246    1247    1250    1267

FIRSTLAT                        Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     336
  Set     1543    1545
  Used    1519    1576

FIRSTLATINGROUP                 Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl    1405
  Set     1490
  Used    1473    1506    1534    1537    1543    1545    1599    1603

FIRSTLATINPROC_F                Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     283
  Set      678
  Used     544     765     776

FIRSTLON                        Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     334
  Set     1527    1528    1554
  Used    1520    1530    1599

FIRSTLONINGROUP                 Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl    1407
  Set     1491
  Used    1474    1527

FIRST_PROC_FOUR                 Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     292
  Set      509
  Used     458

FTN_LIB_DEFINITIONS                                               Module
  Decl
  Set 
  Used       1

GIVENFOURIERGROUPS              Dummy Arg                         LOGICAL, INTENT(IN)
  Decl     430     431
  Set 
  Used     439

GRIDDECOMPOSITION                                                 Subroutine, Module procedure
  Decl    1389
  Set 
  Used

GRIDMAP                         Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     351
  Set     1537
  Used    1444    1653    1796    1798    1803    1881    1883    1888

H                                                                 CHARACTER(24), PARAMETER
  Decl     375
  Set 
  Used     420

H                                                                 CHARACTER(24), PARAMETER
  Decl     433
  Set 
  Used

H                                                                 CHARACTER(24), PARAMETER
  Decl     524
  Set 
  Used     668     701

H                                                                 CHARACTER(15), PARAMETER
  Decl     712
  Set 
  Used     723     729     736     741     746     748     750     755     759     766     767     778     782     792

H                                                                 CHARACTER(26), PARAMETER
  Decl     825
  Set 
  Used     845     855     867     915     930     948     956

H                                                                 CHARACTER(20), PARAMETER
  Decl    1160
  Set 
  Used    1162    1167    1169    1179    1182    1192    1195    1205

H                                                                 CHARACTER(18), PARAMETER
  Decl    1227
  Set 
  Used    1261    1267    1271

H                                                                 CHARACTER(23), PARAMETER
  Decl    1413
  Set 
  Used    1698    1699    1814    1815

HAVEM1                          Static offset=0                   LOGICAL, SAVE
  Decl     166
  Set      888     890
  Used

HAVESURF                        Static offset=64                  LOGICAL, SAVE
  Decl     312
  Set      892     893
  Used

HJ                              Stack                             REAL(KIND=8)
  Decl    1412
  Set     1443
  Used    1584

I                               Stack                             INTEGER
  Decl     434
  Set      460     473     485     500     508
  Used     461     466     467     468     474     475     477     486     488     489     490     492     493     501     502
           504     506     509

I                               Stack                             INTEGER
  Decl     527
  Set      562     580     610     616     621     626     631     654     659
  Used     564     565     566     582     583     584     611     612     617     618     622     627     632     633     634
           635     636     638     639     640     641     642     643     655     656     657     660     661     662

I                               Stack                             INTEGER
  Decl     820
  Set      872     896     964
  Used     873     878     882     900     901     905     906     968     969     973     974

I                               Stack                             INTEGER
  Decl    1281
  Set     1297    1304    1307    1311
  Used    1300    1305    1309

I                               Stack                             INTEGER
  Decl    1401
  Set     1466    1469    1584    1615    1651    1658    1668    1757    1770    1797    1820    1835    1856    1882    1896
          1909    1916    1923
  Used    1468    1585    1619    1621    1622    1652    1659    1663    1664    1670    1671    1673    1675    1678    1683
          1685    1688    1771    1773    1774    1798    1799    1801    1803    1805    1806    1836    1838    1839    1857
          1858    1863    1883    1884    1886    1888    1910    1911    1917    1924    1926    1927

I1                              Stack                             INTEGER
  Decl    1399
  Set     1645    1648    1908    1911
  Used    1647

I2                              Stack                             INTEGER
  Decl    1399
  Set     1646    1649    1667    1672    1679    1689
  Used    1647    1651    1669

IADD                            Stack                             INTEGER
  Decl    1398
  Set     1641    1644
  Used    1651

IAUX                            Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE
  Decl    1411
  Set     1632    1653
  Used    1631    1659    1670    1673    1678    1683    1688

IB                              Stack                             INTEGER
  Decl     527
  Set 
  Used

IB                              Stack                             INTEGER
  Decl    1401
  Set     1616    1660    1744
  Used    1619    1620    1621    1626    1663    1745    1746    1747    1748    1749    1750    1751    1752

IBMAX                           Static offset=6336                INTEGER, SAVE, Initialized
  Decl     318
  Set 
  Used

IBMAX                           Dummy Arg                         INTEGER, INTENT(IN)
  Decl    1389    1390
  Set 
  Used    1570    1571    1616    1617    1625    1660    1661

IBMAXPERJB                      Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     282
  Set     1625    1626
  Used    1574

IBPERIJ                         Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     338
  Set     1595    1621    1663    1707    1708    1715    1716    1723    1724    1731    1732    1745    1746    1747    1748
  Used    1593

IERR                            Stack                             INTEGER
  Decl     822
  Set 
  Used     842     843     844     852     853     854     864     865     866     927     928     929     945     946     947
           953     954     955

IEX                             Stack                             INTEGER
  Decl    1400
  Set     1419    1425    1437    1439
  Used    1448    1449    1451    1452    1454    1456    1461    1463    1465

IFIRST                          Stack                             REAL(KIND=8)
  Decl    1412
  Set     1606
  Used    1645

IJ                              Stack                             INTEGER
  Decl    1399
  Set     1652    1876    1878    1885    1915
  Used    1653    1879    1880    1881    1883    1884    1886    1887    1888    1891    1896    1909    1916    1920    1923
          1930

IJ1                             Stack                             INTEGER
  Decl    1399
  Set 
  Used

IJB                             Stack                             INTEGER
  Decl    1401
  Set     1613    1618    1662
  Used    1616    1617    1660    1661

IJMAX                           Static offset=7744                INTEGER, SAVE, Initialized
  Decl     239
  Set      542
  Used     551     552     744     745

IJMAXGAUQUA                     Static offset=7808                INTEGER, SAVE, Initialized
  Decl     240
  Set      424
  Used

IL1                             Stack                             INTEGER
  Decl    1399
  Set 
  Used

IL2                             Stack                             INTEGER
  Decl    1399
  Set 
  Used

ILAST                           Stack                             REAL(KIND=8)
  Decl    1412
  Set     1608
  Used    1646

IMAX                            Static offset=7872                INTEGER, SAVE, Initialized
  Decl     238
  Set      380
  Used     424     539     742    1509    1511    1584

IMAXPERJ                        Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     241
  Set      538
  Used     537     539     542     565     582     583     618     622     632     633     634     638     639     640     657
           662    1478    1492    1496    1499    1501    1534    1540    1584    1607    1609    1644    1645    1646    1647
          1649    1652    1658    1668    1676    1686    1706    1707    1708    1709    1710    1714    1715    1716    1717
          1718    1722    1723    1724    1725    1726    1730    1731    1732    1733    1734    1744    1797    1805    1882
          1891

IMAXPERLAT                      Dummy Arg                         INTEGER, DIMENSION(<exp>), INTENT(IN)
  Decl     519     520
  Set 
  Used     538

IMP2                            Stack                             INTEGER
  Decl     527
  Set 
  Used

IMP2                            Stack                             INTEGER
  Decl    1398
  Set     1706    1714    1722    1730
  Used    1707    1708    1709    1710    1715    1716    1717    1718    1723    1724    1725    1726    1731    1732    1733
          1734

IMPROVED                        Stack                             LOGICAL
  Decl     533
  Set      630     637     644
  Used     647

INC                             Stack                             INTEGER
  Decl     821
  Set     1071    1083    1086
  Used    1081

IND                             Stack                             INTEGER
  Decl    1399
  Set 
  Used

INI                             Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl     823
  Set     1072    1080    1126    1134    1136    1138
  Used    1068    1076    1143    1146

INIBR_SI                        Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     192
  Set 
  Used

INIBS_SI                        Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     193
  Set     1143
  Used    1142

INITVERSIZES                                                      Subroutine, Module procedure
  Decl    1324
  Set 
  Used

INPARALLEL                      Stack                             LOGICAL
  Decl    1225
  Set     1232    1235
  Used    1236    1264

INPARALLEL                      Stack                             LOGICAL
  Decl    1284
  Set     1289    1292
  Used    1293

IOVLAP                          Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl    1402
  Set     1585
  Used    1582    1645    1646

IOVMAX                          Stack                             INTEGER
  Decl    1398
  Set     1588    1590
  Used

IP                              Stack                             INTEGER
  Decl     821
  Set     1070    1081    1084    1087
  Used    1076    1077    1080    1082    1085

IPAR                            Stack                             INTEGER
  Decl     434
  Set 
  Used

IPAR                            Stack                             INTEGER
  Decl    1399
  Set     1636    1674    1684    1792    1800    1807    1811
  Used    1670    1671    1675    1676    1677    1678    1685    1686    1687    1688    1696    1697    1757    1770    1777
          1778    1794    1795    1796    1798    1799    1800    1801    1802    1803    1806    1807    1812    1813    1820
          1832    1835    1842

IPERIJB                         Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     340
  Set     1619
  Used    1572

IPROC                           Stack                             INTEGER
  Decl    1401
  Set     1485    1525    1552
  Used    1527    1528    1529    1530    1532    1536    1537    1542    1543    1545    1547    1548    1550    1553    1554
          1555

IS                              Stack                             INTEGER
  Decl     819
  Set 
  Used

ITRD                            Stack                             INTEGER
  Decl    1223
  Set     1234    1238
  Used    1242    1243    1244    1246    1247    1267

ITRD                            Stack                             INTEGER
  Decl    1283
  Set     1291    1295
  Used    1300

J                               Stack                             INTEGER
  Decl     527
  Set      563     581     681     691
  Used     565     566     567     582     583     584     585     682     692     693

J                               Stack                             INTEGER
  Decl     715
  Set      788
  Used     789     790

J                               Stack                             INTEGER
  Decl    1281
  Set     1298    1306    1310
  Used    1304

J                               Stack                             INTEGER
  Decl    1401
  Set     1535    1583    1614    1640    1642    1643    1657    1738    1758    1793    1821    1877    1897
  Used    1536    1537    1538    1539    1540    1584    1585    1615    1620    1621    1622    1644    1645    1646    1647
          1649    1652    1653    1658    1659    1663    1664    1668    1670    1673    1676    1677    1678    1683    1686
          1687    1688    1739    1740    1741    1742    1743    1745    1746    1747    1748    1749    1750    1751    1752
          1759    1760    1761    1762    1795    1796    1797    1798    1802    1803    1805    1822    1823    1824    1825
          1880    1881    1882    1883    1887    1888    1891    1898    1899    1900    1901

J1                              Stack                             INTEGER
  Decl    1399
  Set     1637
  Used

J2                              Stack                             INTEGER
  Decl    1399
  Set     1638
  Used    1639

JB                              Stack                             INTEGER
  Decl     527
  Set 
  Used

JB                              Stack                             INTEGER
  Decl    1401
  Set     1617    1639    1656    1661    1739    1740    1741    1742    1743
  Used    1619    1620    1622    1627    1640    1642    1643    1644    1664    1695    1744

JBDIM                           Stack                             INTEGER
  Decl    1397
  Set     1507
  Used    1514

JBMAX                           Static offset=10432               INTEGER, SAVE, Initialized
  Decl     319
  Set 
  Used

JBMAX                           Dummy Arg                         INTEGER, INTENT(OUT)
  Decl    1389    1391
  Set     1570    1571
  Used    1571    1625    1626

JBMAXINGROUP                    Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl    1409
  Set     1506
  Used    1477    1507    1528    1529    1530    1533    1547    1554    1555    1600    1604

JBMAX_EXT                       Static offset=128                 INTEGER, SAVE
  Decl     320
  Set 
  Used

JBMAX_EXT                       Dummy Arg                         INTEGER, INTENT(OUT)
  Decl    1389    1392
  Set     1627    1695
  Used    1656

JBPERIJ                         Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     339
  Set     1596    1622    1664    1709    1710    1717    1718    1725    1726    1733    1734    1749    1750    1751    1752
  Used    1594

JEND                            Stack                             INTEGER
  Decl     715
  Set      784
  Used     787     788

JFIRST                          Stack                             INTEGER
  Decl     528
  Set 
  Used

JH                              Stack                             INTEGER
  Decl     527
  Set 
  Used

JH                              Stack                             INTEGER
  Decl    1401
  Set     1704
  Used    1705    1713    1721    1729

JK                              Stack                             INTEGER
  Decl     527
  Set 
  Used

JLAST                           Stack                             INTEGER
  Decl     528
  Set      558     572     579     590
  Used     592

JLO                             Stack                             INTEGER, DIMENSION(1)
  Decl    1401
  Set     1533
  Used    1535

JMAX                            Static offset=11264               INTEGER, SAVE, Initialized
  Decl     216
  Set      377
  Used     424     551     558     579     652     653     695     738     783     784    1443    1478    1579    1643    1721
          1722    1723    1724    1725    1726    1729    1730    1731    1732    1733    1734    1738    1742    1743    1851
          1852

JMAXHALF                        Static offset=11328               INTEGER, SAVE, Initialized
  Decl     217
  Set      378
  Used     690     691     739

JMAXLOCAL_F                     Static offset=192                 INTEGER, SAVE
  Decl     308
  Set      675     685
  Used    1787

JMAXPERM                        Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     220
  Set      695
  Used     689

JMINPERM                        Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     219
  Set      690     693
  Used     688     695

JOVLAP                          Static offset=256                 INTEGER, SAVE
  Decl     330
  Set     1509    1511    1513
  Used    1514    1578    1579    1584    1637    1638    1704    1738

JPERIJB                         Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     341
  Set     1620
  Used    1573

JSTART                          Stack                             INTEGER
  Decl     715
  Set      783
  Used     784     786     789

JUSED                           Stack                             INTEGER
  Decl     528
  Set      567     585     612
  Used     572     590     616     620     621     622

K                               Stack                             INTEGER
  Decl     435
  Set      501
  Used     502

K                               Stack                             INTEGER
  Decl     527
  Set      677
  Used     678     679     680     681     682

K                               Stack                             INTEGER
  Decl     816
  Set     1057    1137
  Used    1059    1062    1138

K                               Stack                             INTEGER
  Decl    1281
  Set     1299    1315
  Used    1302    1316

K                               Stack                             INTEGER
  Decl    1331
  Set     1345    1355    1360    1364    1376    1382
  Used    1346    1356    1361    1365    1366    1367    1372    1373    1374    1377    1383

K                               Stack                             INTEGER
  Decl    1401
  Set     1462    1467    1486    1526
  Used    1463    1468    1469    1487    1488    1490    1491    1494    1498    1499    1500    1527    1528    1529    1530
          1531    1533    1534    1537    1539    1540    1543    1545    1547    1548    1550    1554    1555

KFIRST_FOUR                     Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     287
  Set      503
  Used     454     511     512

KLAST_FOUR                      Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     288
  Set      504
  Used     455     511     513

KMAX                            Static offset=14464               INTEGER, SAVE, Initialized
  Decl     353
  Set      382
  Used     443     444     447     448     451     452     453     467     743    1335    1345    1355    1358    1360    1364
          1366    1376    1382

KMAXLOC                         Static offset=320                 INTEGER, SAVE
  Decl     309
  Set      511
  Used    1138

KMAXSL                          Stack                             INTEGER
  Decl    1330
  Set     1334
  Used    1335

L                               Stack                             INTEGER
  Decl     435
  Set      502
  Used     503     504

L                               Stack                             INTEGER
  Decl     527
  Set 
  Used

LASTEXTLAT                      Stack                             INTEGER
  Decl    1400
  Set     1579
  Used    1583    1657

LASTIND                         Dummy Arg                         INTEGER, INTENT(IN)
  Decl    1214    1216
  Set 
  Used    1239    1251    1267

LASTLAT                         Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     337
  Set     1548    1550
  Used    1521    1577

LASTLATINGROUP                  Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl    1406
  Set     1498
  Used    1475    1506    1534    1540    1548    1550    1600    1604

LASTLATINPROC_F                 Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     284
  Set      679
  Used     545     681     776

LASTLON                         Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     335
  Set     1529    1536    1555
  Used    1522    1542    1547    1603

LASTLONINGROUP                  Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl    1408
  Set     1500
  Used    1476    1539

LAT                             Stack                             INTEGER
  Decl    1397
  Set     1483    1495    1502    1851
  Used    1490    1492    1496    1498    1499    1501    1852    1859    1861    1870

LEFT                            Stack                             INTEGER
  Decl    1221
  Set     1241
  Used    1242    1246    1247

LENGTH                          Stack                             INTEGER
  Decl    1224
  Set     1239
  Used    1240    1241

LINE                            Stack                             CHARACTER(256)
  Decl     714
  Set      770     785
  Used     771     772     775     778     786     787     790     792

LINE                            Stack                             CHARACTER(256)
  Decl    1159
  Set     1163    1172    1185    1198
  Used    1164    1165    1166    1167    1173    1174    1177    1179    1186    1187    1190    1192    1199    1200    1203
          1205

LM                              Stack                             INTEGER
  Decl     813
  Set     1012    1034
  Used    1015    1016    1037    1038

LM2M                            Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     156
  Set      932
  Used     927    1114    1177

LOG                                                               Function, REAL, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0    1365    1373    1383

LON                             Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl    1402
  Set     1530    1538    1540
  Used    1523    1533    1536    1537    1539    1554

M                               Stack                             INTEGER
  Decl     374
  Set      395     411
  Used     398     399     414     415

M                               Stack                             INTEGER
  Decl     435
  Set      499     506
  Used     503     504

M                               Stack                             INTEGER
  Decl     527
  Set      692
  Used     693

M                               Stack                             INTEGER
  Decl     808
  Set      877     881     899     904     967     972    1073    1114
  Used     878     882     900     901     905     906     968     969     973     974    1074    1116

M                               Stack                             INTEGER
  Decl    1157
  Set     1175    1201
  Used    1176    1177    1202    1203

M                               Dummy Arg                         INTEGER, INTENT(IN)
  Decl    1277    1278
  Set 
  Used    1279    1299    1315    1318

MAPR_SI                         Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     195
  Set 
  Used    1121

MAPS_SI                         Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     194
  Set     1127    1132
  Used    1120    1134

MAP_FOUR                        Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     291
  Set      492
  Used     481     502

MAX                                                               Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0    1704    1738

MAXIND                          Dummy Arg                         INTEGER, INTENT(OUT)
  Decl    1214    1218
  Set     1244    1247    1251
  Used    1267    1271

MAXN                            Stack                             INTEGER
  Decl     821
  Set      873
  Used     876     881     882

MAXNODES                        Dummy Arg                         INTEGER, INTENT(IN)
  Decl     519     523
  Set 
  Used

MAXNODES                        Dummy Arg                         INTEGER, INTENT(IN)
  Decl    1154    1155
  Set 
  Used    1183    1184

MAXNODES                        Use assoc                         INTEGER, From module PARALLELISM, SAVE
  Decl
  Set 
  Used     442     444     467     470     497    1055    1056    1057    1082    1084    1150    1851    1852    1856    1858

MAXNODES_FOUR                   Use assoc                         INTEGER, From module PARALLELISM, SAVE
  Decl
  Set      489
  Used     549     677     836     837     898     904     966     972

MAXPOINTS                       Stack                             INTEGER
  Decl     532
  Set      593
  Used     597     602

MAXPOINTSOLD                    Stack                             INTEGER
  Decl     532
  Set      574     602
  Used     582     597

MAXVAL                                                            Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0       0       0     539     593     983     984    1507    1608    1787    1870

MBASE                           Stack                             INTEGER
  Decl     811
  Set      875     897     965
  Used     876     878     898     966

MEANL                           Stack                             INTEGER
  Decl     528
  Set      551
  Used

MEANP                           Stack                             INTEGER
  Decl     528
  Set      552
  Used     564

MEND                            Stack                             INTEGER
  Decl    1157
  Set     1171    1197
  Used    1174    1175    1200    1201

MESSAGES_F                      Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     294
  Set     1794    1795    1796    1799    1801    1802    1803    1806    1824    1825
  Used    1788    1798    1800    1807    1822    1823    1833    1836    1839

MESSAGES_G                      Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     295
  Set 
  Used    1790

MESSPROC_F                      Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     296
  Set     1831    1833    1838    1839    1842
  Used    1789

MESSPROC_G                      Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     297
  Set 
  Used    1791

MEXTMAP                         Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     151
  Set      392     399
  Used     388

MFIRST                          Stack                             INTEGER, DIMENSION(<exp>)
  Decl     529
  Set      624     625     627     642     643     655     660
  Used     638     639     640     641     643     656     661     673     678     680

MIN                                                               Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0       0       0       0     693     784     881     904     972    1076    1171    1184    1197    1487    1579
          1738

MININD                          Dummy Arg                         INTEGER, INTENT(OUT)
  Decl    1214    1217
  Set     1243    1246    1250
  Used    1267    1271

MINLATPERBLK                    Stack                             INTEGER
  Decl     525
  Set 
  Used

MINLOC                                                            Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used    1533

MINVAL                                                            Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used    1606

MLAST                           Stack                             INTEGER, DIMENSION(<exp>)
  Decl     529
  Set      554     566     600     617     635     636     641     656     661
  Used     566     611     621     627     632     633     634     635     643     660     674     679     680

MLAST1                          Stack                             INTEGER, DIMENSION(<exp>)
  Decl     531
  Set      556     584     601
  Used     584     600

MM                              Stack                             INTEGER
  Decl     814
  Set      874     880     884     894     903     908     961     971     976
  Used     901     906

MMAP                            Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     146
  Set      408     415
  Used     405

MMAX                            Static offset=23168               INTEGER, SAVE, Initialized
  Decl     143
  Set      384
  Used     385     386     395     396     403     411     412     728     731     836     837     875     877     881     897
           899     904     965     967     968     969     972     973     974    1013    1035    1073    1074    1196    1197

MMAXLOCAL                       Static offset=384                 INTEGER, SAVE
  Decl     161
  Set      836     837
  Used     837

MMAXPERJ                        Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     218
  Set      536
  Used     535     692

MMID                            Stack                             INTEGER
  Decl     812
  Set      876     898     966
  Used     877     881     882     899     904     967     972

MN                              Stack                             INTEGER
  Decl     374
  Set      394     397     410     413
  Used     398     399     400     414     415     416

MN                              Stack                             INTEGER
  Decl     810
  Set     1011    1014    1033    1036    1069    1078    1101    1106    1113    1128
  Used    1015    1016    1017    1037    1038    1039    1077    1104    1105    1114    1115    1117    1129    1131    1132
          1134

MNEXTMAP                        Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     153
  Set      393     398
  Used     390

MNEXTMAX                        Static offset=24576               INTEGER, SAVE, Initialized
  Decl     150
  Set      387
  Used     734

MNEXTMAXLOCAL                   Static offset=448                 INTEGER, SAVE
  Decl     163
  Set      984
  Used

MNG                             Stack                             INTEGER
  Decl     815
  Set     1102    1116
  Used    1103    1104    1105    1117

MNGIV                           Stack                             INTEGER
  Decl     821
  Set     1076
  Used    1077    1078    1079    1080

MNMAP                           Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     148
  Set      407     414
  Used     404    1116

MNMAX                           Static offset=25408               INTEGER, SAVE, Initialized
  Decl     145
  Set      403
  Used     733    1055    1056    1102

MNMAXLOCAL                      Static offset=512                 INTEGER, SAVE
  Decl     162
  Set      983
  Used

MNMAX_SI                        Static offset=576                 INTEGER, SAVE
  Decl     183
  Set     1094
  Used

MNPROCMAP_SI                    Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     187
  Set     1077
  Used    1053    1103    1117

MNSENDSMAP_SI                   Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     188
  Set     1117
  Used    1111    1124    1129    1131    1132    1134

MNSEXTPERPROC                   Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     171
  Set      963     969     974
  Used     953     984     990

MNSINPROC_SI                    Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     189
  Set     1059    1062
  Used    1052    1076    1094

MNSPERPROC                      Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     170
  Set      962     968     973
  Used     945     983     989

MNSPERPROC_SI                   Stack                             INTEGER
  Decl     818
  Set     1055
  Used    1056    1059    1062

MOD                                                               Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0    1652    1660

MPERLAT                         Dummy Arg                         INTEGER, DIMENSION(<exp>), INTENT(IN)
  Decl     519     521
  Set 
  Used     536

MSG                             Dummy Arg                         CHARACTER(*), INTENT(IN)
  Decl    1214    1219
  Set 
  Used    1267    1271

MSGDUMP                         Use assoc                         Subroutine, From module PARALLELISM, Module procedure
  Decl
  Set 
  Used       0       0       0       0     420     755     766     778     792    1162    1167    1169    1179    1182    1192
          1195    1205

MSGDUMP                         Use assoc                         Subroutine, From module PARALLELISM, Module procedure
  Decl
  Set 
  Used       0       0       0       0     420     755     766     778     792    1162    1167    1169    1179    1182    1192
          1195    1205

MSINPROC                        Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     157
  Set      901     906
  Used     852     932

MSPERPROC                       Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     158
  Set      895     900     905
  Used     842     914     922    1190

MSTART                          Stack                             INTEGER
  Decl    1157
  Set     1170    1196
  Used    1171    1173    1176    1197    1199    1202

MYFIRSTLAT                      Static offset=640                 INTEGER, SAVE
  Decl     321
  Set     1576
  Used    1578    1598    1599    1602    1603    1606    1607    1608    1609    1637    1705    1713

MYFIRSTLAT_DIAG                 Static offset=704                 INTEGER, SAVE
  Decl     327
  Set     1866
  Used    1868

MYFIRSTLAT_F                    Static offset=768                 INTEGER, SAVE
  Decl     301
  Set      673
  Used     686     757

MYFIRSTLEV                      Static offset=832                 INTEGER, SAVE
  Decl     303
  Set      512
  Used

MYFIRSTLON                      Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     332
  Set     1598
  Used    1580    1606

MYGRIDPOINTS                    Stack                             INTEGER
  Decl    1400
  Set     1568
  Used    1570    1571

MYGROUP_FOUR                    Use assoc                         INTEGER, From module PARALLELISM, SAVE
  Decl
  Set      488
  Used     887     893     896     964    1203

MYID                            Dummy Arg                         INTEGER, INTENT(IN)
  Decl     519     522
  Set 
  Used

MYID                            Dummy Arg                         INTEGER, INTENT(IN)
  Decl    1389    1394
  Set 
  Used    1568    1576    1577    1599    1600    1601    1603    1604    1605    1653    1800    1807    1866    1867    1910

MYID                            Use assoc                         INTEGER, From module PARALLELISM, SAVE
  Decl
  Set 
  Used     487     511     512     513    1094    1103

MYID_FOUR                       Use assoc                         INTEGER, From module PARALLELISM, SAVE
  Decl
  Set      490
  Used     673     674     887     922     932     989     990

MYJMAX_D                        Static offset=896                 INTEGER, SAVE
  Decl     329
  Set     1868
  Used

MYJMAX_F                        Static offset=960                 INTEGER, SAVE
  Decl     305
  Set      686
  Used     756

MYLASTLAT                       Static offset=1024                INTEGER, SAVE
  Decl     322
  Set     1577
  Used    1579    1598    1601    1602    1605    1606    1607    1608    1609    1614    1638    1721    1729    1738

MYLASTLAT_DIAG                  Static offset=1088                INTEGER, SAVE
  Decl     328
  Set     1867
  Used    1868    1877

MYLASTLAT_F                     Static offset=1152                INTEGER, SAVE
  Decl     302
  Set      674
  Used     686     758    1793

MYLASTLEV                       Static offset=1216                INTEGER, SAVE
  Decl     304
  Set      513
  Used

MYLASTLON                       Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     333
  Set     1602
  Used    1581    1608    1615

MYMEXTMAP                       Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     173
  Set     1030    1038
  Used    1027

MYMMAP                          Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     168
  Set     1009    1016
  Used    1006    1114

MYMMAX                          Static offset=1280                INTEGER, SAVE
  Decl     160
  Set      922
  Used     932    1012    1034    1164    1170    1171

MYMNEXTMAP                      Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     175
  Set     1032    1037
  Used    1029

MYMNEXTMAX                      Static offset=1344                INTEGER, SAVE
  Decl     165
  Set      990
  Used    1166

MYMNMAP                         Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     172
  Set     1008    1015
  Used    1005

MYMNMAP_SI                      Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     190
  Set     1104
  Used    1099

MYMNMAX                         Static offset=1408                INTEGER, SAVE
  Decl     164
  Set      989
  Used    1113    1128    1165

MYMS                            Dummy Arg                         INTEGER, DIMENSION(<exp>), INTENT(INOUT)
  Decl    1277    1279
  Set     1302    1316
  Used

MYNEXTMAP                       Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     174
  Set     1031    1039
  Used    1028

MYNMAP                          Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     169
  Set     1010    1017
  Used    1007    1115

MYNMAP_SI                       Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     191
  Set     1105
  Used    1098

MYRECSGR                        Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     343
  Set     1671    1675    1676    1677    1678    1685    1686    1687    1688    1761    1762
  Used    1517    1670    1759    1760    1768    1771    1774

MYRECSPR                        Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     344
  Set     1768    1773    1774    1777
  Used    1518

MYRECSPR_DIAG                   Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     348
  Set     1919    1921    1926    1927    1930
  Used    1874

MYRECS_DIAG                     Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     347
  Set     1879    1880    1881    1884    1886    1887    1888    1891    1900    1901    1917
  Used    1873    1883    1898    1899    1910    1921    1924    1927

MYRECS_SI                       Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     186
  Set 
  Used

MYSENDSGR                       Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     345
  Set 
  Used    1515

MYSENDSPR                       Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     346
  Set 
  Used    1516

MYSENDSPR_DIAG                  Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     350
  Set 
  Used    1872

MYSENDS_DIAG                    Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     349
  Set 
  Used    1871

MYSENDS_SI                      Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     185
  Set     1144
  Used    1141

N                               Stack                             INTEGER
  Decl     374
  Set      396     412
  Used     398     400     414     416

N                               Stack                             INTEGER
  Decl     434
  Set      482     494
  Used     487     492     497

N                               Stack                             INTEGER
  Decl     809
  Set     1013    1035    1115
  Used    1015    1017    1037    1039    1116

N                               Stack                             INTEGER
  Decl    1398
  Set     1531    1855    1859    1861    1907    1912
  Used    1857    1863    1915    1917

NDIM                            Stack                             INTEGER
  Decl    1397
  Set     1514    1870
  Used    1696    1697

NDIM_F                          Stack                             INTEGER
  Decl    1398
  Set     1787
  Used    1812    1813

NEXT                            Stack                             INTEGER
  Decl     435
  Set      471
  Used     472     475     477

NEXT                            Stack                             INTEGER
  Decl    1397
  Set     1487
  Used    1488    1489

NEXTMAP                         Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     152
  Set      391     400
  Used     389

NEXTMAX                         Static offset=43712               INTEGER, SAVE, Initialized
  Decl     149
  Set      386
  Used     387

NFPRT                           Use assoc                         INTEGER, From module OPTIONS, SAVE, Initialized
  Decl
  Set 
  Used    1697    1698    1813    1814

NG                              Stack                             INTEGER
  Decl     434
  Set      440     447     448
  Used     448     450     451     452     453     460     471     472     473

NGPPERPROC                      Stack                             INTEGER
  Decl    1398
  Set     1479
  Used    1480    1481    1482    1488

NGPTOTAL                        Stack                             INTEGER
  Decl    1397
  Set     1478
  Used    1479    1480

NGROUPS                         Stack                             INTEGER
  Decl    1396
  Set     1416    1422    1430    1432    1465
  Used    1434    1435    1448    1453    1454    1458    1461    1467    1486    1526

NGROUPS_FOUR                    Static offset=1472                INTEGER, SAVE
  Decl     306
  Set      450
  Used     485     500     508     872

NINT                                                              Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0    1645    1646

NL                              Stack                             INTEGER
  Decl     434
  Set      443     451     452
  Used     444     447     448     452     453     462     464

NLAT                            Dummy Arg                         INTEGER, INTENT(IN)
  Decl     369     371
  Set 
  Used     377     378

NLATSINPROC_D                   Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     293
  Set     1865
  Used    1850

NLATSINPROC_F                   Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     285
  Set      680
  Used     546     685     776

NLEVPERG_FOUR                   Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     289
  Set      466
  Used     457     504     506

NLG                             Stack                             INTEGER
  Decl     434
  Set      462     464
  Used     466     467

NLON                            Dummy Arg                         INTEGER, INTENT(IN)
  Decl     369     372
  Set 
  Used     380

NLP                             Stack                             INTEGER
  Decl     434
  Set 
  Used

NLP                             Stack                             INTEGER
  Decl     532
  Set      652
  Used     653     655     656     657     661     662

NMAP                            Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     147
  Set      409     416
  Used     406    1105

NMAX                            Static offset=46080               INTEGER, SAVE, Initialized
  Decl     144
  Set      385
  Used     403     732

NMS                             Dummy Arg                         INTEGER, INTENT(OUT)
  Decl    1277    1280
  Set     1296    1301    1318
  Used    1302

NN                              Stack                             INTEGER
  Decl     434
  Set      444
  Used     445

NNODES                          Stack                             INTEGER
  Decl     715
  Set      765
  Used     768     769

NODEHASJ                        Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     298
  Set 
  Used

NODEHASJ_F                      Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     286
  Set      676     682
  Used     547     790

NODEHASM                        Heap                              INTEGER, DIMENSION(:, :), ALLOCATABLE, SAVE
  Decl     155
  Set      878     882
  Used     864     887     900     901     905     906     968     969     973     974    1203

NP                              Stack                             INTEGER
  Decl     434
  Set      459     468
  Used     470

NP                              Stack                             INTEGER
  Decl    1396
  Set     1428    1492    1496    1532    1853
  Used    1429    1430    1432    1494    1499    1854

NP1                             Stack                             INTEGER
  Decl    1396
  Set     1854
  Used    1858

NP2                             Stack                             INTEGER
  Decl    1396
  Set     1427
  Used    1428    1429

NPOINTS                         Stack                             INTEGER, DIMENSION(<exp>)
  Decl     530
  Set      555     565     598     618     620     622     633     634     639     640     657     662
  Used     564     574     625     627     632     638     667

NPOINTS1                        Stack                             INTEGER, DIMENSION(<exp>)
  Decl     531
  Set      557     583     599
  Used     582     593     598

NPOINTSINGROUP                  Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl    1404
  Set     1488
  Used    1471    1494    1499

NPPERG                          Stack                             INTEGER
  Decl    1396
  Set     1417    1423    1434
  Used    1435    1436    1450    1452    1454    1457    1458    1461    1514

NPPERG_FOUR                     Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     290
  Set      467     475     477
  Used     456     468     486     489     501     873

NPR                             Stack                             INTEGER
  Decl    1396
  Set     1450
  Used    1451    1452    1453    1454

NPREST                          Stack                             INTEGER
  Decl     435
  Set      470     472
  Used     471     474

NPROC                           Stack                             INTEGER
  Decl     532
  Set      549
  Used     552     610     626     631     652     653     654     659

NPROC                           Dummy Arg                         INTEGER, INTENT(IN)
  Decl    1389    1393
  Set 
  Used    1415    1416    1421    1423    1427    1434    1435    1479    1480    1482    1553

NPROCMAX_FOUR                   Static offset=1536                INTEGER, SAVE
  Decl     307
  Set 
  Used

NPROCSINGROUP                   Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl    1403
  Set     1447    1448    1451    1452    1453    1454    1457    1458    1461    1463
  Used    1446    1468    1469    1487    1488    1531    1787    1870

NPROC_VERT                      Dummy Arg                         INTEGER, INTENT(IN)
  Decl     430     432
  Set 
  Used     440

NPSQ                            Stack                             INTEGER
  Decl     434
  Set      442
  Used     445

NRECS_DIAG                      Static offset=1600                INTEGER, SAVE
  Decl     325
  Set     1922    1925    1932
  Used    1926    1927    1930

NRECS_F                         Static offset=1664                INTEGER, SAVE
  Decl     310
  Set     1834    1837    1844
  Used    1838    1839    1842

NRECS_G                         Static offset=1728                INTEGER, SAVE
  Decl     311
  Set 
  Used

NRECS_GR                        Static offset=1792                INTEGER, SAVE
  Decl     323
  Set     1769    1772    1779
  Used    1773    1774    1777

NRECS_SI                        Static offset=1856                INTEGER, SAVE
  Decl     182
  Set 
  Used

NREST                           Stack                             INTEGER
  Decl     434
  Set      453
  Used     461

NREST                           Stack                             INTEGER
  Decl     532
  Set      653
  Used     654

NREST                           Stack                             INTEGER
  Decl    1396
  Set     1418    1424    1435    1480    1489    1852
  Used    1462    1481    1482    1487    1853    1854

NS                              Stack                             INTEGER
  Decl     821
  Set     1074    1079
  Used    1076    1089

NSENDS_DIAG                     Static offset=1920                INTEGER, SAVE
  Decl     326
  Set 
  Used

NSENDS_GR                       Static offset=1984                INTEGER, SAVE
  Decl     324
  Set     1780
  Used

NSENDS_SI                       Static offset=2048                INTEGER, SAVE
  Decl     181
  Set     1125    1130
  Used    1129    1131    1132    1137    1143    1144

NSET                            Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     299
  Set      483     493
  Used     480     486     490     492

NTRD                            Stack                             INTEGER
  Decl    1222
  Set     1233    1237
  Used    1240    1241

NTRD                            Stack                             INTEGER
  Decl    1282
  Set     1290    1294
  Used    1305    1307

O                               Stack                             INTEGER
  Decl     715
  Set      774     789
  Used     775     790

O                               Stack                             INTEGER
  Decl    1157
  Set     1176    1189    1202
  Used    1177    1190    1203

OMP_GET_MAX_THREADS                                               Function, INTEGER, RESULT(OMP_GET_MAX_THREADS), EXTERNAL
  Decl     526
  Set 
  Used

OMP_GET_NUM_THREADS                                               Function, INTEGER, RESULT(OMP_GET_NUM_THREADS), EXTERNAL
  Decl    1228    1285
  Set 
  Used

OMP_GET_THREAD_NUM                                                Function, INTEGER, RESULT(OMP_GET_THREAD_NUM), EXTERNAL
  Decl    1229    1286
  Set 
  Used

OMP_IN_PARALLEL                                                   Function, LOGICAL, RESULT(OMP_IN_PARALLEL), EXTERNAL
  Decl    1230    1287
  Set 
  Used

OP                              Stack                             LOGICAL
  Decl     716
  Set 
  Used     722

OP                              Stack                             LOGICAL
  Decl    1226
  Set 
  Used    1260

OPTIONS                                                           Module
  Decl
  Set 
  Used      81

P                               Stack                             INTEGER
  Decl     715
  Set      773
  Used     774     776

PARALLELISM                                                       Module
  Decl
  Set 
  Used      88

PE                              Stack                             INTEGER
  Decl    1158
  Set     1188
  Used    1189    1190

PEEND                           Stack                             INTEGER
  Decl    1158
  Set     1184
  Used    1187    1188

PEND                            Stack                             INTEGER
  Decl     715
  Set      769
  Used     772     773

PESTART                         Stack                             INTEGER
  Decl    1158
  Set     1183
  Used    1184    1186    1189

POINTSINPROC                    Heap                              INTEGER, DIMENSION(:), ALLOCATABLE, SAVE
  Decl     342
  Set     1481    1482
  Used    1472    1532    1568

PROCINGROUP                     Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl    1410
  Set     1468
  Used    1445    1599    1600    1603    1604

PSTART                          Stack                             INTEGER
  Decl     715
  Set      768
  Used     769     771     774

R8                              Use assoc                         INTEGER, PARAMETER, From module CONSTANTS
  Decl
  Set 
  Used     355     356     357     358     359     360     361     362    1326    1327    1328    1332    1395    1412

RDEL2                           Heap                              REAL(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE
  Decl     359
  Set     1349
  Used    1338

REAL                                                              Function, REAL, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0       0     442    1450    1534    1606    1607    1608    1609

REDUCEDGRID                     Use assoc                         LOGICAL, From module OPTIONS, SAVE, Initialized
  Decl
  Set 
  Used     550

REGISTERBASICSIZES                                                Subroutine, Module procedure
  Decl     369
  Set 
  Used

REGISTEROTHERSIZES                                                Subroutine, Module procedure
  Decl     519
  Set 
  Used

REST                            Stack                             INTEGER
  Decl     817
  Set     1056    1060
  Used    1058

RK                              Use assoc                         REAL(KIND=8), PARAMETER, From module CONSTANTS
  Decl
  Set 
  Used    1351    1373    1383

RK1                             Stack                             REAL(KIND=8)
  Decl    1332
  Set     1351
  Used    1365    1367    1372

RPI                             Heap                              REAL(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE
  Decl     362
  Set     1383
  Used    1343

SENDS                           Heap                              INTEGER, DIMENSION(:), ALLOCATABLE
  Decl     823
  Set     1124    1131
  Used    1122    1127    1129    1144    1147

SI                              Heap                              REAL(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE
  Decl     356
  Set     1361
  Used    1340    1365    1367    1372

SIN                                                               Function, REAL, Implicit type, INTRINSIC
  Decl
  Set 
  Used    1584

SIRK                            Stack                             REAL(KIND=8)
  Decl    1332
  Set     1365
  Used    1371

SIRK1                           Stack                             REAL(KIND=8)
  Decl    1332
  Set     1367    1369
  Used    1371

SIZE                                                              Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0    1334

SIZE                                                              Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0    1334

SIZES                                                             Module
  Decl       6
  Set 
  Used

SI_IN                           Dummy Arg                         REAL(KIND=8), DIMENSION(:), INTENT(IN)
  Decl    1324    1326
  Set 
  Used    1346

SL                              Heap                              REAL(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE
  Decl     360
  Set     1373
  Used    1341    1374    1383

SLAGR                           Use assoc                         LOGICAL, From module OPTIONS, SAVE, Initialized
  Decl
  Set 
  Used    1513    1587    1629

SL_IN                           Dummy Arg                         REAL(KIND=8), DIMENSION(:), INTENT(IN)
  Decl    1324    1327
  Set 
  Used    1334

SL_TWOTIME_SCHEME               Use assoc                         LOGICAL, From module OPTIONS, SAVE, Initialized
  Decl
  Set 
  Used    1508

SPECTRALDOMAINDECOMP                                              Subroutine, Module procedure
  Decl     806
  Set 
  Used

SQRT                                                              Function, REAL, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0    1428    1450

SUM                                                               Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0    1478

SUM                                                               Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0    1478

THREADDECOMP                                                      Subroutine, Module procedure
  Decl    1214
  Set 
  Used

THREADDECOMPMS                                                    Subroutine, Module procedure
  Decl    1277
  Set 
  Used

TRIM                                                              Function, INTEGER, Implicit type, INTRINSIC
  Decl
  Set 
  Used       0       0       0       0       0     736     741     751     760     778     845     855     867     930     948
           956    1167    1179    1192    1205

TRUNC                           Dummy Arg                         INTEGER, INTENT(IN)
  Decl     369     370
  Set 
  Used     384

UNITDUMP                        Use assoc                         INTEGER, From module PARALLELISM, SAVE
  Decl
  Set 
  Used     729     735     740     746     748     750    1265    1269

USEDINLAT                       Stack                             INTEGER
  Decl    1397
  Set     1484    1499    1503
  Used    1491    1492    1500    1501

VERT                            Dummy Arg                         INTEGER, INTENT(IN)
  Decl     369     373
  Set 
  Used     382

VERTICALGROUPS                                                    Subroutine, Module procedure
  Decl     430
  Set 
  Used

VMAX_EST                        Dummy Arg                         REAL(KIND=8), INTENT(IN)
  Decl    1389    1395
  Set 
  Used    1509    1511


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                         E x t e r n a l   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Name  Messages
----  --------
ABORT(Intrinsic)
      Defined as:  No definitions.

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
ABORT
      Defined as:  No definitions.

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
ACOS(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 1443, file Sizes.f90)

Name  Messages
----  --------
ADJUSTL(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 736, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 736, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 736, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 737, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 741, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 741, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 747, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 747, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 751, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 751, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 751, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 759, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 760, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 761, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 845, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 855, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 867, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 930, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 948, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 956, file Sizes.f90)

Name  Messages
----  --------
ALL(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 1129, file Sizes.f90)

Name  Messages
----  --------
ANY(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 667, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 914, file Sizes.f90)

Name  Messages
----  --------
CONSTANTS
      Defined as:  No definitions.

      Used By:     SIZES

Name  Messages
----  --------
DUMPSIZES in SIZES
      Defined as:  Subroutine (line 711, file Sizes.f90)

      Interface:   None

      Called By:   DUMPSIZES in SIZES (Line 421, file Sizes.f90)
                   DUMPSIZES in SIZES (Line 702, file Sizes.f90)

      Calls:       DUMPSIZES in SIZES (Line 421, file Sizes.f90)
                   DUMPSIZES in SIZES (Line 702, file Sizes.f90)

Name  Messages
----  --------
DUMPSPECDECOMP in SIZES
      Defined as:  Subroutine (line 1154, file Sizes.f90)

      Interface:   None

      Called By:   DUMPSPECDECOMP in SIZES (Line 1150, file Sizes.f90)

      Calls:       DUMPSPECDECOMP in SIZES (Line 1150, file Sizes.f90)

Name  Messages
----  --------
EXIT(Intrinsic)
      Defined as:  No definitions.

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
EXP(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 1365, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1367, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1373, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1383, file Sizes.f90)

Name  Messages
----  --------
FATALERROR in PARALLELISM
      Defined as:  No definitions.

      Interface:   None

      Called By:   SIZES (Line 668, file Sizes.f90)
                   SIZES (Line 723, file Sizes.f90)
                   SIZES (Line 845, file Sizes.f90)
                   SIZES (Line 855, file Sizes.f90)
                   SIZES (Line 867, file Sizes.f90)
                   SIZES (Line 915, file Sizes.f90)
                   SIZES (Line 930, file Sizes.f90)
                   SIZES (Line 948, file Sizes.f90)
                   SIZES (Line 956, file Sizes.f90)
                   SIZES (Line 1261, file Sizes.f90)

Name  Messages
----  --------
FLUSH
      Defined as:  No definitions.

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
FLUSH_8
      Defined as:  No definitions.

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
FTN_LIB_DEFINITIONS
      Defined as:  No definitions.

      Used By:     SIZES

Name  Messages
----  --------
GRIDDECOMPOSITION in SIZES
      Defined as:  Subroutine (line 1389, file Sizes.f90)

      Interface:   None

      Calls:       REAL(Intrinsic) (Line 442, file Sizes.f90)
                   SQRT(Intrinsic) (Line 442, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 481, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 539, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 574, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 593, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 685, file Sizes.f90)
                   SUM(Intrinsic) (Line 542, file Sizes.f90)
                   ANY(Intrinsic) (Line 667, file Sizes.f90)
                   MIN(Intrinsic) (Line 693, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 736, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 736, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 736, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 737, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 741, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 741, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 747, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 747, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 751, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 751, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 751, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 759, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 760, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 761, file Sizes.f90)
                   TRIM(Intrinsic) (Line 736, file Sizes.f90)
                   TRIM(Intrinsic) (Line 736, file Sizes.f90)
                   TRIM(Intrinsic) (Line 736, file Sizes.f90)
                   TRIM(Intrinsic) (Line 737, file Sizes.f90)
                   TRIM(Intrinsic) (Line 741, file Sizes.f90)
                   TRIM(Intrinsic) (Line 741, file Sizes.f90)
                   TRIM(Intrinsic) (Line 747, file Sizes.f90)
                   TRIM(Intrinsic) (Line 747, file Sizes.f90)
                   TRIM(Intrinsic) (Line 751, file Sizes.f90)
                   TRIM(Intrinsic) (Line 751, file Sizes.f90)
                   TRIM(Intrinsic) (Line 751, file Sizes.f90)
                   TRIM(Intrinsic) (Line 759, file Sizes.f90)
                   TRIM(Intrinsic) (Line 760, file Sizes.f90)
                   TRIM(Intrinsic) (Line 761, file Sizes.f90)
                   TRIM(Intrinsic) (Line 778, file Sizes.f90)
                   TRIM(Intrinsic) (Line 792, file Sizes.f90)
                   SIZE(Intrinsic) (Line 765, file Sizes.f90)
                   MIN(Intrinsic) (Line 769, file Sizes.f90)
                   MIN(Intrinsic) (Line 784, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 845, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 855, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 867, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 930, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 948, file Sizes.f90)
                   ADJUSTL(Intrinsic) (Line 956, file Sizes.f90)
                   TRIM(Intrinsic) (Line 845, file Sizes.f90)
                   TRIM(Intrinsic) (Line 855, file Sizes.f90)
                   TRIM(Intrinsic) (Line 867, file Sizes.f90)
                   TRIM(Intrinsic) (Line 930, file Sizes.f90)
                   TRIM(Intrinsic) (Line 948, file Sizes.f90)
                   TRIM(Intrinsic) (Line 956, file Sizes.f90)
                   MIN(Intrinsic) (Line 877, file Sizes.f90)
                   MIN(Intrinsic) (Line 881, file Sizes.f90)
                   MIN(Intrinsic) (Line 899, file Sizes.f90)
                   MIN(Intrinsic) (Line 904, file Sizes.f90)
                   MIN(Intrinsic) (Line 967, file Sizes.f90)
                   MIN(Intrinsic) (Line 972, file Sizes.f90)
                   MIN(Intrinsic) (Line 1076, file Sizes.f90)
                   ANY(Intrinsic) (Line 914, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 983, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 984, file Sizes.f90)
                   ALL(Intrinsic) (Line 1129, file Sizes.f90)
                   TRIM(Intrinsic) (Line 1167, file Sizes.f90)
                   TRIM(Intrinsic) (Line 1179, file Sizes.f90)
                   TRIM(Intrinsic) (Line 1192, file Sizes.f90)
                   TRIM(Intrinsic) (Line 1205, file Sizes.f90)
                   MIN(Intrinsic) (Line 1171, file Sizes.f90)
                   MIN(Intrinsic) (Line 1184, file Sizes.f90)
                   MIN(Intrinsic) (Line 1197, file Sizes.f90)
                   SIZE(Intrinsic) (Line 1334, file Sizes.f90)
                   LOG(Intrinsic) (Line 1365, file Sizes.f90)
                   LOG(Intrinsic) (Line 1367, file Sizes.f90)
                   LOG(Intrinsic) (Line 1373, file Sizes.f90)
                   LOG(Intrinsic) (Line 1383, file Sizes.f90)
                   EXP(Intrinsic) (Line 1365, file Sizes.f90)
                   EXP(Intrinsic) (Line 1367, file Sizes.f90)
                   EXP(Intrinsic) (Line 1373, file Sizes.f90)
                   EXP(Intrinsic) (Line 1383, file Sizes.f90)
                   REAL(Intrinsic) (Line 1428, file Sizes.f90)
                   REAL(Intrinsic) (Line 1450, file Sizes.f90)
                   REAL(Intrinsic) (Line 1533, file Sizes.f90)
                   REAL(Intrinsic) (Line 1534, file Sizes.f90)
                   REAL(Intrinsic) (Line 1606, file Sizes.f90)
                   REAL(Intrinsic) (Line 1607, file Sizes.f90)
                   REAL(Intrinsic) (Line 1608, file Sizes.f90)
                   REAL(Intrinsic) (Line 1609, file Sizes.f90)
                   SQRT(Intrinsic) (Line 1428, file Sizes.f90)
                   SQRT(Intrinsic) (Line 1450, file Sizes.f90)
                   ACOS(Intrinsic) (Line 1443, file Sizes.f90)
                   SUM(Intrinsic) (Line 1478, file Sizes.f90)
                   MIN(Intrinsic) (Line 1487, file Sizes.f90)
                   MIN(Intrinsic) (Line 1579, file Sizes.f90)
                   MIN(Intrinsic) (Line 1738, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 1507, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 1608, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 1787, file Sizes.f90)
                   MAXVAL(Intrinsic) (Line 1870, file Sizes.f90)
                   MINLOC(Intrinsic) (Line 1533, file Sizes.f90)
                   MAX(Intrinsic) (Line 1578, file Sizes.f90)
                   MAX(Intrinsic) (Line 1704, file Sizes.f90)
                   MAX(Intrinsic) (Line 1738, file Sizes.f90)
                   SIN(Intrinsic) (Line 1584, file Sizes.f90)
                   NINT(Intrinsic) (Line 1584, file Sizes.f90)
                   NINT(Intrinsic) (Line 1645, file Sizes.f90)
                   NINT(Intrinsic) (Line 1646, file Sizes.f90)
                   MINVAL(Intrinsic) (Line 1606, file Sizes.f90)
                   MOD(Intrinsic) (Line 1616, file Sizes.f90)
                   MOD(Intrinsic) (Line 1652, file Sizes.f90)
                   MOD(Intrinsic) (Line 1660, file Sizes.f90)

Name  Messages
----  --------
ICEIL
      Defined as:  No definitions.

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
ICEIL_J
      Defined as:  No definitions.

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
INITVERSIZES in SIZES
      Defined as:  Subroutine (line 1324, file Sizes.f90)

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
LOG(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 1365, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1367, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1373, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1383, file Sizes.f90)

Name  Messages
----  --------
MAX(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 1578, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1704, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1738, file Sizes.f90)

Name  Messages
----  --------
MAXVAL(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 481, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 539, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 574, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 593, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 685, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 983, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 984, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1507, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1608, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1787, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1870, file Sizes.f90)

Name  Messages
----  --------
MIN(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 693, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 769, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 784, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 877, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 881, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 899, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 904, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 967, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 972, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1076, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1171, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1184, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1197, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1487, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1579, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1738, file Sizes.f90)

Name  Messages
----  --------
MINLOC(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 1533, file Sizes.f90)

Name  Messages
----  --------
MINVAL(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 1606, file Sizes.f90)

Name  Messages
----  --------
MOD(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 1616, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1652, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1660, file Sizes.f90)

Name  Messages
----  --------
MSGDUMP in PARALLELISM
      Defined as:  No definitions.

      Interface:   None

      Called By:   SIZES (Line 420, file Sizes.f90)
                   SIZES (Line 701, file Sizes.f90)
                   SIZES (Line 755, file Sizes.f90)
                   SIZES (Line 759, file Sizes.f90)
                   SIZES (Line 766, file Sizes.f90)
                   SIZES (Line 767, file Sizes.f90)
                   SIZES (Line 778, file Sizes.f90)
                   SIZES (Line 782, file Sizes.f90)
                   SIZES (Line 792, file Sizes.f90)
                   SIZES (Line 1162, file Sizes.f90)
                   SIZES (Line 1167, file Sizes.f90)
                   SIZES (Line 1169, file Sizes.f90)
                   SIZES (Line 1179, file Sizes.f90)
                   SIZES (Line 1182, file Sizes.f90)
                   SIZES (Line 1192, file Sizes.f90)
                   SIZES (Line 1195, file Sizes.f90)
                   SIZES (Line 1205, file Sizes.f90)

Name  Messages
----  --------
NINT(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 1584, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1645, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1646, file Sizes.f90)

Name  Messages
----  --------
OMP_GET_MAX_THREADS
      Defined as:  No definitions.

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
OMP_GET_NUM_THREADS
      Defined as:  No definitions.

      Interface:   None

      Called By:   THREADDECOMP in SIZES (Line 1237, file Sizes.f90)
                   THREADDECOMPMS in SIZES (Line 1294, file Sizes.f90)

Name  Messages
----  --------
OMP_GET_THREAD_NUM
      Defined as:  No definitions.

      Interface:   None

      Called By:   THREADDECOMP in SIZES (Line 1238, file Sizes.f90)
                   THREADDECOMPMS in SIZES (Line 1295, file Sizes.f90)

Name  Messages
----  --------
OMP_IN_PARALLEL
      Defined as:  No definitions.

      Interface:   None

      Called By:   THREADDECOMP in SIZES (Line 1235, file Sizes.f90)
                   THREADDECOMPMS in SIZES (Line 1292, file Sizes.f90)

Name  Messages
----  --------
OPTIONS
      Defined as:  No definitions.

      Used By:     SIZES

Name  Messages
----  --------
PARALLELISM
      Defined as:  No definitions.

      Used By:     SIZES

Name  Messages
----  --------
REAL(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 442, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1428, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1450, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1533, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1534, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1606, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1607, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1608, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1609, file Sizes.f90)

Name  Messages
----  --------
REGISTERBASICSIZES in SIZES
      Defined as:  Subroutine (line 369, file Sizes.f90)

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
REGISTEROTHERSIZES in SIZES
      Defined as:  Subroutine (line 519, file Sizes.f90)

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
SIN(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 1584, file Sizes.f90)

Name  Messages
----  --------
SIZE(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 765, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1334, file Sizes.f90)

Name  Messages
----  --------
SIZES
      Defined as:  Module (line 6, file Sizes.f90)

      Calls:       FATALERROR in PARALLELISM (Line 668, file Sizes.f90)
                   FATALERROR in PARALLELISM (Line 723, file Sizes.f90)
                   FATALERROR in PARALLELISM (Line 845, file Sizes.f90)
                   FATALERROR in PARALLELISM (Line 855, file Sizes.f90)
                   FATALERROR in PARALLELISM (Line 867, file Sizes.f90)
                   FATALERROR in PARALLELISM (Line 915, file Sizes.f90)
                   FATALERROR in PARALLELISM (Line 930, file Sizes.f90)
                   FATALERROR in PARALLELISM (Line 948, file Sizes.f90)
                   FATALERROR in PARALLELISM (Line 956, file Sizes.f90)
                   FATALERROR in PARALLELISM (Line 1261, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 420, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 701, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 755, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 759, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 766, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 767, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 778, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 782, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 792, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 1162, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 1167, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 1169, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 1179, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 1182, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 1192, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 1195, file Sizes.f90)
                   MSGDUMP in PARALLELISM (Line 1205, file Sizes.f90)

        Uses:      FTN_LIB_DEFINITIONS
                   CONSTANTS
                   OPTIONS
                   PARALLELISM

Name  Messages
----  --------
SPECTRALDOMAINDECOMP in SIZES
      Defined as:  Subroutine (line 806, file Sizes.f90)

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
SQRT(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 442, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1428, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1450, file Sizes.f90)

Name  Messages
----  --------
SUM(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 542, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1478, file Sizes.f90)

Name  Messages
----  --------
THREADDECOMP in SIZES
      Defined as:  Subroutine (line 1214, file Sizes.f90)

      Interface:   None

      Calls:       OMP_GET_NUM_THREADS (Line 1237, file Sizes.f90)
                   OMP_GET_THREAD_NUM (Line 1238, file Sizes.f90)
                   OMP_IN_PARALLEL (Line 1235, file Sizes.f90)

Name  Messages
----  --------
THREADDECOMPMS in SIZES
      Defined as:  Subroutine (line 1277, file Sizes.f90)

      Interface:   None

      Calls:       OMP_GET_NUM_THREADS (Line 1294, file Sizes.f90)
                   OMP_GET_THREAD_NUM (Line 1295, file Sizes.f90)
                   OMP_IN_PARALLEL (Line 1292, file Sizes.f90)

Name  Messages
----  --------
TRIM(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   GRIDDECOMPOSITION in SIZES (Line 736, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 736, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 736, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 737, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 741, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 741, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 747, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 747, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 751, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 751, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 751, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 759, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 760, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 761, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 778, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 792, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 845, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 855, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 867, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 930, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 948, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 956, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1167, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1179, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1192, file Sizes.f90)
                   GRIDDECOMPOSITION in SIZES (Line 1205, file Sizes.f90)

Name  Messages
----  --------
VERTICALGROUPS in SIZES
      Defined as:  Subroutine (line 430, file Sizes.f90)

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
flush_(Intrinsic)
      Defined as:  No definitions.

                   No calls.  It is not called and does not use any procedure.

      Interface:   None

Name  Messages
----  --------
flush_8_(Intrinsic)
      Defined as:  No definitions.

                   No calls.  It is not called and does not use any procedure.

      Interface:   None


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
