      SUBROUTINE WTERP(LONIN,LATIN,LONOUT,LATOUT,FLGIN,FLGOUT,
     *                 WTLON,WTLAT,MPLON,MPLAT,LOND,LATD,DWORK)
C*
C*    NEW INTERPOLATION WEIGHT CALCULATION
C*    THIS SUBROUTINE SHOULD BE CALLED ONCE TO DETERMINE THE AREA
C*    WEIGHTS AND INDEX MAPPING BETWEEN A PAIR OF GRIDS ON A
C*    SPHERE.  THE WEIGHTS AND MAP INDICES ARE USED BY SUBROUTINE
C*    NTERP TO PERFOM THE ACTUAL INTERPOLATION.  SEE FILE grid.interp
C*    FOR A FURTHER DISCUSSION.
C*
C*    SUBROUTINE ARGUMENTS:
C*
C*    USER SUPPLIED INPUT ARGUMENTS AND FLAGS:
C*    LONIN  NUMBER OF LONGITUDE POINTS FOR THE INPUT GRID
C*    LATIN  NUMBER OF LATITUDE POINTS FOR THE INPUT GRID
C*    LONOUT NUMBER OF LONGITUDE POINTS FOR THE OUTPUT GRID
C*    LATOUT NUMBER OF LATITUDE POINTS FOR THE OUTPUT GRID
C*    FLGIN  INPUT GRID FLAGS (SEE BELOW)
C*    FLGOUT OUTPUT GRID FLAGS (SEE BELOW)
C*
C*    COMPUTED OUTPUT ARRAYS AND ARGUMENTS (NOTE DIMENSIONS):
C*    WTLON  AREA WEIGHTS IN THE LONGITUDINAL DIRECTION
C*    WTLAT  AREA WEIGHTS IN THE LATITUDINAL DIRECTION
C*    MPLON  LONGITUDE INDEX MAPPING FROM INPUT (,1) TO OUTPUT (,2)
C*    MPLAT  LATITUDE INDEX MAPPING FROM INPUT (,1) TO OUTPUT (,2)
C*    LOND   TOTAL NUMBER OF LONGITUDE WEIGHTS
C*    LATD   TOTAL NUMBER OF LATITUDE WEIGTHS
C*
C*    USER SUPPLIED WORK ARRAY:
C*    DWORK  DOUBLE PRECISION WORK ARRAY WHICH SHOULD BE DIMENSIONED
C*           THE LARGER OF 2*(LATIN+LATOUT+2) OR 2*(LONIN+LONOUT+2)
C*
C*    FLAGS: (IN OR OUT)
C*    1     START AT NORTH POLE (TRUE) START AT SOUTH POLE (FALSE)
C*    2     START AT PRIME MERIDIAN (TRUE) START AT I.D.L. (FALSE)
C*    3     LATITUDES ARE AT CENTER OF BOX (TRUE)
C*          LATITUDES ARE AT EDGE (FALSE) NORTH EDGE IF 1=TRUE
C*                                        SOUTH EDGE IF 1=FALSE
C*    4     LONGITUDES ARE AT CENTER OF BOX (TRUE)
C*          LONGITUDES ARE AT WESTERN EDGE OF BOX (FALSE)
C*    5     GAUSSIAN (TRUE) REGULAR (FALSE)
C*
      INTEGER LONIN,LATIN,LONOUT,LATOUT,LOND,LATD
      INTEGER MPLON(LONIN+LONOUT+2,2),MPLAT(LATIN+LATOUT+2,2)
      REAL WTLON(LONIN+LONOUT+2),WTLAT(LATIN+LATOUT+2)
      LOGICAL FLGIN(*),FLGOUT(*)
      DOUBLE PRECISION DWORK(*)
C*
      INTEGER LATH,JOI,JOO,J,J1,J2,J3,IOI,ICI,I,IOO,ICO,I1,I2,I3
      DOUBLE PRECISION DPI,DRLTM,DRLTP,DLAT,DOF,DELRDI,DELRDO
C*
      DPI=3.1415926535897932384626433832795D0
C*
C*    INPUT GRID LATITUDES
C*
      JOI=LATIN+LATOUT+2
C*
      IF (FLGIN(5)) THEN
C*
C*    GAUSSIAN GRID CASE
C*
      LATH=LATIN/2
      CALL GL(LATH,DWORK)
C*
      DO 10 J=2,LATIN
      IF (J .LE. LATH) THEN
      DRLTM=-DPI/2.0D0+DWORK(J-1)
      DRLTP=-DPI/2.0D0+DWORK(J)
      ELSE IF(J.GT.LATH+1)THEN
      DRLTM=DPI/2.0D0-DWORK(LATIN-J+2)
      DRLTP=DPI/2.0D0-DWORK(LATIN-J+1)
      ELSE
      DRLTM=0.0D0
      DRLTP=0.0D0
      ENDIF
      DWORK(J+JOI)=DSIN((DRLTM+DRLTP)/2.0D0)
   10 CONTINUE
      DWORK(1+JOI)=-1.0D0
      DWORK(LATH+1+JOI)=0.0D0
      DWORK(LATIN+1+JOI)=1.0D0
C*
      ELSE
C*
C*    REGULAR GRID CASE
C*
      IF (FLGIN(3)) THEN
      DLAT=DPI/DBLE(LATIN-1)
      DOF=-(DPI+DLAT)/2.0D0
      ELSE
      DLAT=DPI/DBLE(LATIN)
      DOF=-DPI/2.0D0
      ENDIF
      DO 20 J=2,LATIN
      DWORK(JOI+J)=DSIN(DOF+DLAT*DBLE(J-1))
   20 CONTINUE
      DWORK(1+JOI)=-1.0D0
      DWORK(LATIN+1+JOI)=1.0D0
C*
      ENDIF
C*
C*    OUTPUT GRID LATITUDES
C*
      JOO=2*LATIN+LATOUT+3
C*
      IF(FLGOUT(5))THEN
C*
C*    GAUSSIAN GRID CASE
C*
      LATH=LATOUT/2
      CALL GL(LATH,DWORK)
C*
      DO 30 J=2,LATOUT
      IF (J .LE. LATH) THEN
      DRLTM=-DPI/2.0D0+DWORK(J-1)
      DRLTP=-DPI/2.0D0+DWORK(J)
      ELSEIF(J.GT.LATH+1)THEN
      DRLTM=DPI/2.0D0-DWORK(LATOUT-J+2)
      DRLTP=DPI/2.0D0-DWORK(LATOUT-J+1)
      ELSE
      DRLTM=0.0D0
      DRLTP=0.0D0
      ENDIF
      DWORK(J+JOO)=DSIN((DRLTM+DRLTP)/2.0D0)
   30 CONTINUE
      DWORK(1+JOO)=-1.0D0
      DWORK(LATH+1+JOO)=0.0D0
      DWORK(LATOUT+1+JOO)=1.0D0
C*
      ELSE
C*
C*    REGULAR GRID CASE
C*
      IF (FLGOUT(3)) THEN
      DLAT=DPI/DBLE(LATOUT-1)
      DOF=-(DPI+DLAT)/2.0D0
      ELSE
      DLAT=DPI/DBLE(LATOUT)
      DOF=-DPI/2.0D0
      ENDIF
      DO 40 J=2,LATOUT
      DWORK(JOO+J)=DSIN(DOF+DLAT*DBLE(J-1))
   40 CONTINUE
      DWORK(1+JOO)=-1.0D0
      DWORK(LATOUT+1+JOO)=1.0D0
C*
      ENDIF
C*
C*    PRODUCE SINGLE ORDERED SET OF SIN(LAT) FOR BOTH GRIDS
C*    DETERMINE LATITUDE WEIGHTING AND INDEX MAPPING
C*
      J1=1
      J2=1
      J3=1
C*
   50 IF (DWORK(J1+JOI) .EQ. DWORK(J2+JOO)) THEN
      DWORK(J3)=DWORK(J1+JOI)
      IF (J3 .NE. 1) THEN
      WTLAT(J3-1)=DWORK(J3)-DWORK(J3-1)
      MPLAT(J3-1,1)=J1-1
      IF (FLGIN(1)) MPLAT(J3-1,1)=LATIN+2-J1
      MPLAT(J3-1,2)=J2-1
      IF (FLGOUT(1)) MPLAT(J3-1,2)=LATOUT+2-J2
      ENDIF
C*
      J1=J1+1
      J2=J2+1
      J3=J3+1
C*
      ELSEIF (DWORK(J1+JOI) .LT. DWORK(J2+JOO)) THEN
      DWORK(J3)=DWORK(J1+JOI)
      IF (J3 .NE. 1) THEN
      WTLAT(J3-1)=DWORK(J3)-DWORK(J3-1)
      MPLAT(J3-1,1)=J1-1
      IF (FLGIN(1)) MPLAT(J3-1,1)=LATIN+2-J1
      MPLAT(J3-1,2)=J2-1
      IF (FLGOUT(1)) MPLAT(J3-1,2)=LATOUT+2-J2
      ENDIF
C*
      J1=J1+1
      J3=J3+1
C*
      ELSE
      DWORK(J3)=DWORK(J2+JOO)
      IF (J3 .NE. 1)THEN
      WTLAT(J3-1)=DWORK(J3)-DWORK(J3-1)
      MPLAT(J3-1,1)=J1-1
      IF (FLGIN(1)) MPLAT(J3-1,1)=LATIN+2-J1
      MPLAT(J3-1,2)=J2-1
      IF (FLGOUT(1)) MPLAT(J3-1,2)=LATOUT+2-J2
      ENDIF
C*
      J2=J2+1
      J3=J3+1
C*
      ENDIF
C*
      IF (J1.LE.LATIN+1 .AND. J2.LE.LATOUT+1) GOTO 50
C*
      LATD=J3-2
C*
C*    LATITUDES DONE, NOW DO LONGITUDES
C*
C*    INPUT GRID LONGITUDES
C*
      IOI=LONIN+LONOUT+2
      DELRDI=(2.0D0*DPI)/DBLE(LONIN)
      IF (FLGIN(5) .OR. FLGIN(4)) THEN
      ICI=0
      DOF=0.5D0
      ELSE
      ICI=1
      DOF=0.0D0
      ENDIF
      DO 60 I=1,LONIN
      DWORK(I+IOI)= (DOF+DBLE(I-1))*DELRDI
   60 CONTINUE
C*
C*    OUTPUT GRID LONGITUDES
C*
      IOO=2*LONIN+LONOUT+3
      DELRDO=(2.0D0*DPI)/DBLE(LONOUT)
      IF (FLGOUT(5) .OR. FLGOUT(4)) THEN
      ICO=0
      DOF=0.5D0
      ELSE
      ICO=1
      DOF=0.0D0
      ENDIF
CJPB  DO 70 I=1,LONIN
      DO 70 I=1,LONOUT
      DWORK(I+IOO)= (DOF+DBLE(I-1))*DELRDO
   70 CONTINUE
C*
C*    PRODUCE SINGLE ORDERED SET OF LONGITUDES FOR BOTH GRIDS
C*    DETERMINE LONGITUDE WEIGHTING AND INDEX MAPPING
C*
      I1=1
      I2=1
      I3=1
C*
   80 IF (DWORK(I1+IOI) .EQ. DWORK(I2+IOO)) THEN
      DWORK(I3)=DWORK(I1+IOI)
      IF (I3 .NE. 1) THEN
      WTLON(I3-1)=DWORK(I3)-DWORK(I3-1)
      MPLON(I3-1,1)=I1-ICI
      IF (.NOT.FLGIN(2)) THEN
      MPLON(I3-1,1)=LONIN/2+I1-ICI
      IF(I1-ICI.GT.LONIN/2)MPLON(I3-1,1)=I1-ICI-LONIN/2
      ENDIF
      MPLON(I3-1,2)=I2-ICO
      IF (.NOT.FLGOUT(2)) THEN
      MPLON(I3-1,2)=LONOUT/2+I2-ICO
      IF (I2-ICO .GT. LONOUT/2) MPLON(I3-1,2)=I2-ICO-LONOUT/2
      ENDIF
      ENDIF
C*
      I1=I1+1
      I2=I2+1
      I3=I3+1
C*
      ELSEIF (DWORK(I1+IOI) .LT. DWORK(I2+IOO)) THEN
      DWORK(I3)=DWORK(I1+IOI)
      IF (I3 .NE. 1)THEN
      WTLON(I3-1)=DWORK(I3)-DWORK(I3-1)
      MPLON(I3-1,1)=I1-ICI
      IF (.NOT.FLGIN(2)) THEN
      MPLON(I3-1,1)=LONIN/2+I1-ICI
      IF (I1-ICI .GT. LONIN/2) MPLON(I3-1,1)=I1-ICI-LONIN/2
      ENDIF
      MPLON(I3-1,2)=I2-ICO
      IF (.NOT.FLGOUT(2)) THEN
      MPLON(I3-1,2)=LONOUT/2+I2-ICO
      IF (I2-ICO .GT. LONOUT/2) MPLON(I3-1,2)=I2-ICO-LONOUT/2
      ENDIF
      ENDIF
C*
      I1=I1+1
      I3=I3+1
C*
      ELSE
      DWORK(I3)=DWORK(I2+IOO)
      IF (I3 .NE. 1)THEN
      WTLON(I3-1)=DWORK(I3)-DWORK(I3-1)
      MPLON(I3-1,1)=I1-ICI
      IF (.NOT.FLGIN(2)) THEN
      MPLON(I3-1,1)=LONIN/2+I1-ICI
      IF (I1-ICI .GT. LONIN/2) MPLON(I3-1,1)=I1-ICI-LONIN/2
      ENDIF
      MPLON(I3-1,2)=I2-ICO
      IF (.NOT.FLGOUT(2)) THEN
      MPLON(I3-1,2)=LONOUT/2+I2-ICO
      IF (I2-ICO .GT. LONOUT/2) MPLON(I3-1,2)=I2-ICO-LONOUT/2
      ENDIF
      ENDIF
C*
      I2=I2+1
      I3=I3+1
C*
      ENDIF
C*
      IF (I1.LE.LONIN .AND. I2.LE.LONOUT) GOTO 80
C*
      IF (I1 .GT. LONIN) I1=1
      IF (I2 .GT. LONOUT) I2=1
C*
   90 IF (I2 .NE. 1) THEN
C*
      DWORK(I3)=DWORK(I2+IOO)
      WTLON(I3-1)=DWORK(I3)-DWORK(I3-1)
      MPLON(I3-1,1)=1
      IF (.NOT.(FLGIN(4) .OR. FLGIN(5))) MPLON(I3-1,1)=LONIN
      IF (.NOT.FLGIN(2)) THEN
      MPLON(I3-1,1)=LONIN/2+1
      IF (.NOT.(FLGIN(4) .OR. FLGIN(5))) MPLON(I3-1,1)=LONIN/2
      ENDIF
      MPLON(I3-1,2)=I2-ICO
      IF (.NOT.FLGOUT(2)) THEN
      MPLON(I3-1,2)=LONOUT/2+I2-ICO
      IF (I2-ICO .GT. LONOUT/2) MPLON(I3-1,2)=I2-ICO-LONOUT/2
      ENDIF
      I2=I2+1
      IF (I2 .GT. LONOUT)I2=1
      I3=I3+1
C*
      ENDIF
C*
      IF (I1 .NE. 1)THEN
C*
      DWORK(I3)=DWORK(I1+IOI)
      WTLON(I3-1)=DWORK(I3)-DWORK(I3-1)
      MPLON(I3-1,1)=I1-ICI
      IF (.NOT.FLGIN(2)) THEN
      MPLON(I3-1,1)=LONIN/2+I1-ICI
      IF (I1-ICI .GT. LONIN/2) MPLON(I3-1,1)=I1-ICI-LONIN/2
      ENDIF
      MPLON(I3-1,2)=1
      IF (.NOT.(FLGOUT(4) .OR. FLGOUT(5))) MPLON(I3-1,2)=LONOUT
      IF (.NOT.FLGOUT(2)) THEN
      MPLON(I3-1,2)=LONOUT/2+1
      IF (.NOT.(FLGOUT(4) .OR. FLGOUT(5))) MPLON(I3-1,2)=LONOUT/2
      ENDIF
      I1=I1+1
      IF (I1 .GT. LONIN)I1=1
      I3=I3+1
C*
      ENDIF
C*
      IF (I1.NE.1 .OR. I2.NE.1) GOTO 90
C*
      WTLON(I3-1)=2.0D0*DPI+DWORK(1)-DWORK(I3-1)
      MPLON(I3-1,1)=1
      IF (.NOT.(FLGIN(4) .OR. FLGIN(5))) MPLON(I3-1,1)=LONIN
      IF (.NOT.FLGIN(2)) THEN
      MPLON(I3-1,1)=LONIN/2+1
      IF (.NOT.(FLGIN(4) .OR. FLGIN(5))) MPLON(I3-1,1)=LONIN/2
      ENDIF
      MPLON(I3-1,2)=1
      IF (.NOT.(FLGOUT(4) .OR. FLGOUT(5))) MPLON(I3-1,2)=LONOUT
      IF (.NOT.FLGOUT(2)) THEN
      MPLON(I3-1,2)=LONOUT/2+1
      IF (.NOT.(FLGOUT(4) .OR. FLGOUT(5))) MPLON(I3-1,2)=LONOUT/2
      ENDIF
C*
      LOND=I3-1
C*
      RETURN
      END
