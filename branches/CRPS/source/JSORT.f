      SUBROUTINE JSORT(X,N,Y)
C
C     THIS ROUTINE SORTS THE ELEMENTS OF THE INPUT VECTOR X AND PUTS THE SORTED
C     ELEMENTS INTO THE VECTOR Y.
C     THE INPUT TO THIS ROUTINE IS THE SINGLE PRECISION VECTOR X OF
C     (UNSORTED) OBSERVATIONS, THE INTEGER VALUE N (= SAMPLE SIZE),
C     AND AN EMPTY SINGLE PRECISION VECTOR Y INTO WHICH THE SORTED OBSERVATIONS
C     WILL BE PLACED.
C     THE OUTPUT FROM THIS ROUTINE IS THE SINGLE PRECISION VECTOR Y INTO WHICH
C     THE SORTED OBSERVATIONS HAVE BEEN PLACED.
C     RESTRICTIONS ON THE MAXIMUM ALLOWABLE VALUE OF N--THE DIMENSIONS
C     OF VECTORS IU AND IL (DEFINED AND USED INTERNALLY WITHIN THIS ROUTINE)
C     DETERMINE THE MAXIMUM ALLOWABLE VALUE OF N FOR THIS
C     ROUTINE.  IF IU AND IL EACH HAVE DIMENSION K, THEN N MAY NOT EXCEED
C     2**(K+1) - 1.  FOR THIS ROUTINE AS WRITTEN, THE DIMENSIONS OF IU AND IL
C     HAVE BEEN SET TO 36, THUS THE MAXIMUM ALLOWABLE VALUE OF N IS
C     APPROXIMATELY 137 BILLION.  SINCE THIS EXCEEDS THE MAXIMUM ALLOWABLE
C     VALUE FOR AN INTEGER VARIABLE IN MANY COMPUTERS, AND SINCE A SORT OF 137
C     BILLION ELEMENTS IS PRESENTLY IMPRACTICAL AND UNLIKELY, THEREFORE NO
C     TEST FOR WHETHER THE INPUT SAMPLE SIZE N EXCEEDS 137 BILLION HAS BEEN
C     INCORPORATED INTO THIS ROUTINE.  IT IS THUS ASSUMED THAT THERE IS NO
C     (PRACTICAL) RESTRICTION ON THE MAXIMUM VALUE OF N FOR THIS ROUTINE.
C     PRINTING--NONE UNLESS AN ERROR CONDITION EXISTS
C     THIS ROUTINE IS SINGLE PRECISION IN INTERNAL OPERATION.
C     SUBROUTINES NEEDED--NONE
C     SORTING METHOD--BINARY SORT
C     REFERENCE--CACM MARCH 1969, PAGE 186 (BINARY SORT ALGORITHM BY RICHARD
C                C. SINGLETON.
C              --CACM JANUARY 1970, PAGE 54.
C              --CACM OCTOBER 1970, PAGE 624.
C              --JACM JANUARY 1961, PAGE 41.
C
C     THE BINARY SORT ALGORITHM USED HEREIN IS EXTREMELY FAST AS THE
C     FOLLOWING TIME TRIALS (PERFORMED BY SORTING RANDOM NUMBERS)
C     ON THE UNIVAC 1108 EXEC 8 SYSTEM INDICATE.
C     THESE TIME TRIALS WERE CARRIED OUT IN AUGUST, 1974.
C     BY WAY OF COMPARISON, THE TIME TRIAL VALUES FOR THE EASY-TO-PROGRAM
C     BUT EXTREMELY INEFFICIENT BUBBLE SORT METHOD HAVE ALSO BEEN
C     INCLUDED:
C          NUMBER OF RANDOM            BINARY SORT       BUBBLE SORT
C           NUMBERS SORTED
C            N = 10                     .002 SEC          .002 SEC
C            N = 100                    .011 SEC          .045 SEC
C            N = 1000                   .141 SEC         4.332 SEC
C            N = 3000                   .476 SEC        37.683 SEC
C            N = 10000                 1.887 SEC      NOT COMPUTED
C
C     WRITTEN BY JAMES J. FILLIBEN, STATISTICAL ENGINEERING LABORATORY (205.03)
C     NATIONAL BUREAU OF STANDARDS, WASHINGTON, D.C. 20234       JUNE 1972
C
      DIMENSION X(1),Y(1)
      DIMENSION IU(36),IL(36)
C
      IPR=6
C
C     CHECK THE INPUT ARGUMENTS FOR ERRORS
C
      IF(N.LT.1)GOTO50
      IF(N.EQ.1)GOTO55
      HOLD=X(1)
      DO60I=2,N
      IF(X(I).NE.HOLD)GOTO90
   60 CONTINUE
      WRITE(IPR, 9)HOLD
      DO61I=1,N
      Y(I)=X(I)
   61 CONTINUE
      RETURN
   50 WRITE(IPR,15)
      WRITE(IPR,47)N
      RETURN
   55 WRITE(IPR,18)
      Y(1)=X(1)
      RETURN
   90 CONTINUE
    9 FORMAT(1H ,108H***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUME
     1NT (A VECTOR) TO THE SORT   SUBROUTINE HAS ALL ELEMENTS = ,E15.8,6
     1H *****)
   15 FORMAT(1H , 91H***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE
     1 SORT   SUBROUTINE IS NON-POSITIVE *****)
   18 FORMAT(1H ,100H***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUME
     1NT TO THE SORT   SUBROUTINE HAS THE VALUE 1 *****)
   47 FORMAT(1H , 35H***** THE VALUE OF THE ARGUMENT IS ,I8   ,6H *****)
C
C     COPY THE VECTOR X INTO THE VECTOR Y
      DO100I=1,N
      Y(I)=X(I)
  100 CONTINUE
C
C     CHECK TO SEE IF THE INPUT VECTOR IS ALREADY SORTED
C
      NM1=N-1
      DO200I=1,NM1
      IP1=I+1
      IF(Y(I).LE.Y(IP1))GOTO200
      GOTO250
  200 CONTINUE
      RETURN
  250 M=1
      I=1
      J=N
  305 IF(I.GE.J)GOTO370
  310 K=I
      MID=(I+J)/2
      AMED=Y(MID)
      IF(Y(I).LE.AMED)GOTO320
      Y(MID)=Y(I)
      Y(I)=AMED
      AMED=Y(MID)
  320 L=J
      IF(Y(J).GE.AMED)GOTO340
      Y(MID)=Y(J)
      Y(J)=AMED
      AMED=Y(MID)
      IF(Y(I).LE.AMED)GOTO340
      Y(MID)=Y(I)
      Y(I)=AMED
      AMED=Y(MID)
      GOTO340
  330 Y(L)=Y(K)
      Y(K)=TT
  340 L=L-1
      IF(Y(L).GT.AMED)GOTO340
      TT=Y(L)
  350 K=K+1
      IF(Y(K).LT.AMED)GOTO350
      IF(K.LE.L)GOTO330
      LMI=L-I
      JMK=J-K
      IF(LMI.LE.JMK)GOTO360
      IL(M)=I
      IU(M)=L
      I=K
      M=M+1
      GOTO380
  360 IL(M)=K
      IU(M)=J
      J=L
      M=M+1
      GOTO380
  370 M=M-1
      IF(M.EQ.0)RETURN
      I=IL(M)
      J=IU(M)
  380 JMI=J-I
      IF(JMI.GE.11)GOTO310
      IF(I.EQ.1)GOTO305
      I=I-1
  390 I=I+1
      IF(I.EQ.J)GOTO370
      AMED=Y(I+1)
      IF(Y(I).LE.AMED)GOTO390
      K=I
  395 Y(K+1)=Y(K)
      K=K-1
      IF(AMED.LT.Y(K))GOTO395
      Y(K+1)=AMED
      GOTO390
      END
      SUBROUTINE NPFAC(CONT,CONF,N,IFAC,Y)
C
C        
C
      BETA=CONT/100.
      ALPHA=CONF/100.
      Y=0.
    4 Y=Y+.1
      IF(Y .LE. 1000.) GO TO 5
      PRINT 100,Y
  100 FORMAT(F10.2)
      RETURN
    5 CONTINUE
      A=Y
      B=N-Y+1.
      X=1.-BETA
C      P=BETAI(X,A,B)
      P=HBETAI(X,A,B)
C      WRITE(6,*) P,P2
      IF(P.GT.ALPHA)GO TO 4
      IFAC=Y
      RETURN
      END
      FUNCTION XP(P)
C
C        FUNCTION TO CALCULATE NORMAL QUANTILE
C
C           REFERENCE:  ABRAMOWITZ AND STEGUN
C
      DATA C0,C1,C2,D1,D2,D3 /2.515517,0.802853,0.010328,1.432788,
     X 0.189269,0.001308/
      P1=P
      T=(LOG(1./(P1*P1)))**.5
      XP=T - ((C0+C1*T+C2*T*T)/(1.+D1*T+D2*T*T+D3*T*T*T))
      IF (XP .LT. 0.00001) XP=0.0
      RETURN
      END
      FUNCTION HBETAI(X,A,B)
C
C        EVALUATION OF AN INCOMPLETE BETA FUNCTION
C
C           REFERENCE:  ABRAMOWITZ AND STEGUN
C
      ACCURACY=.00000000001
C
C        CHOOSING THE APPROPRIATE TAIL
C
      CHECK=(A-1.0)/(A+B-2.0)
      IF (X .GE. CHECK) GO TO 500
C
C        SETTING UP THE ORIGINAL PARAMETERS AND LOOP
C
      PREVIOUS=0.0
      N=1
      XA=A
      XB=B
      XTERM=X
   50 N=N+1
      DO 100 K=1,N
      I=N-K
C
C        CALCULATING THE ITH EVEN AND ODD TERMS
C
      XI=FLOAT(I)
      C2I=(XI*(XB-XI)*XTERM)/((XA+(2.0*XI)-1.0)*(XA+(2.0*XI)))
      C2IP1=(-1.0*(XA+XI)*(XA+XB+XI)*XTERM)/
     2((XA+(2.0*XI)+1.0)*(XA+(2.0*XI)))
      IF (I .EQ. 0) C2I=1.0
C
C        MULTIPLYING BY THE PREVIOUS TERMS
C
      IF (K .EQ. 1) PRETERM=0.0
      TERM=(C2I/(1.0+(C2IP1/(1.0+PRETERM))))
C
C        SETTING A NEW PREVIOUS TERM AND GOING BACK FOR THE NEXT PAIR OF TERMS
C
      PRETERM=TERM
  100 CONTINUE
C
C        COMPARING TO THE PREVIOUS INTERATION
C
      DIFF=PREVIOUS-TERM
      DIFF=ABS(DIFF)
      IF (DIFF .LT. ACCURACY) GO TO 200
      PREVIOUS=TERM
      GO TO 50
  200 CONTINUE
C
C        CALCULATING THE BETA FUNCTION
C
      AB=XA+XB
      A1=XA+1
      GAB=ALGAMMA(AB)
      GA1=ALGAMMA(A1)
      GB=ALGAMMA(XB)
      XLBETAI=(GAB+(XA*ALOG(XTERM))+(XB*ALOG(1.0-XTERM))+ALOG(TERM))
     2-(GA1+GB)
      HBETAI=EXP(XLBETAI)
      RETURN
C
C        SETTING UP FOR SOLUTION IN OTHER TAIL
C
  500 CONTINUE
C
C        SETTING UP THE ORIGINAL PARAMETERS AND LOOP
C
      PREVIOUS=0.0
      N=1
      XA=B
      XB=A
      XTERM=1.0-X
  550 N=N+1
      DO 600 K=1,N
      I=N-K
C
C        CALCULATING THE ITH EVEN AND ODD TERMS
C
      XI=FLOAT(I)
      C2I=(XI*(XB-XI)*XTERM)/((XA+(2.0*XI)-1.0)*(XA+(2.0*XI)))
      C2IP1=(-1.0*(XA+XI)*(XA+XB+XI)*XTERM)/
     2((XA+(2.0*XI)+1.0)*(XA+(2.0*XI)))
      IF (I .EQ. 0) C2I=1.0
C
C        MULTIPLYING BY THE PREVIOUS TERMS
C
      IF (K .EQ. 1) PRETERM=0.0
      TERM=(C2I/(1.0+(C2IP1/(1.0+PRETERM))))
C
C        SETTING A NEW PREVIOUS TERM AND GOING BACK FOR THE NEXT PAIR OF TERMS
C
      PRETERM=TERM
  600 CONTINUE
C
C        COMPARING TO THE PREVIOUS INTERATION
C
      DIFF=PREVIOUS-TERM
      DIFF=ABS(DIFF)
      IF (DIFF .LT. ACCURACY) GO TO 700
      PREVIOUS=TERM
      GO TO 550
  700 CONTINUE
C
C        CALCULATING THE BETA FUNCTION
C
      AB=XA+XB
      A1=XA+1
      GAB=ALGAMMA(AB)
      GA1=ALGAMMA(A1)
      GB=ALGAMMA(XB)
      XLBETAI=(GAB+(XA*ALOG(XTERM))+(XB*ALOG(1.0-XTERM))+ALOG(TERM))
     2-(GA1+GB)
      BETA=EXP(XLBETAI)
      HBETAI=1.0-BETA
      RETURN
      END
      FUNCTION ALGAMMA(X)
C
C        CALCULATING THE LOG OF A GAMMA FUNCTION
C
C           REFERENCE: 
C
      IF (X .LE. 0.0) RETURN
      XLOG2PI=1.83787706641
      C1=1.0/12.0
      C2=1.0/360.0
      C3=1.0/1260.0
      C4=1.0/1680.0
      C5=1.0/1188.0
C
C        CHECK IF ARGUMENT OF GAMMA IS GREATER THAN 7
C
      ARG=X
      XMULT=1.0
   10 IF (ARG .GE. 7.0) GO TO 20
      XMULT=XMULT*ARG
      ARG=ARG+1.0
      GO TO 10
   20 CONTINUE
C
C        USING APPROXIMATION TO STIRLING'S FORMULA
C
      T1=(ARG-0.5)*ALOG(ARG)
      T2=0.5*XLOG2PI
      T3=C1/ARG
      T4=C2/(ARG**3)
      T5=C3/(ARG**5)
      T6=C4/(ARG**7)
      T7=C5/(ARG**9)
      XLOG=T1-ARG+T2+T3-T4+T5-T6+T7
C
C        CORRECTING BACK TO ORIGINAL X
C
      IF (X .GE. 7.0) GO TO 30
      XLOG=XLOG-ALOG(XMULT)
   30 ALGAMMA=XLOG
      RETURN
      END
