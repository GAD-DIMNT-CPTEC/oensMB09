       !        
       !        Cray Inc. Decompilation
       !        WARNING - This output is provided for information only.
       !        
       !        Cray Inc. reserves the right to change the format of this
       !        information at any time and does not guarantee the
       !        readability or accuracy of this information.
       !        
       !        This information may not be compilable and corresponds to
       !        the internal representation of the program during the
       !        optimization phase of the compilation process.
       !        
       !        Source                :  getgbexm.f
       !        File                  :  getgbexm.opt
       !        Format                :  Fortran
       !        Target                :  X86, 64-bit
       !        
    2.       
    2.       subroutine getgbexm( lugb, lugi, jf, j, jpds, jgds, jens, mbuf, cbuf, nlen, nnum, mnum, kf, k, kpds, kgds, kens, kprob, xprob, kclust, kmembr, lb, f, iret )
    2.       t$1 = mbuf
  223.       t$3 = _zla( 0, mbuf )
    2.       t$2 = jf
  224.       t$4 = _zla( 0, jf )
  229.       if ( j >= 0 ) then
  230.          if ( mnum >= 0 ) then
  231.             irgi = 0
  231.          else
  234.             irgi = 1
  233.             mnum = -1 + -mnum
  233.          endif
  236.          jr = j + -mnum
  237.          if ( j + -mnum < 0 ) then
  235.             goto 10
  237.          else if ( j + -mnum < nnum ) then
  237.             goto 20
  237.          else if ( irgi == 0 ) then
  237.    20       continue
  238.             call getgb1s(  _substr(cbuf(1),1,1), nlen, nnum, jr, jpds(1), jgds(1), jens(1), kr, kpds(1), kgds(1), kens(1), lskip, lgrib, irgs )
  240.             if ( irgs == 0 ) then
  240.                k = mnum + kr
  240.             endif
  241.             if ( irgi == 1 ) then
  241.                if ( irgs == 0 ) then
  241.                   mnum = -1 + -mnum
  241.                endif
  242.                if ( irgs > 0 ) then
  242.                   mnum = mnum + nnum
  242.                endif
  242.             endif
  242.          else
  242.    10       continue
  244.             mnum = j
  245.             irgi = 1
  246.             irgs = 1
  246.          endif
  246.       else
  249.          mnum = -1 + -j
  250.          irgi = 1
  251.          irgs = 1
  251.       endif
  255.       jr = 0
  256.       if ( ( irgi == 1 .and. irgs == 1 ) /= .false. ) then
  252.          do
  257.             if ( lugi > 0 ) then
  258.                call getgi( lugi, mnum, mbuf,  _substr(cbuf(1),1,1), nlen, nnum, irgi )
  258.             else
  260.                call getgir( lugb, 32000, 4000, mnum, mbuf,  _substr(cbuf(1),1,1), nlen, nnum, irgi )
  260.             endif
  262.             if ( irgi <= 1 ) then
  263.                call getgb1s(  _substr(cbuf(1),1,1), nlen, nnum, jr, jpds(1), jgds(1), jens(1), kr, kpds(1), kgds(1), kens(1), lskip, lgrib, irgs )
  265.                if ( irgs == 0 ) then
  265.                   k = mnum + kr
  265.                endif
  266.                if ( irgi == 1 ) then
  266.                   if ( irgs == 0 ) then
  266.                      mnum = -1 + -mnum
  266.                   endif
  267.                   if ( irgs > 0 ) then
  267.                      mnum = mnum + nnum
  267.                   endif
  267.                endif
  267.             endif
  268.             if ( ( irgi == 1 .and. irgs == 1 ) == .false. ) exit
  268.          enddo
  268.       endif
  272.       if ( irgi > 1 ) then
  273.          iret = 96
  274.       else if ( irgs /= 0 ) then
  275.          iret = 99
  275.       else
  276.          $t_S0 = lengds( kgds(1) )
  276.          if ( $t_S0 > jf ) then
  277.             iret = 98
  277.          else
  279.             call getgb1re( lugb, lskip, lgrib, kf, kpds(1), kgds(1), kens(1), kprob(1), xprob(1), kclust(1), kmembr(1), lb(1), f(1), iret )
  279.          endif
  279.       endif
  284.       return
  284.       end
  284.       
