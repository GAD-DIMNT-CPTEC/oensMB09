#!/bin/bash 
#help#
#*********************************************************************************#
#                                                                                 #
# script to run CPTEC Global Model on PC Clusters under MPI Scali                 #
# and Sun Grid Engine without OpenMP                                              #
#                                                                                 #
# assumptions: assume present at the same directory:                              #
#              ParModel_MPI (Global Model Executable file)                        #
#              MODELIN (Global Model input Namelist file)                         #
#                                                                                 #
# usage: run_multi_UNA cpu_mpi cpu_node  task_omp name TRC LV LABELI LABELF hold  #
# where:                                                                          #
# cpu_mpi: integer, the desired number of mpi processes                           #
# cpu_node: integer, the desired number of mpi processes per shared memory node   #
# task_omp:  threads per MPI task                                                 #
# name: character, the job name (for SGE)                                         #
# hold: any, present or not;                                                      #
#            if absent, script finishes after queueing job;                       #
#            if present, script holds till job completion                         #
#*********************************************************************************#
#help#
#
#       Help:
#
if [ "${1}" = "help" -o -z "${1}" ]
then
  cat < ${0} | sed -n '/^#help#/,/^#help#/p'
  exit 1
else
  TRC=`echo ${5} | awk '{print $1/1}'`   
fi
if [ -z "${6}" ]
then
  echo "LV is not set" 
  exit 2
else
  LV=`echo ${6} | awk '{print $1/1}'`    
fi

if [ -z "${7}" ]
then
  echo "LABELI is not set" 
  exit 3
else
  export LABELI=${7}  
fi
if [ -z "${8}" ]
then
  echo "LABELF is not set" 
  exit 3
else
  export LABELF=${8}  
fi

if [ "$#" == 9 ]
then hold=""
else hold=
fi


if [ ${TRC} = 21 ]; then
 export timestep=3600
fi 
if [ ${TRC} = 31 ]; then
 export timestep=1800
fi 
if [ ${TRC} = 42 ]; then
 export timestep=1800
fi 
if [ ${TRC} = 62 ]; then
 export timestep=1200
fi
if [ ${TRC} = 106 ]; then
 export timestep=900
fi
if [ ${TRC} = 126 ]; then
 export timestep=600
fi
if [ ${TRC} = 133 ]; then
 export timestep=600
fi
if [ ${TRC} = 159 ]; then
 export timestep=600
fi
if [ ${TRC} = 170 ]; then
 export timestep=450
fi
if [ ${TRC} = 213 ]; then
 export timestep=450
fi
if [ ${TRC} = 213 ]; then
 export timestep=360
fi
if [ ${TRC} = 254 ]; then
 export timestep=300
fi
if [ ${TRC} = 299 ]; then
 export timestep=300
fi
if [ ${TRC} = 319 ]; then
 export timestep=225
fi
if [ ${TRC} = 341 ]; then
 export timestep=200
fi
if [ ${TRC} = 382 ]; then
 export timestep=180
fi
if [ ${TRC} = 511 ]; then
 export timestep=150
fi
if [ ${TRC} = 533 ]; then
 export timestep=150
fi
if [ ${TRC} = 666 ]; then
 export timestep=150
fi
if [ ${TRC} = 863 ]; then
 export timestep=150
fi
if [ ${TRC} = 1279 ]; then
 export timestep=20
fi

#
# SETTING THE APPROPRIATED ENVIRONMENT
#
CASE=`echo ${TRC} ${LV} |awk '{ printf("TQ%4.4dL%3.3d\n",$1,$2)  }' `
PATHA=`pwd`
export FILEENV=`find ${PATHA} -name EnvironmentalVariablesMCGA2 -print`
export PATHENV=`dirname ${FILEENV}`
export PATHBASE=`cd ${PATHENV};cd ../;pwd`
. ${FILEENV} ${CASE}
cd ${HOME_suite}/run
#
#   Set nproc, resol, host, machine, NQS Queue and Run time
#
DIRRESOL=`echo ${TRC} ${LV} |awk '{ printf("TQ%4.4dL%3.3d\n",$1,$2)  }' `
HSTMAQ=`hostname`
MAQUI=`hostname -s`
QUEUE=${QUEUE}
RUNTM=`date +'%Y%m%d%T'`
yi=`awk 'BEGIN {print substr("'${LABELI}'",1,4)}'` ; export yi
mi=`awk 'BEGIN {print substr("'${LABELI}'",5,2)}'` ; export mi
di=`awk 'BEGIN {print substr("'${LABELI}'",7,2)}'` ; export di
hi=`awk 'BEGIN {print substr("'${LABELI}'",9,2)}'` ; export hi
yf=`awk 'BEGIN {print substr("'${LABELF}'",1,4)}'` ; export yf
mf=`awk 'BEGIN {print substr("'${LABELF}'",5,2)}'` ; export mf
df=`awk 'BEGIN {print substr("'${LABELF}'",7,2)}'` ; export df
hf=`awk 'BEGIN {print substr("'${LABELF}'",9,2)}'` ; export hf

echo $yi $mi $di $hi  $yf $mf $df $hf
mkdir -p ${DK_HSM}/GFCT/${yi}${mi}${di}${hi} 
mkdir -p ${DK_HSM}/GFGH/${yi}${mi}${di}${hi} 
mkdir -p ${HOME_suite}/run/setout
#
#########################################################
#
#      SCRIPT FOR GLOBAL MODEL PRODUCTION RUNS 
#
#########################################################

#
# Step 1: Set Directories and files:
#
#   DIRBASE is the root directory path; 
#           all files belong to subdirectories of root;
#   EXECFILEPATH is the executable filename (with path)
#   SCRIPTFILEPATH is the script file that submits executable (with path)
#   NAMELISTFILEPATH contains the namelist file read by the executable (with path)
#   OUTPUTFILEPATH is the executable output file (with path)
#
EXECFILEPATH=${DK_suite}/model/exec
SCRIPTFILEPATH=${DK_suite}/model/exec/modg${DIRRESOL}.${MAQUI}
NAMELISTFILEPATH=${HOME_suite}/run
OUTPUTFILEPATH=${HOME_suite}/run/setout/modg${DIRRESOL}.${MAQUI}.${RUNTM}.out
FSCR=${HOME_suite}/run

export cpu_mpi=$1
export cpu_node=$2
export ThreadsperMPITASK=$3
export RES=$4
num=$(($cpu_mpi+$cpu_node-1))
fra=$(($num/$cpu_node))
cpu_tot=$(($fra*$cpu_node))
echo fila=mpi-npn${cpu_node} total cpus=${cpu_tot}
#
# build Nanmelist to model MCGA
#
if [ -z "${PREFXO}" ] ;then
export PREFX="NMC" 
else
export PREFX="${PREFXO}" 
fi 
if [ -z "${PREFXI}" ] ;then
export PREFY="NMC"
else
export PREFY="${PREFXI}"
fi 
PROC=`echo ${cpu_mpi} |awk '{ printf("P%4.4d\n",$1)  }' `

export eigeninit=".TRUE."
export mgiven=".FALSE."      #,   ! mgiven       --> .FALSE.
export gaussgiven=".FALSE."      #,   ! gaussgiven       --> .FALSE.
export aspa="'"
export path_in=${DK_suite}/model/datain; mkdir -p ${path_in}
export dirfNameOutput=${DK_suite}/model/dataout/${DIRRESOL}/${yi}${mi}${di}${hi}_${PROC};rm -rf ${dirfNameOutput}; mkdir -p ${dirfNameOutput}
export EXECFILEPATH=${EXECFILEPATH}_${PROC};rm -rf ${EXECFILEPATH}; mkdir -p ${EXECFILEPATH}/setout ; cp -f ${DK_suite}/model/exec/ParModel_MPI ${EXECFILEPATH}/ 
#export dirfNameOutput=${DK_suite}/model/dataout/${DIRRESOL}/${yi}${mi}${di}${hi};rm -rf ${dirfNameOutput}; mkdir -p ${dirfNameOutput}
export SCRIPTFILEPATH=${DK_suite}/model/exec_${PROC}/modg${DIRRESOL}.${MAQUI}


cat ${NAMELISTFILEPATH}/MODELIN | awk '{  
 if (substr($1,1,5) == "trunc")
  {
   "echo ${TRC}" | getline TRC	   
    printf(" trunc    =%4.4d,		      !TRC   : three-digit triangular truncation\n",TRC)
  }
 else if (substr($1,1,4) == "vert")
  {
   "echo ${LV}" | getline LV	 
    printf(" vert     =%3.3d,		      !LV    : two-digit number of vertical sigma-layers\n",LV)
  }
 else if (substr($1,1,2) == "dt")
  {
   "echo $timestep" | getline timestep       
    printf(" dt       =%.1f,	     !      : delta t\n",timestep)
  }
 else if (substr($1,1,6) == "IDATEI")
  {
   "echo $yi" | getline yi	 
   "echo $mi" | getline mi	 
   "echo $di" | getline di	 
   "echo $hi" | getline hi	 
    printf(" IDATEI   = %2.2d,%2.2d,%2.2d,%4.4d, !LABELI: initial forecasting label\n",hi,di,mi,yi)
  }
 else if (substr($1,1,6) == "IDATEW")
  {
   "echo $yf" | getline yf	 
   "echo $mf" | getline mf	 
   "echo $df" | getline df	 
   "echo $hf" | getline hf	 
    printf(" IDATEW   = %2.2d,%2.2d,%2.2d,%4.4d, !LABELC: final forecasting label for cold\n",hf,df,mf,yf)
  }
 else if (substr($1,1,6) == "IDATEF")
  {
   "echo $yf" | getline yf	 
   "echo $mf" | getline mf	 
   "echo $df" | getline df	 
   "echo $hf" | getline hf	 
    printf(" IDATEF   = %2.2d,%2.2d,%2.2d,%4.4d, !LABELF: final forecasting label for warm\n",hf,df,mf,yf)
  }
 else if (substr($1,1,9) == "eigeninit")
  { 
   "echo $eigeninit" | getline eigeninit
    printf(" eigeninit     =%s,  ! eigenInit  --> .FALSE.\n",eigeninit)
  }
 else if (substr($1,1,6) == "mgiven")
  { 
   "echo $mgiven" | getline mgiven
    printf(" mgiven	   =%s,  ! mgiven  --> .FALSE.\n",mgiven)
  }
 else if (substr($1,1,10) == "gaussgiven")
  { 
   "echo $gaussgiven" | getline gaussgiven
    printf(" gaussgiven    =%s,  ! gaussgiven  --> .FALSE.\n",gaussgiven)
  }
 else if (substr($1,1,5) == "PREFX")
  { 
   "echo $aspa" | getline aspa
   "echo $PREFX" | getline PREFX
    printf(" PREFX    =%s%s%s , 	 !PREFX : preffix for name of output files\n",aspa,PREFX,aspa)
  }
 else if (substr($1,1,5) == "PREFY")
  { 
   "echo $aspa" | getline aspa
   "echo $PREFY" | getline PREFY
    printf(" PREFY    =%s%s%s , 	 !PREFY : preffix for name of input files\n",aspa,PREFY,aspa)
  }
 else if (substr($1,1,7) == "path_in")
  { 
   "echo $aspa" | getline aspa
   "echo $path_in" | getline path_in
    printf(" path_in=%s%s%s , \n",aspa,path_in,aspa)
  }
 else if (substr($1,1,14) == "dirfNameOutput")
  { 
   "echo $aspa" | getline aspa
   "echo $dirfNameOutput" | getline dirfNameOutput
    printf(" dirfNameOutput=%s%s%s , \n",aspa,dirfNameOutput,aspa)
  }
  else
  {
    print $0
  }
 }'    > ${EXECFILEPATH}/MODELIN

#
# Step 2: Build script that runs the AGCM executable getting information
#         from namelist 
#
cat <<EOF1>${EXECFILEPATH}/mpisep.bash
#!/bin/bash
export F_UFMTENDIAN=18,19,20,22,23,24,25,26,27,31,32,33,36,37,38,39,42,43,44,45,49,50,51,52,53,55,61,66,71,77,80,81,82,83,88,91,92,93,99
export GFORTRAN_CONVERT_UNIT=big_endian:18,19,20,22,23,24,25,26,27,31,32,33,36,37,38,39,42,43,44,45,49,50,51,52,53,55,61,66,71,77,80,81,82,83,88,91,92,93,99
export KMP_STACKSIZE=128m
ulimit -s unlimited

#export MPICH_MAX_SHORT_MSG_SIZE=128000
#export MPICH_UNEX_BUFFER_SIZE=60000000
#export MPICH_PTL_UNEX_EVENTS=20480
#export MPICH_PTL_OTHER_EVENTS=2048

#export MPICH_MAX_SHORT_MSG_SIZE=4096
#export MPICH_UNEX_BUFFER_SIZE=100000000
#export MPICH_PTL_UNEX_EVENTS=50000
#export MPICH_PTL_OTHER_EVENTS=2500

export MPID_RSH
cd ${EXECFILEPATH}
${EXECFILEPATH}/ParModel_MPI < ${EXECFILEPATH}/MODELIN >> ${EXECFILEPATH}/setout/Print.model.${LABELI}.${tmstp}.%s.MPI${cpu_mpi}.out
EOF1
chmod +x ${EXECFILEPATH}/mpisep.bash
#
# Step 3: Build script to submit the script above in the UNA
#
cat <<EOF0>${SCRIPTFILEPATH}
#!/bin/bash
#PBS -o ${HSTMAQ}:${EXECFILEPATH}/setout/Out.model.${LABELI}.${tmstp}.%s.MPI${cpu_mpi}.out
#PBS -j oe
#PBS -l walltime=6:00:00
#PBS -q pesq
#PBS -l mppwidth=${cpu_mpi}
#PBS -l mppnppn=${cpu_node}
#PBS -l mppdepth=${ThreadsperMPITASK}
#PBS -V
#PBS -S /bin/bash
#PBS -N $RES
#
cd ${EXECFILEPATH}
date
#time aprun -n ${cpu_mpi} -N ${cpu_node} ${EXECFILEPATH}/ParModel_MPI -i ${EXECFILEPATH}/MODELIN
export OMP_NUM_THREADS=${ThreadsperMPITASK}
ulimit -s unlimited
#time aprun -n  ${cpu_mpi} -N  ${cpu_node} -d ${ThreadsperMPITASK} -S  1  -ss ${EXECFILEPATH}/ParModel_MPI -i ${EXECFILEPATH}/MODELIN
#time aprun -n  ${cpu_mpi} -N  ${cpu_node} -d ${ThreadsperMPITASK} -S  1 ${EXECFILEPATH}/ParModel_MPI -i ${EXECFILEPATH}/MODELIN
#time aprun -n  ${cpu_mpi} -N  ${cpu_node} -d ${ThreadsperMPITASK} -ss  ${EXECFILEPATH}/ParModel_MPI -i ${EXECFILEPATH}/MODELIN
optserver=`printf "$PBS_SERVER \n" | cut -c1-3`
if [[ (\${optserver} = "aux") ]]; then
${EXECFILEPATH}/mpisep.bash
else
if [ ${ThreadsperMPITASK} = 1 ]; then
#time aprun -n ${cpu_mpi} -N  ${cpu_node} -S 1 -d ${ThreadsperMPITASK}  ${EXECFILEPATH}/mpisep.bash
time aprun -n ${cpu_mpi} -N  ${cpu_node}   -d ${ThreadsperMPITASK}  ${EXECFILEPATH}/mpisep.bash
else
time aprun -n ${cpu_mpi} -N  ${cpu_node}  -d ${ThreadsperMPITASK} -ss  ${EXECFILEPATH}/mpisep.bash
fi
fi
cmp ${DK_suite}/model/dataout/${DIRRESOL}/${LABELI}_P0021/GFCT${PREFY}${LABELI}${LABELF}F.fct.${DIRRESOL} ${dirfNameOutput}/GFCT${PREFY}${LABELI}${LABELF}F.fct.${DIRRESOL} > ${dirfNameOutput}/CMP.${DIRRESOL}
date
EOF0
chmod +x ${SCRIPTFILEPATH}
cd ${EXECFILEPATH}
if [[ ${it} -eq 1 ]];then
FIRST=`qsub ${SCRIPTFILEPATH}`
export FIRST
echo $FIRST
else
SECOND=`qsub -W depend=afterok:$FIRST ${SCRIPTFILEPATH}`
echo $SECOND
fi
#THIRD=`qsub -W depend=afterok:$SECOND ${SCRIPTFILEPATH}`
#echo $THIRD
#FOURTH=`qsub -W depend=afterok:$THIRD ${SCRIPTFILEPATH}`

#qsub ${hold} ${SCRIPTFILEPATH}
#qsub -W depend=${SCRIPTFILEPATH}                
#qsub -W depend=before:"${SCRIPTFILEPATH}"                      
#${FOURTH}

echo  ${hold} ${SCRIPTFILEPATH}
echo  ${it}
#it=2
#while [ ${it} -gt 0 ];do
#it=`qstat | grep $RES | wc -l`
#done

