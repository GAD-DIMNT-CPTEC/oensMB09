#! /bin/bash
#---------------------------------------------------------------------------------------------#
#            Grupo do Brazilian Global Atmospheric Model - BAM/CPTEC/INPE - 2016              #
#---------------------------------------------------------------------------------------------#
#BOP
#
# !DESCRIPTION:
#      Script para executar o pre-processamento do BAM 
#
# !CALLING SEQUENCE:
#           ./runPre TRC LV LABELI PREFIX total SmoothTopo GDASOnly RESIN KMIN 
#
# example : ./runPre 62 28 2016021100 NMC 1 T F 62 28  
#
#           * TRC         : 4 digits spectral resolution                           
#           * LV          : 3 digits vertical resolution                           
#           * LABELI      : initial data YYYYMMDDHH                                
#           * PREFIX      : NMC,AVN,P!                                             
#           * total       : 1 tudo 0 parcial                                       
#           * SmoothTopo  : Flag to Performe Topography Smoothing                  
#           * GDASOnly    : Flag to Only Produce Input CPTEC Analysis File (T or F)
#           * RESIN       : Spectral Horizontal Resolution of Input Data           
#                           4 digits spectral resolution                           
#           * KMIN        : Number of Layers of Input Data                         
#                           3 digits vertical resolution                           
#
# !REVISION HISTORY:
#      22-06-2016 - Eduardo Khamis      - Codigo Inicial
#      14-07-2016 - Eduardo Khamis      - Incluidas funcoes que tornam o runPre independente de scripts externos atraves de um namelist.
#                                         No momento, continua dependente apenas do run_Chopping_parallel.bash e run_Chopping_serial.bash.  
#      21-07-2016 - Eduardo Khamis      - runPre independente do run_Chopping_parallel.bash e run_Chopping_serial.bash.
#      26-07-2016 - Eduardo Khamis      - Inclusao de funcao que cria um script de submissao para cada processo.
#      28-07-2016 - Eduardo Khamis      - Mudanca na forma de submissao dos processos e inclusao de funcao de espera e checagem das saidas.
#                                         Convem ressaltar que eh feita uma busca de 'ends normally' no log do processo. Alguns processos,
#                                         como por exemplo NormalModes e TopographyGradient, nao possuem esse print no codigo. Esse print
#                                         serah incluido. Quem for usar esse script devera recompilar o codigo fortran com os prints inclusos.
#      20-09-2016 - Carlos Bastarz      - Corrigida verificacao do arquivo de analise quando a suavizacao da topografia e realizada (PREFIXO=SMT).
#                                         Corrigido o numero de processadores por no do Chopping_parralel (N=24).
#                                         Generalizado o prefixo dos processos SSTClima, FLUXCO2Clima, SSTWeekly, SSTMonthlyDirec, SSTDailyDirec,
#                                         e TopographyGradient (modificacoes feitas tambem no script namelist.runPre).
#                                       - Inclusao de testes e verificacao da existencia do arquivo de SST.
#      28-08-2017 - Eduardo Khamis      - Troca de if por case
#      29-09-2017 - Eduardo Khamis      - Correcao de bugs. Comentada a linha de export GFORTRAN_CONVERT_UNIT.
#      31-09-2017 - Eduardo Khamis      - Inclusao de cpu_mpi_aux e cpu_mpi_node para definir o numero total de processadores
#                                         e o numero de processadores por noh que o processo Chopping_parallel utiliza. Remocao
#                                         dos arquivos OUT.MPI*, set*.bash e .*.ok antes da submissao do processo.
#
# !REMARKS:
#
# !BUGS:
#
#---------------------------------------------------------------------------------------------#
#EOP

#BOC

#**********************************************************************************************
#------------------------------------FUNCOES COMUNS--------------------------------------------
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
function usageprincipal()
{
   echo ""
   echo -e "\033[34;1m          >>>>>> Execucao do Pre-processamento <<<<<<\033[m"
   echo " "
   echo " ==> Para rodar o pre-processamento digite:"
   echo " "
   echo " > ./runPre TRC LV LABELI PREFIX total SmoothTopo GDASOnly RESIN KMIN "
   echo " "
   echo "   exemplo: ./runPre 62 28 2016021100 NMC 1 T F 62 28  "
   echo " "
   echo "     * TRC         : 4 digits spectral resolution "
   echo "     * LV          : 3 digits vertical resolution "
   echo "     * LABELI      : initial data YYYYMMDDHH "
   echo "     * PREFIX      : NMC,AVN,P! "
   echo "     * total       : 1 tudo 0 parcial "
   echo "     * SmoothTopo  : Flag to Performe Topography Smoothing "
   echo "     * GDASOnly    : Flag to Only Produce Input CPTEC Analysis File (T or F) "
   echo "     * RESIN       : Spectral Horizontal Resolution of Input Data "
   echo "                     4 digits spectral resolution "
   echo "     * KMIN        : Number of Layers of Input Data "
   echo "                     3 digits vertical resolution "
   echo " "
   echo -e "\033[33;1m  Creditos: GDAD/DMD/CPTEC/INPE \033[m"
   echo " "    
}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
mostraHelice() {
#   tput civis
   for i in / - \\ \|
   do
      echo -ne "\033[31;1m"
      echo -ne "\033[1D$i"
      echo -ne "\033[m"
      sleep .1
   done
#   tput cnorm
}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
#function WaitUntilcp()
#{
#   local file
#   file=${1}
#
#   echo " "
#   echo -en "       Checando copia de ${file%%.ok} . aguarde   "
#
#   itr=0
#   while [ ${itr} -eq 0 ] ; do
#      sleep 0.33 | mostraHelice;
#      let itr=`ls ${file} | wc -l`
#   done
#
#   echo " "
#}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
function WaitUntil()
{
   local file
   file=${1}
   file2=${2}
   QPIDpre=${3}
   fileo=${4}
   varname=${5}

   echo " "
   echo -en "     Aguardando arquivo ${file}   "

   fazqstat=0
   while [ \( ! -s ${file} \) ] ; do
      sleep 0.33 | mostraHelice;
      let fazqstat++
      if [ $fazqstat -gt 100 ]; then # o qstat eh executado a cada 33 segundos
         if test ! -e ${file2} ; then
            testpid=$(/opt/pbs/10.4.0.101257/bin/qstat $QPIDpre | tail -1 | awk '{print $5}')
         else
            break
         fi
         if [ 'x'$testpid = 'x' ]; then
            break
         fi
         fazqstat=0
      fi 
   done

   until [ -s ${file} ]; do sleep 1s; done

   if [ $varname != "NormalModes" -a  $varname != "TopographyGradient" ]; then # nao possuem o print 'ends normally' no codigo fortran
   preok=$(cat ${file} | grep -i "normally" | wc -l)
   mensagem=$(cat ${file} | grep -i "normally" )
   if [ ${preok} -eq 1 ];then
      echo " "
      echo " "
      echo -e "    \033[32;1m${mensagem}\033[m"
   else
      echo " "
      echo " "
      echo -e "    \033[31;1m !!! Problema ao executar o ${varname} !!!\033[m"
      echo -e "    \033[31;1m     Nao foi gerado ${fileo} \033[m"
      exit 1
   fi
   fi

#  essa checagem abaixo sera removida quando o print 'ends normally' for adicionado ao codigo fortran
   if [ $varname = NormalModes -o $varname = TopographyGradient ]; then
      if test ! -s ${fileo} ; then
         echo " "
         echo " "
         echo -e "    \033[31;1m !!! Problema ao executar o ${varname} !!!\033[m"
         echo -e "    \033[31;1m     Nao foi gerado ${fileo} \033[m"
         exit 1
      else
         echo " "
         echo " "
         echo -e "    \033[32;1m*** ${varname} ENDS NORMALLY ***\033[m"
      fi
   fi

}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
diffdate() 
{
   di=${1}
   df=${2}
   procname=${3}

   si=$(date --date "${di:0:8} ${di:8:2}:${di:10:2}:${di:12:2}" +%s)
   sf=$(date --date "${df:0:8} ${df:8:2}:${df:10:2}:${df:12:2}" +%s)

   (( horas = (sf - si )/3600 ))
   (( minutos = ( (sf - si ) - horas*3600 )/60 ))
   (( segundos = (sf - si ) - horas*3600 - minutos*60 ))

   if [ $horas    -lt 10 ]; then horas='0'$horas       ; fi
   if [ $minutos  -lt 10 ]; then minutos='0'$minutos   ; fi
   if [ $segundos -lt 10 ]; then segundos='0'$segundos ; fi

   diffd=$horas'h'$minutos'm'$segundos's'
   echo
   echo -e "\033[32;1m     Tempo Total do Processo ${procname}: $diffd \033[m"
   echo
   echo
}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
function lenamelist 
{
   auxdir=$1

   sed 's/#.*$//' $auxdir/namelist.runPre | sed 's/[ ]\+//g' | sed '/^$/d' > $auxdir/namelistrp.tmp
   
   case ${total} in
      0) sed -n '/&opt/{/\//tc;:a;/\//!{N;ba;};:c;s/.*\&opt//;s/\/.*$//;p;}'     $auxdir/namelistrp.tmp  | sed '/^$/d'> $auxdir/tmp ;;
      1) sed -n '/&geral/{/\//tc;:a;/\//!{N;ba;};:c;s/.*\&geral//;s/\/.*$//;p;}' $auxdir/namelistrp.tmp  | sed '/^$/d'> $auxdir/tmp ;;
      2) sed -n '/&debug/{/\//tc;:a;/\//!{N;ba;};:c;s/.*\&debug//;s/\/.*$//;p;}' $auxdir/namelistrp.tmp  | sed '/^$/d'> $auxdir/tmp ;;
      *) echo "Relacao de processos (total ou parcial = ${total}) inexistente...";exit 0;;
   esac

   nl=$(wc -l $auxdir/tmp | awk '{print $1}')

   if [ $nl -gt 0 ]; then
      echo
      echo -e "\033[35;1m     ----- Inicio da Leitura da Relacao de Processos -----\033[m"
      echo
      case ${total} in
         0) echo -e "\033[35;1m     Bloco\033[32;1m opt \033[35;1m\033[m";;
         1) echo -e "\033[35;1m     Bloco\033[32;1m geral \033[35;1m\033[m";;
         2) echo -e "\033[35;1m     Bloco\033[32;1m debug \033[35;1m\033[m";;
      esac
      echo
      rm -fr $auxdir/.listapre 2>&1
      while read linha ; do
         echo "       $linha "| sed 's/=/ = /g' 
         eval export $linha
         echo "$linha" | sed 's/=/ = /g' | grep '= 1' | cut -d' ' -f1 >> $auxdir/.listapre
      done < $auxdir/tmp
   fi

   # Verifica se os executaveis se encontram no pre/exec
   for execfile in $(cat $auxdir/.listapre)
   do
      if [ ${execfile} = ClmtClima ]; then
            if [ ! -e ${DK_suite}/pre/exec/TemperatureClima ]; then
               cp -vf ${dirhome}/sources/TemperatureClima/TemperatureClima ${DK_suite}/pre/exec/ 
            fi
      else
         if [ ${execfile} = Clmt ]; then
            if [ ! -e ${DK_suite}/pre/exec/Temperature ]; then
               cp -vf ${dirhome}/sources/Temperature/Temperature ${DK_suite}/pre/exec/
            fi 
         else
            if [ ! -e ${DK_suite}/pre/exec/${execfile} ]; then
              cp -vf ${dirhome}/sources/${execfile}/${execfile} ${DK_suite}/pre/exec/ 
            fi
         fi
      fi
   done

   echo
   echo -e "\033[35;1m     ----- Fim da Leitura da Relacao de Processos-----\033[m"

   rm -f $auxdir/namelistrp.tmp $auxdir/tmp 
}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
function spid() 
{
   echo
   for i in `seq 1 1 12`; do
      host=eslogin$(printf "%02i\n" $i)
      echo ------------ $host ------------
      ssh $host "ps -u $USER"
      echo -----------------------------------
      echo
      if [ $host = $HOSTNAME ]; then
         echo "AVISO: O PID $$ e' o proprio runPre que esta' executando o spid"
         echo
         echo
      fi 
   done
}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
function fileout()
{
   procname=${1}
   
   varname=$procname

   inputaux=InputDim # cabecalho da primeira linha dos arquivos .nml

   if [ ${procname} = TopoWaterPercNavy ]; then
      file_out=${dirdata}/pre/dataout/TopoNavy.dat
      file_out2=${dirdata}/pre/dataout/WaterNavy.dat
      jobname=TopoNavy 
      ieeefiles='20,30,40'
   fi
   if [ ${procname} = TopoWaterPercGT30 ]; then
      file_out=${dirdata}/pre/dataout/TopoGT30.dat
      file_out2=${dirdata}/pre/dataout/WaterGT30.dat
      jobname=GT30
#      ieeefiles='???'
   fi
   if [ ${procname} = NormalModes  ]; then
      file_out=${dirdata}/model/datain/NMI.${TRUNCA}
      jobname=NormalModes
      ieeefiles='20'
      inputaux=NorModNML
   fi
   if [ ${procname} = LandSeaMask  ]; then
      file_out=${dirdata}/pre/dataout/LandSeaMaskNavy.G${prefix}.dat
      jobname=SeaMask
      ieeefiles='10,20,30'
   fi
   if [ ${procname} = VarTopo ]; then
      file_out=${dirdata}/pre/dataout/Topography.G${prefix}
      jobname=VarTop
      ieeefiles='10,20,30,40'
   fi
   if [ ${procname} = TopoSpectral ]; then
      file_out=${dirdata}/model/datain/TopoVariance.G${prefix}
      jobname=TopoSpectra
      ieeefiles='10,20,30'
   fi
   if [ ${procname} = Chopping_serial  ]; then
      file_out=${dirdata}/model/datain/GANL${PREFXI}${DATA}S.unf.${MRES}
      file_out2=${dirdata}/model/datain/OZON${PREFXI}${DATA}S.grd.${pfxgrd}
      jobname=Chopping
      ieeefiles='10,15,20,25,30,35,40,45,50,55,60,65,70,75'
      inputaux=ChopNML
   fi
   if [ ${procname} = Chopping_parallel  ]; then
      file_out=${dirdata}/model/datain/GANL${PREFXI}${DATA}S.unf.${MRES}
      file_out2=${dirdata}/model/datain/OZON${PREFXI}${DATA}S.grd.${pfxgrd}
      file_out3=${dirdata}/model/datain/TRAC${PREFXI}${DATA}S.grd.${pfxgrd}
      jobname=Chopping
      ieeefiles='10,15,20,25,30,35,40,45,50,55,60,65,70,75'
      inputaux=ChopNML
   fi
   if [ ${procname} = VegetationMaskSSiB ]; then
      file_out=${dirdata}/pre/dataout/VegetationMaskClima.dat
      jobname=VegMasSSiB
      ieeefiles='20,30'
   fi
   if [ ${procname} = VegetationMask ]; then
      file_out=${dirdata}/pre/dataout/VegetationMask.G${prefix}
      jobname=VegetationMask
      ieeefiles='20,30,50'
   fi
   if [ ${procname} = VegetationMaskSiB2Clima ]; then
      file_out=${dirdata}/pre/dataout/VegetationMaskClima.dat
      jobname=VegMasSiB2 
      ieeefiles='10,20,30'
   fi
   if [ ${procname} = VegetationMaskSiB2 ]; then
      file_out=${dirdata}/pre/dataout/VegetationMaskSiB2.G${prefix}
      jobname=VegMaskSiB2 
      ieeefiles='20,30,50'
   fi
   if [ ${procname} = VegetationMaskIBISClima ]; then
      file_out=${dirdata}/pre/dataout/VegetationMaskIBISClima.dat
      jobname=VegMasIBIS 
      ieeefiles='10,20,30'
   fi
   if [ ${procname} = VegetationMaskIBIS ]; then
      file_out=${dirdata}/pre/dataout/VegetationMaskIBISClima.dat
      jobname=VegMasIBIS 
      ieeefiles='20,30,50'
   fi
   if [ ${procname} = VegetationAlbedoSSiB ]; then
      file_out=${dirdata}/model/datain/VegetationMask.G${prefix}
      jobname=VegAlbSSiB 
      ieeefiles='20,40'
   fi
   if [ ${procname} = DeepSoilTemperatureClima ]; then
      file_out=${dirdata}/pre/dataout/DeepSoilTemperatureClima.dat
      jobname=DeepSoilTemClim
      ieeefiles='20'
   fi
   if [ ${procname} = DeepSoilTemperature ]; then
      file_out=${dirdata}/model/datain/DeepSoilTemperature.G${prefix}
      jobname=DeepSoilTemp 
      ieeefiles='10,20'
   fi
   if [ ${procname} = RoughnessLengthClima ]; then
      file_out=${dirdata}/pre/dataout/RoughnessLengthClima.dat
      jobname=RouLenClm 
      ieeefiles='20'
   fi
   if [ ${procname} = RoughnessLength ]; then
      file_out=${dirdata}/model/datain/RoughnessLength.G${prefix}
      jobname=RougLeng
      ieeefiles='10,20'
   fi
   if [ ${procname} = SoilMoistureClima ]; then
      file_out=${dirdata}/pre/dataout/SoilMoistureClima.dat
      jobname=SoilMoisClm
      ieeefiles='20'
   fi
   if [ ${procname} = SoilMoisture ]; then
      file_out=${dirdata}/model/datain/SoilMoisture.G${prefix}
      jobname=SoilMoist
      ieeefiles='20,30'
   fi
   if [ ${procname} = AlbedoClima ]; then
      file_out=${dirdata}/pre/dataout/AlbedoClima.dat
      jobname=AlbClm
      ieeefiles='20'
   fi
   if [ ${procname} = Albedo ]; then
      file_out=${dirdata}/pre/dataout/Albedo.G${prefix}
      jobname=Alb
      ieeefiles='10,20'
   fi
   if [ ${procname} = SnowClima ]; then
      file_out=${dirdata}/model/datain/Snow${DATA}S.unf.G${prefix}
      jobname=SnowClm
      ieeefiles='20,30'
   fi
   if [ ${procname} = SSTClima ]; then
      datt=`echo ${DATA} |cut -c 1-8`
      file_out=${dirdata}/model/datain/SSTClima$datt.G${prefix}
      jobname=SSTClim
      ieeefiles='10,40,50'
   fi
   if [ ${procname} = FLUXCO2Clima ]; then
      datt=`echo ${DATA} |cut -c 1-8`
      file_out=${dirdata}/model/datain/FLUXCO2Clima$datt.G${prefix}
      jobname=FLUXCO2Clim
      ieeefiles='10,40,50'
   fi
   if [ ${procname} = SSTWeeklyNCEP ]; then
      datt=`echo ${DATA} |cut -c 1-8`
      file_out=${dirdata}/pre/dataout/SSTWeekly.$datt
      jobname=SSTWeeklyNCEP
      ieeefiles='10,20'
   fi
   if [ ${procname} = SSTWeekly ]; then
      datt=`echo ${DATA} |cut -c 1-8`
      file_out=${dirdata}/model/datain/SSTWeekly$datt.G${prefix}
      jobname=SSTWeekly
      ieeefiles='10,30,50,60'
   fi
   if [ ${procname} = SNOWWeeklyNCEP ]; then
      datt=`echo ${DATA} |cut -c 1-8`
      file_out=${dirdata}/pre/dataout/SNOWWeekly.$datt
      jobname=SNOWWeeklyNCEP
      ieeefiles='10,20'
   fi
   if [ ${procname} = SoilMoistureWeeklyCPTEC ]; then
      datt=`echo ${DATA} |cut -c 1-8`
      file_out=${dirdata}/pre/dataout/SoilMoistureWeekly.$datt 
      jobname=SoilMWCPTEC
      ieeefiles='10,20'
   fi
   if [ ${procname} = SNOWWeekly ]; then
      datt=`echo ${DATA} |cut -c 1-8`
      file_out=${dirdata}/model/datain/SNOWWeekly.$datt.G${prefix}
      jobname=SNOWWeekly
      ieeefiles='10,20'
   fi
   if [ ${procname} = SoilMoistureWeekly ]; then
      datt=`echo ${DATA} |cut -c 1-8`
      file_out=${dirdata}/model/datain/SoilMoistureWeekly.$datt.G${prefix}
      jobname=SoilMW
      ieeefiles='10,20'
   fi
   if [ ${procname} = CLimaSoilMoistureClima ]; then
      file_out=${dirdata}/pre/dataout/CLimaSoilMoistureClima.dat
      jobname=CSoilMoisC
      ieeefiles='10,20'
   fi
   if [ ${procname} = CLimaSoilMoisture ]; then
      file_out=${dirdata}/model/datain/CLimaSoilMoisture.G${prefix}
      jobname=CSoilMoisture
      ieeefiles='10,20'
   fi
   if [ ${procname} = ClmtClima ]; then
      file_out=${dirdata}/pre/dataout/TemperatureClima.dat
      jobname=ClmtClima
      ieeefiles='10,20'
      varname=TemperatureClima # na versao entregue essa variavel eh alterada dentro do run_ClmtClima.bash
   fi
   if [ ${procname} = Clmt ]; then
      file_out=${dirdata}/model/datain/Temperature.G${prefix}
      jobname=Clmt
      ieeefiles='10,20'
      varname=Temperature # na versao entregue essa variavel eh alterada dentro do run_Clmt.bash
   fi
   if [ ${procname} = DeltaTempColdestClima ]; then
      file_out=${dirdata}/pre/dataout/DeltaTempColdestClima.dat
      jobname=DelTempColdC
      ieeefiles='10,20'
   fi
   if [ ${procname} = DeltaTempColdest ]; then
      file_out=${dirdata}/model/datain/DeltaTempColdes.G${prefix}
      jobname=DelTempCold
      ieeefiles='10,20'
   fi
   if [ ${procname} = NDVIClima ]; then
      file_out=${dirdata}/pre/dataout/NDVIClima.dat
      jobname=NDVIClima
      ieeefiles='10,20'
   fi
   if [ ${procname} = NDVI ]; then
      file_out=${dirdata}/model/datain/NDVI.G${prefix}
      jobname=NDVI
      ieeefiles='10,20'
   fi
   if [ ${procname} = PorceClayMaskIBISClima ]; then
      file_out=${dirdata}/pre/dataout/PorceClayMaskIBISClima.dat
      jobname=PcClayMaskIBISC
      ieeefiles='10,20,30'
   fi
   if [ ${procname} = PorceClayMaskIBIS ]; then
      file_out=${dirdata}/model/datain/PorceClayMaskIBIS.G${prefix}
      jobname=PcClayMaskIBIS
      ieeefiles='20,30,50'
   fi
   if [ ${procname} = PorceClayMaskSiB2Clima ]; then
      file_out=${dirdata}/pre/dataout/PorceClayMaskSiB2Clima.dat
      jobname=PcClayMskSiB2C
      ieeefiles='10,20,30'
   fi
   if [ ${procname} = PorceClayMaskSiB2 ]; then
      file_out=${dirdata}/model/datain/PorceClayMaskSiB2.G${prefix}
      jobname=PcClayMskSiB2
      ieeefiles='20,30,50'
   fi
   if [ ${procname} = PorceSandMaskIBISClima ]; then
      file_out=${dirdata}/pre/dataout/PorceSandMaskIBISClima.dat
      jobname=PcSandMskIBISC
      ieeefiles='10,20,30'
   fi
   if [ ${procname} = PorceSandMaskIBIS ]; then
      file_out=${dirdata}/model/datain/PorceSandMaskIBIS.G${prefix}
      jobname=PcSandMskIBIS
      ieeefiles='20,30,50'
   fi
   if [ ${procname} = PorceSandMaskSiB2Clima ]; then
      file_out=${dirdata}/pre/dataout/PorceSandMaskSiB2Clima.dat
      jobname=PcSandMskSiB2C
      ieeefiles='10,20,30'
   fi
   if [ ${procname} = PorceSandMaskSiB2 ]; then
      file_out=${dirdata}/model/datain/PorceSandMaskSiB2.G${prefix}
      jobname=PcSandMskSiB2
      ieeefiles='20,30,50'
   fi
   if [ ${procname} = SoilTextureMaskSiB2Clima ]; then
      file_out=${dirdata}/pre/dataout/SoilTextureMaskClima.dat
      jobname=SoilTxMskSiB2C
      ieeefiles='10,20,30'
   fi
   if [ ${procname} = SoilTextureMaskSiB2 ]; then
      file_out=${dirdata}/model/datain/SoilTextureMaskSiB2.G${prefix}
      jobname=SoilTxMskSiB2
      ieeefiles='20,30,50'
   fi
   if [ ${procname} = SSTMonthlyDirec ]; then
      DATA1=`echo ${DATA} | awk '{print substr($1,1,8)}'`
      file_out=${dirdata}/model/datain/SSTMonthlyDirec${DATA1}.G${prefix}
      jobname=SSTMonthlyDirec
      ieeefiles='10,30,50,60'
   fi
   if [ ${procname} = SSTDailyDirec ]; then
      DATA1=`echo ${DATA} | awk '{print substr($1,1,8)}'`
      file_out=${dirdata}/model/datain/SSTDailyDirec${DATA1}.G${prefix}
      jobname=SSTDailyDirec
      ieeefiles='10,30,50,60'
   fi
   if [ ${procname} = TopographyGradient ]; then
      file_out=${dirdata}/model/datain/TopographyGradient${DATA}.G${prefix}
      jobname=TopoGrad
      ieeefiles='10,20'
      inputaux=TopoGradNML
   fi
}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
function crianml() 
{ 
   varname=$1
   echo -e "\033[35;1m     ----- Cria namelist -----\033[m"
   if [ $varname = ClmtClima ]; then
      varname=TemperatureClima
   fi
   if [ $varname = Clmt ]; then
      varname=Temperature
   fi
   rm -f ${DK_suite}/pre/exec/${varname}.nml
   sed    's/#.*$//'           ${onde}/namelist.runPre  > ${DK_suite}/pre/exec/namelistrp.tmp
   sed -i '/DirBCs=/s/\//|/g'  ${DK_suite}/pre/exec/namelistrp.tmp
   sed -i '/DirMain=/s/\//|/g' ${DK_suite}/pre/exec//namelistrp.tmp
   sed -i '/DirHome=/s/\//|/g' ${DK_suite}/pre/exec/namelistrp.tmp
   sed -n "/&${varname}$/{/\//tc;:a;/\//!{N;ba;};:c;s/.*\&${varname}//;p;}" ${DK_suite}/pre/exec/namelistrp.tmp  > ${DK_suite}/pre/exec/tmp
   nl=$(wc -l ${DK_suite}/pre/exec/tmp | awk '{print $1}')
   if [ $nl -gt 0 ]; then
      echo -e "\033[35;1m     ----- Gerando o arquivo \033[32;1m ${varname}.nml \033[35;1m\033[m"
      while read linha2 ; do
         echo "  $linha2"| sed s/'${IM}'/$IM/g | sed s/'${JM}'/$JM/g | sed s,'${dirdata}',"$dirdata",g \
                         | sed s/'${RESOUT}'/$RESOUT/g | sed s/'${KMOUT}'/$KMOUT/g | sed s/'${RESO}'/$RESO/g \
                         | sed s/'${RESIN}'/$RESIN/g | sed s/'${KMIN}'/$KMIN/g | sed s/'${GetOzone}'/$GetOzone/g \
                         | sed s/'${GetTracers}'/$GetTracers/g | sed s/'${GrADS}'/$GrADS/g | sed s/'${GrADSOnly}'/$GrADSOnly/g \
                         | sed s/'${GDASOnly}'/$GDASOnly/g | sed s/'${SmoothTopo}'/$SmoothTopo/g | sed s/'${RmGANL}'/$RmGANL/g \
                         | sed s/'${SetLinear}'/$SetLinear/g | sed s/'${DATA}'/$DATA/g | sed s/'${UTC}'/$UTC/g \
                         | sed s/'${AnlPref}'/$AnlPref/g | sed s,'${dirhome}',"$dirhome",g | sed s/'${MendCut}'/$MendCut/g \
                         | sed s/'${SmthPerCut}'/$SmthPerCut/g \
                         | sed s/'${PREFIXO}'/$PREFIXO/g 
      done < ${DK_suite}/pre/exec/tmp > ${DK_suite}/pre/exec/${varname}.nml
   fi
   sed -i 's, inputaux=,\&,g'  ${DK_suite}/pre/exec/${varname}.nml  
   sed -i '/^\s*$/d'           ${DK_suite}/pre/exec/${varname}.nml  
   sed -i '/DirBCs=/s/|/\//g'  ${DK_suite}/pre/exec/${varname}.nml 
   sed -i '/DirMain=/s/|/\//g' ${DK_suite}/pre/exec/${varname}.nml 
   sed -i '/DirHome=/s/|/\//g' ${DK_suite}/pre/exec/${varname}.nml 
   sed -i '$ d'                ${DK_suite}/pre/exec/${varname}.nml   
   if test ! -s ${DK_suite}/pre/exec/${varname}.nml ; then
      echo -e "\033[31;1m     ----- Problema na criacao do arquivo! -----\033[m"
      exit 1 
   else
      echo " /" >>  ${DK_suite}/pre/exec/${varname}.nml  
      echo -e "\033[35;1m     ----- arquivo pronto -----\033[m" 
      rm -f ${DK_suite}/pre/exec/namelistrp.tmp ${DK_suite}/pre/exec/tmp
   fi
}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
function GetSNOW() 
{
   #
   #  Run GetSNOW.ksh
   #  To deGRIB NCEP SNOW file with the script GetSNOW.ksh
   #  and to format properly the file for SNOWWeekly)
   #
   YYYYMMDD=`echo ${DATA} |cut -c1-8`
   hh12=`echo ${DATA} |cut -c9-10`
   hh=00
   cd ${dirdata}/pre/datain
   rm -f dump
   rec=`${dirgrads}/wgrib -s -4yr -d 1 -ieee gdas1.T${hh12}Z.snogrb.${YYYYMMDD}${hh12}`
   mv dump gdas1.T${hh}Z.snogrd.${DATA}

   rec=`${dirgrads}/wgrib2 -s -YY -d 1 -order we:ns gdas1.T${hh}Z.snogrb2.${YYYYMMDD}${hh} -ieee gdas1.T${hh}Z.snogrd.${YYYYMMDD}${hh}`
   rec=`${dirgrads}/wgrib2 -s -YY -d 1 -order we:ns gdas1.T${hh}Z.snogrb2.${YYYYMMDD}${hh} -ieee gdas1.T${hh12}Z.snogrd.${YYYYMMDD}${hh12}`

   echo ${rec}
   date=`awk 'BEGIN {print substr("'${rec}'",7,10)}'`
   echo ${DATA}
   #
}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
function GetSoilMoisture() 
{
   #
   #  Run GetSoilMoisture.ksh
   #  To deGRIB CPTEC SoilMoisture file with the script GetSoilMoisture.ksh
   #  and to format properly the file for SoilMoistureWeekly)
   #
   YYYYMMDD=`echo ${DATA} |cut -c1-8`
   hh12=`echo ${DATA} |cut -c9-10`
   hh=00
   cd ${dirdata}/pre/datain
   #rm -f dump
   #rec=`${dirgrads}/wgrib -s -4yr -d 1 -ieee gdas1.T${hh12}Z.snogrb.${YYYYMMDD}${hh12}`
   #mv dump gdas1.T${hh}Z.snogrd.${DATA}

   #rec=`${dirgrads}/wgrib2 -s -YY -d 1 -order we:ns gdas1.T${hh}Z.snogrb2.${YYYYMMDD}${hh} -ieee gdas1.T${hh}Z.snogrd.${YYYYMMDD}${hh}`
   #rec=`${dirgrads}/wgrib2 -s -YY -d 1 -order we:ns gdas1.T${hh}Z.snogrb2.${YYYYMMDD}${hh} -ieee gdas1.T${hh12}Z.snogrd.${YYYYMMDD}${hh12}`

   #echo ${rec}
   #date=`awk 'BEGIN {print substr("'${rec}'",7,10)}'`
   echo ${DATA}
   #
}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
function GetSST() 
{
   #
   #  Run GetSST.ksh
   #  To deGRIB NCEP SST file with the script GetSST.ksh
   #  and to format properly the file for SSTWeekly)
   #
   YYYYMMDD=`echo ${DATA} |cut -c1-8`
   hh12=`echo ${DATA} |cut -c9-10`
   hh=00

   cd ${dirdata}/pre/datain

   if [ -s gdas1.T${hh12}Z.sstgrb.${YYYYMMDD}${hh12} ]
   then
     rec=`${dirgrads}/wgrib -s -4yr -d 1 -ieee gdas1.T${hh12}Z.sstgrb.${YYYYMMDD}${hh12}`
     mv dump gdas1.T${hh}Z.sstgrd.${DATA}
   elif [ -s gdas1.T${hh}Z.sstgrb2.${YYYYMMDD}${hh} ]
   then
     rec=`${dirgrads}/wgrib2 -s -YY -d 1 -order we:ns gdas1.T${hh}Z.sstgrb2.${YYYYMMDD}${hh} -ieee gdas1.T${hh12}Z.sstgrd.${YYYYMMDD}${hh12}`
   elif [ -s gdas1.T${hh}Z.sstgrb2.${YYYYMMDD}${hh} ]
   then
     rec=`${dirgrads}/wgrib2 -s -YY -d 1 -order we:ns gdas1.T${hh}Z.sstgrb2.${YYYYMMDD}${hh} -ieee gdas1.T${hh12}Z.sstgrd.${YYYYMMDD}${hh12}`
   elif [ -s gdas1.T${hh}Z.sstgrb2.${YYYYMMDD}${hh12} ]
   then
     rec=`${dirgrads}/wgrib2 -s -YY -d 1 -order we:ns gdas1.T${hh}Z.sstgrb2.${YYYYMMDD}${hh12} -ieee gdas1.T${hh12}Z.sstgrd.${YYYYMMDD}${hh12}`
   elif [ -s rtgssthr_grb_0.083.grib2.${YYYYMMDD} ]
   then
     rec=`${dirgrads}/wgrib2 -s -YY -d 1 -order we:ns rtgssthr_grb_0.083.grib2.${YYYYMMDD} -ieee gdas1.T${hh12}Z.sstgrd.${YYYYMMDD}${hh12}`
   else
     echo "SST file not found!"
   fi
   
   echo ${rec}
   date=`awk 'BEGIN {print substr("'${rec}'",7,10)}'`
   echo ${DATA}
   #
}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************
function criabash() 
{
   export FEXE=`pwd`
   export cpu_mpi=$1
   export cpu_node=$2
   export RES=$3        # jobname
   export varname=$4    # linha
   num=$(($cpu_mpi+$cpu_node-1))
   fra=$(($num/$cpu_node))
   cpu_tot=$(($fra*$cpu_node))
#   echo fila=mpi-npn${cpu_node} total cpus=${cpu_tot}

   if [ $varname = ClmtClima ]; then
      varname=TemperatureClima
   fi
   if [ $varname = Clmt ]; then
      varname=Temperature
   fi

#
   direxe=${dirdata}/pre/exec
   dirsrc=${dirhome}/sources/${varname}
   dirout=${dirhome}/scripts/output
   dirrun=${dirhome}/scripts
   echo " "
   host=`hostname`
   echo "     ${host}"
   RUNTM=`date +'%d_%H:%M'`
#

   if [ $varname = Chopping_parallel ]; then
      cp -f ${dirsrc}/Delta* ${dirdata}/pre/datain/
      export PBS_SERVER=${pbs_server1}
      export HEADBASH="#!/bin/bash -x"     # for debug
      export FILAPBS="#PBS -q ${QUEUEP}"
   else 
      export PBS_SERVER=${pbs_server2}
      export HEADBASH="#!/bin/bash"
      export FILAPBS="#PBS -q ${AUX_QUEUE}"
   fi

   optserver=`printf "$PBS_SERVER \n" | cut -c1-3`
   if [[ (${optserver} = "aux") ]]; then
      export MPPBS="#"
   else
      export MPPBS="#PBS -l mppwidth=${cpu_mpi}"
   fi

   auxvarname=$varname

   rm -f ${direxe}/set${varname}.bash > /dev/null 2>&1
   rm -f ${direxe}/Out.MPI${cpu_mpi}_${varname} > /dev/null 2>&1
   rm -f ${direxe}/.${varname}.ok > /dev/null 2>&1

cat <<EOT1 > ${direxe}/set${varname}.bash
${HEADBASH}
#PBS -o ${host}:${direxe}/Out.MPI${cpu_mpi}_${varname}
#PBS -j oe
#PBS -l walltime=${AUX_WALLTIME}
#PBS -A ${QUOTA}
${MPPBS}
#PBS -l mppnppn=${cpu_node}
#PBS -V
#PBS -S /bin/bash
#PBS -N $RES
${FILAPBS}

#
auxvarname=`printf "$varname"`
if [[ (\${auxvarname} = "Chopping_parallel") ]]; then
.  /opt/modules/default/etc/modules.sh
   module load stat
   module list
#   
   export PBS_SERVER=${pbs_server1}
#   echo \${PBS_O_QUEUE} # doing nothing
else
   export PBS_SERVER=${pbs_server2}
fi

if [[ (${MAQUI} = "Linux") || (${MAQUI} = "linux") ]]; then
  export F_UFMTENDIAN=${ieeefiles}
#  export GFORTRAN_CONVERT_UNIT=big_endian:${ieeefiles}
  echo "F_UFMTENDIAN = \${F_UFMTENDIAN}"
  echo "GFORTRAN_CONVERT_UNIT = \${GFORTRAN_CONVERT_UNIT}"
fi
export KMP_STACKSIZE=128m

if [[ (\${auxvarname} = "FLUXCO2Clima") ]]; then
   ulimit -s 65532
else
   ulimit -s unlimited
fi

#
cd ${direxe}
date
optserver=`printf "$PBS_SERVER \n" | cut -c1-3`
if [[ (\${optserver} = "aux") ]]; then
${direxe}/${varname} -i ${direxe}/${varname}.nml
else
time aprun -n ${cpu_mpi} -N ${cpu_node} ${direxe}/${varname} -i ${direxe}/${varname}.nml
fi
wait
date
wait
touch ${direxe}/.${varname}.ok

EOT1

#
#  Change mode to be executable
#
   chmod +x ${direxe}/set${varname}.bash 

}
#**********************************************************************************************
#**********************************************************************************************
#**********************************************************************************************

#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------
#--------------------- I N I C I O   D O   P R E - P R O C E S S A M E N T O ------------------
#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------

#
# Verificando argumentos de entrada
#
if [ "$#" -ne 9 ]; then
  if [ 'x'$1 = 'xspid' ]; then
     spid
     exit 
  else
     usageprincipal
     exit 1
  fi
fi

#
# pegando argumentos
#
TRC=${1}             
LV=${2}              
DATA=${3}       # LABELI initial data YYYYMMDDHH 
PREFIXO=${4}    # PREFIX   
total=${5}         
SmoothTopo=${6} # Flag to Performe Topography Smoothing
if [ ${SmoothTopo} == "T" ]
then
  export PREFIXO=SMT 
fi
GDASOnly=${7}   # Flag to Only Produce Input CPTEC Analysis File
RESIN=${8}      # Spectral Horizontal Resolution of Input Data
KMIN=${9}       # Number of Layers of Input Data

#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------

CASE=`echo ${TRC} ${LV} |awk '{ printf("TQ%4.4dL%3.3d\n",$1,$2)  }' `
#PATHA=`pwd`
#export FILEENV=`find ${PATHA} -name EnvironmentalVariablesMCGA -print`
#export PATHENV=`dirname ${FILEENV}`

export PATHENV=$(dirname $(readlink -e ${0})) # Local (path) onde est√° este script
export FILEENV=${PATHENV}/EnvironmentalVariablesMCGA
export PATHBASE=`cd ${PATHENV};cd ../;pwd`
. ${FILEENV} ${CASE} ${PREFIXO}
cd ${DK_suite}/pre/exec

# Set  Res for Chopping
typeset -x prefi
export RESOUT=`echo $1 | awk '{print $1/1}'`
export KMOUT=`echo $2 | awk '{print $1/1}'`
export GetOzone=T      #! Flag to Produce Ozone Files
export GetTracers=T    #! Flag to Produce Tracers Files
export GrADS=T         #! Flag to Produce GrADS Files
export GrADSOnly=F     #! Flag to Only Produce GrADS Files (Do Not Produce Inputs for Model)
export RmGANL=F        #! Flag to Remove GANL File if Desired
export MendCut=`echo $RESOUT | awk '{ print (int(1/((5+(40000/($1*3)))*(3/(40000)))) +1) }' ` #! FLAG to Spectral Resolution Cut Off for Topography Smoothing
#export MendCut=`echo $RESOUT | awk '{ print (int(1/((8+(1/($1))))) +1) }' ` #! FLAG to Spectral Resolution Cut Off for Topography Smoothing
#export MendCut=$RESOUT
export SmthPerCut=0.12 #! FLAG to Percentage for Topography Smoothing

export SetLinear=FALSE
export RESO=${1}

case ${RESOUT} in
21)   export IM=64;   export JM=32;   export timestep=3600;;
31)   export IM=96;   export JM=48;   export timestep=1800;;
42)   export IM=128;  export JM=64;   export timestep=1200;;
62)   export IM=192;  export JM=96;   export timestep=900;;
106)  export IM=320;  export JM=160;  export timestep=600;;
126)  export IM=384;  export JM=192;  export timestep=450;;
133)  export IM=400;  export JM=200;  export timestep=450;;
159)  export IM=480;  export JM=240;  export timestep=360;;
170)  export IM=512;  export JM=256;  export timestep=360;;
213)  export IM=640;  export JM=320;  export timestep=300;;
213)  export IM=640;  export JM=320;  export timestep=300;;
254)  export IM=768;  export JM=384;  export timestep=240;;
299)  export IM=900;  export JM=450;  export timestep=200;;
319)  export IM=960;  export JM=480;  export timestep=180;;
341)  export IM=1024; export JM=512;  export timestep=180;;
382)  export IM=1152; export JM=576;  export timestep=150;;
511)  export IM=1536; export JM=768;  export timestep=120;;
533)  export IM=1600; export JM=800;  export timestep=120;;
666)  export IM=2000; export JM=1000; export timestep=90;;
863)  export IM=2592; export JM=1296; export timestep=60;;
1279) export IM=3840; export JM=1920; export timestep=20;;
1332) export IM=4000; export JM=2000; export timestep=20;;
*) echo "Spectral resolution (TRC=${RESOUT}) is not contemplated...";exit 0;;
esac

if [[ "$SetLinear" = "TRUE" ]]; then
   export TRUNC=`echo ${RESOUT} |awk '{ printf("TL%4.4d\n",$1)  }' `
   export MRES=`echo ${TRC} ${LV} |awk '{ printf("TL%4.4dL%3.3d\n",$1,$2)  }' `
else
   export TRUNC=`echo ${RESOUT} |awk '{ printf("TQ%4.4d\n",$1)  }' `
   export MRES=`echo ${TRC} ${LV} |awk '{ printf("TQ%4.4dL%3.3d\n",$1,$2)  }' `
fi

export TRUNCA=`echo ${TRC} ${LV} |awk '{ printf("T%4.4dL%3.3d\n",$1,$2)  }' `

export pfxgrd=`echo ${JM} ${LV}  |awk '{ printf("G%5.5dL%3.3d\n",$1,$2)  }' `

prefix=`echo ${JM} |awk '{ printf("%5.5d\n",$1)  }' `

#set run date

export DATA=$DATA 
echo $DATA

# AnlPref ja esta definida no EnviromentalVariablesMCGA
#if [ -z "${AnlPref}" ]; then
##   export AnlPref=gdas1
#   export AnlPref=gblav
#fi 

export dirhome=${HOME_suite}/pre
export dirdata=${DK_suite}
export dirgrads=${DIRGRADS}

# Machine options: SX6; Linux
export MAQUI=Linux
export PBS_SERVER=${pbs_server2}

export cpu_mpi_aux=24   # numero de processadores
export cpu_node_aux=24  # processadores por no'

#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------

export onde=$PATHBASE/run
#export onde=$PATHBASE/pre/run   # PAD

lenamelist $onde    # essa leitura gera uma lista com os processos escolhidos para rodar no pre

#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------

# No repositorio atual, ha o arquivo <dir>/bam/pre/datasst/oiv2monthly/sstmtd.nml utilizado pelo 
# processo SSTMonthlyDirec. Nesse arquivo, o diretorio <dir> esta apontado para a conta do Paulo 
# Kubota. O comando abaixo corrige esse diretorio caso seja necessario.

#sed -i s,'/scratchin/grupos/pad/home/paulo.kubota/agcmibis_clima',"${dirdata}",g \       # PAD
sed -i s,'/scratchin/grupos/pad/home/paulo.kubota/agcmibis',"${dirdata}",g \
        ${dirdata}/pre/datasst/oiv2monthly/sstmtd.nml

#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------

echo
echo -e "   > \033[33;1mExecutando o Pre-processamento\033[m"
echo

while read linha; do

   date +%Y%m%d%H%M%S > ${onde}/.tempoi

   echo -e "   > \033[33;1mProcesso: ${linha}\033[m"
   echo " "

   fileout $linha

   crianml $linha

   if [ $linha = SSTWeeklyNCEP ]; then
      GetSST
   fi
   if [ $linha = SNOWWeeklyNCEP ]; then
      GetSNOW
   fi
   if [ $linha = SoilMoistureWeeklyCPTEC ]; then
      GetSoilMoisture
   fi

#
#  cria script de submissao
#
   if [ $linha = Chopping_parallel ]; then
      echo " "
      echo -e "     \033[33;1mCria .bash e submete o processo: criabash ${cpu_mpi_aux} ${cpu_node_aux} ${jobname} ${linha}\033[m"
      criabash ${cpu_mpi_aux} ${cpu_node_aux} ${jobname} ${linha}
   else
      if [ $linha = Chopping_serial ]; then
         echo " "
         echo -e "     \033[33;1mCria .bash e submete o processo: criabash 24 1 ${jobname} ${linha}\033[m"
         criabash 24 1 ${jobname} ${linha}
      else
         echo " "
         echo -e "     \033[33;1mCria .bash e submete o processo: criabash 1 1 ${jobname} ${linha}\033[m"
         criabash 1 1 ${jobname} ${linha}
      fi
   fi

#
#  submete processo 
#
   #${QSUB} ${direxe}/set${varname}.bash
   export QPIDpre=$(${QSUB} ${direxe}/set${varname}.bash)
   echo "     QPIDpre: ${QPIDpre}"

   fileout $linha

#
#  checa o log do processo e copia as saidas quando necessario
#
   if [ $linha = Chopping_parallel ]; then
      WaitUntil ${direxe}/Out.MPI${cpu_mpi_aux}_${varname} ${direxe}/.${linha}.ok ${QPIDpre} ${file_out} ${linha}
      sleep 15 # checar se a pausa eh suficiente para a copia de arquivos grandes
   else
      if [ $linha = Chopping_serial ]; then # checar se falta file_out3
         WaitUntil ${direxe}/Out.MPI24_${varname} ${direxe}/.${linha}.ok ${QPIDpre} ${file_out} ${linha}
         sleep 15 
      else
         WaitUntil ${direxe}/Out.MPI1_${varname} ${direxe}/.${linha}.ok ${QPIDpre} ${file_out} ${linha}
      fi
   fi

#
#  checa a existencia das saidas dos processos
#
   if [ $linha = TopoWaterPercNavy -o $linha = TopoWaterPercGT30 ]; then
      if test ! -s ${file_out} ; then 
         echo
         echo -e "    \033[31;1m Problema!!! Nao foi gerado ${file_out} !!!\033[m"
         exit 1
      else 
         if test ! -s ${file_out2} ; then
            echo
            echo -e "    \033[31;1m Problema!!! Nao foi gerado ${file_out2} !!!\033[m"
            exit 1
         else
            echo
            echo "     Fim do $linha"
         fi
      fi
   else
      if test ! -s ${file_out} ; then
         echo
         echo -e "    \033[31;1m Problema!!! Nao foi gerado ${file_out} !!!\033[m"
         exit 1
      else
         echo
         echo "     Fim do $linha"
      fi
   fi

   date +%Y%m%d%H%M%S > ${onde}/.tempof
   diffdate $(cat ${onde}/.tempoi) $(cat ${onde}/.tempof) $linha
   rm -f ${onde}/.tempoi ${onde}/.tempof

done < $onde/.listapre

rm -f $onde/.listapre 2>&1

#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------
#---------------------- F I M   D O   P R E - P R O C E S S A M E N T O -----------------------
#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------

echo
echo -e "\033[32;1m     ------------------------------------------------------------ \033[m"
echo -e "\033[32;1m                                  F I M \033[m"
echo -e "\033[32;1m     ------------------------------------------------------------ \033[m"
echo

#
#EOC
#---------------------------------------------------------------------------------------------#
