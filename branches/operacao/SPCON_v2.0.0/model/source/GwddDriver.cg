       !        
       !        Cray Inc. Decompilation
       !        Notice - This output is provided for information only.
       !        
       !        Cray Inc. reserves the right to change the format of this
       !        information at any time and does not guarantee the
       !        readability or accuracy of this information.
       !        
       !        This information may not be compilable and corresponds to
       !        the internal representation of the program during the
       !        optimization phase of the compilation process.
       !        
       !        Source                :  GwddDriver.f90
       !        File                  :  GwddDriver.cg
       !        Network               :  Gemini interconnect
       !        Target                :  X86, 64-bit, sse3
       !        
   44.       
   44.       subroutine initgwdddriver( kmax, si )
   42.       call initgwddschalpert( 0[loc( si ),0].L, 0[loc( kmax ),0] )
   44.       return
   44.       end
   44.       
   86.       
   86.       subroutine gwdd_driver( ps, gu, gv, gt, chug, chvg, xdrag, ydrag, var, varcut, sigml, sig, delsig, ncols, kmax, latco )
   69.       call gwddschalpert( 0[loc( ps ),0].L, 0[loc( gu ),0].L, 0[loc( gv ),0].L, 0[loc( gt ),0].L, 0[loc( chug ),0].L, 0[loc( chvg ),0].L, 0[loc( xdrag ),0].L, 0[loc( ydrag ),0].L, 0[loc( var ),0].L, 0[loc( varcut ),0].L, 0[loc( sigml ),0].L, 0[loc( sig ),0].L, 0[loc( delsig ),0].L, 0[loc( ncols ),0], 0[loc( kmax ),0] )
   76.       if ( int( startstordiag ) /= 0 ) then
   77.          call gwdddiagnstorage( 0[loc( latco ),0], 0[loc( ncols ),0], 0[loc( kmax ),0], 0[loc( xdrag ),0].L, 0[loc( ydrag ),0].L, 0[loc( chug ),0].L, 0[loc( chvg ),0].L )
   77.       endif
   82.       t$21 = isgridhistoryon
   86.       return
   86.       end
   86.       
   88.       
   88.       subroutine gwddgridhistorystorage
   92.       return
   92.       end
   92.       
  111.       
  111.       subroutine gwdddiagnstorage( latco, ncols, kmax, xdrag, ydrag, chug, chvg )
  106.       $MR_dodia_S1 = (7,dodia)[0].L
  106.       $MR_dodia_S0 = (6,dodia)[0].L
  106.       $LCS_0 = $MR_dodia_S0 + $MR_dodia_S1
  106.       if ( or( -44 + $LCS_0, 43 - $MR_dodia_S0 ) < 0 ) then
  106.          $LB_Y0 = $MR_dodia_S0
  106.          $UB_Y1 = -1 + $LCS_0
  106.          $Subscript_Y5 = 43
  106.          _bounds_error( $_File_Y40, $Line_Y42, $_Name_Y41, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y43 )
  106.       endif
  106.       $MR_dodia_S2 = dodia[0].L
  106.       if ( int( 43[int( $MR_dodia_S2, 8 ),-$MR_dodia_S0] ) /= 0 ) then
  106. !dir$ suppress 0[loc( xdrag ),0].L
  106.          $MR_ncols_S3 = 0[loc( ncols ),0]
  106.          if ( $MR_ncols_S3 <= 0 ) then
  106.             $LB_Y0 = 1
  106.             $UB_Y1 = $MR_ncols_S3
  106.             $Subscript_Y5 = 1
  106.             _bounds_error( $_File_Y40, $Line_Y42, $_Name_Y44, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y45 )
  106.          endif
  106.          t$22[0].L = pointer to array[1] of real (kind=8)( cri_pointer( xdrag ) )
  106.          (1,t$22)[0].L = 64
  106.          (2,t$22)[0].L = 0x100000000020051UL
  106.          (6,t$22)[0] = 13
  106.          (7,t$22)[0] = 134481411
  106.          (4,t$22)[0].L = 0
  106.          (5,t$22)[0].L = 0
  106.          (6,t$22)[0].L = 1
  106.          (7,t$22)[0].L = max( 0, $MR_ncols_S3 )
  106.          (8,t$22)[0].L = 1
  106.          ipa$31 = 43
  106.          call updia1d( t$22, ipa$31, 0[loc( latco ),0] )
  106.       endif
  107.       $MR_dodia_S5 = (7,dodia)[0].L
  107.       $MR_dodia_S4 = (6,dodia)[0].L
  107.       $LCS_1 = $MR_dodia_S4 + $MR_dodia_S5
  107.       if ( or( -45 + $LCS_1, 44 - $MR_dodia_S4 ) < 0 ) then
  107.          $LB_Y0 = $MR_dodia_S4
  107.          $UB_Y1 = -1 + $LCS_1
  107.          $Subscript_Y5 = 44
  107.          _bounds_error( $_File_Y40, $Line_Y46, $_Name_Y41, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y47 )
  107.       endif
  107.       $MR_dodia_S6 = dodia[0].L
  107.       if ( int( 44[int( $MR_dodia_S6, 8 ),-$MR_dodia_S4] ) /= 0 ) then
  107. !dir$ suppress 0[loc( ydrag ),0].L
  107.          $MR_ncols_S7 = 0[loc( ncols ),0]
  107.          if ( $MR_ncols_S7 <= 0 ) then
  107.             $LB_Y0 = 1
  107.             $UB_Y1 = $MR_ncols_S7
  107.             $Subscript_Y5 = 1
  107.             _bounds_error( $_File_Y40, $Line_Y46, $_Name_Y48, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y49 )
  107.          endif
  107.          t$23[0].L = pointer to array[1] of real (kind=8)( cri_pointer( ydrag ) )
  107.          (1,t$23)[0].L = 64
  107.          (2,t$23)[0].L = 0x100000000020051UL
  107.          (6,t$23)[0] = 13
  107.          (7,t$23)[0] = 134481411
  107.          (4,t$23)[0].L = 0
  107.          (5,t$23)[0].L = 0
  107.          (6,t$23)[0].L = 1
  107.          (7,t$23)[0].L = max( 0, $MR_ncols_S7 )
  107.          (8,t$23)[0].L = 1
  107.          ipa$33 = 44
  107.          call updia1d( t$23, ipa$33, 0[loc( latco ),0] )
  107.       endif
  108.       $MR_dodia_S9 = (7,dodia)[0].L
  108.       $MR_dodia_S8 = (6,dodia)[0].L
  108.       $LCS_2 = $MR_dodia_S8 + $MR_dodia_S9
  108.       if ( or( -46 + $LCS_2, 45 - $MR_dodia_S8 ) < 0 ) then
  108.          $LB_Y0 = $MR_dodia_S8
  108.          $UB_Y1 = -1 + $LCS_2
  108.          $Subscript_Y5 = 45
  108.          _bounds_error( $_File_Y40, $Line_Y50, $_Name_Y41, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y51 )
  108.       endif
  108.       $MR_dodia_S10 = dodia[0].L
  108.       if ( int( 45[int( $MR_dodia_S10, 8 ),-$MR_dodia_S8] ) /= 0 ) then
  108. !dir$ suppress 0[loc( chug ),0].L
  108.          $MR_kmax_S11 = 0[loc( kmax ),0]
  108.          if ( $MR_kmax_S11 <= 0 ) then
  108.             $LB_Y0 = 1
  108.             $UB_Y1 = $MR_kmax_S11
  108.             $Subscript_Y5 = 1
  108.             _bounds_error( $_File_Y40, $Line_Y50, $_Name_Y52, $Dim_Y9, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y53 )
  108.          endif
  108.          $MR_ncols_S12 = 0[loc( ncols ),0]
  108.          if ( $MR_ncols_S12 <= 0 ) then
  108.             $LB_Y0 = 1
  108.             $UB_Y1 = $MR_ncols_S12
  108.             $Subscript_Y5 = 1
  108.             _bounds_error( $_File_Y40, $Line_Y50, $_Name_Y54, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y55 )
  108.          endif
  108.          t$24[0].L = pointer to array[1] of array[1] of real (kind=8)( cri_pointer( chug ) )
  108.          (1,t$24)[0].L = 64
  108.          (2,t$24)[0].L = 0x200000000020051UL
  108.          (6,t$24)[0] = 13
  108.          (7,t$24)[0] = 134481411
  108.          (4,t$24)[0].L = 0
  108.          (5,t$24)[0].L = 0
  108.          (6,t$24)[0].L = 1
  108.          $LCS_3 = max( 0, $MR_ncols_S12 )
  108.          (7,t$24)[0].L = $LCS_3
  108.          (8,t$24)[0].L = 1
  108.          (9,t$24)[0].L = 1
  108.          (10,t$24)[0].L = max( 0, $MR_kmax_S11 )
  108.          (11,t$24)[0].L = $LCS_3
  108.          ipa$35 = 45
  108.          call updia2d( t$24, ipa$35, 0[loc( latco ),0] )
  108.       endif
  109.       $MR_dodia_S14 = (7,dodia)[0].L
  109.       $MR_dodia_S13 = (6,dodia)[0].L
  109.       $LCS_4 = $MR_dodia_S13 + $MR_dodia_S14
  109.       if ( or( -47 + $LCS_4, 46 - $MR_dodia_S13 ) < 0 ) then
  109.          $LB_Y0 = $MR_dodia_S13
  109.          $UB_Y1 = -1 + $LCS_4
  109.          $Subscript_Y5 = 46
  109.          _bounds_error( $_File_Y40, $Line_Y56, $_Name_Y41, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y57 )
  109.       endif
  109.       $MR_dodia_S15 = dodia[0].L
  109.       if ( int( 46[int( $MR_dodia_S15, 8 ),-$MR_dodia_S13] ) /= 0 ) then
  109. !dir$ suppress 0[loc( chvg ),0].L
  109.          $MR_kmax_S16 = 0[loc( kmax ),0]
  109.          if ( $MR_kmax_S16 <= 0 ) then
  109.             $LB_Y0 = 1
  109.             $UB_Y1 = $MR_kmax_S16
  109.             $Subscript_Y5 = 1
  109.             _bounds_error( $_File_Y40, $Line_Y56, $_Name_Y58, $Dim_Y9, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y59 )
  109.          endif
  109.          $MR_ncols_S17 = 0[loc( ncols ),0]
  109.          if ( $MR_ncols_S17 <= 0 ) then
  109.             $LB_Y0 = 1
  109.             $UB_Y1 = $MR_ncols_S17
  109.             $Subscript_Y5 = 1
  109.             _bounds_error( $_File_Y40, $Line_Y56, $_Name_Y60, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y61 )
  109.          endif
  109.          t$25[0].L = pointer to array[1] of array[1] of real (kind=8)( cri_pointer( chvg ) )
  109.          (1,t$25)[0].L = 64
  109.          (2,t$25)[0].L = 0x200000000020051UL
  109.          (6,t$25)[0] = 13
  109.          (7,t$25)[0] = 134481411
  109.          (4,t$25)[0].L = 0
  109.          (5,t$25)[0].L = 0
  109.          (6,t$25)[0].L = 1
  109.          $LCS_5 = max( 0, $MR_ncols_S17 )
  109.          (7,t$25)[0].L = $LCS_5
  109.          (8,t$25)[0].L = 1
  109.          (9,t$25)[0].L = 1
  109.          (10,t$25)[0].L = max( 0, $MR_kmax_S16 )
  109.          (11,t$25)[0].L = $LCS_5
  109.          ipa$36 = 46
  109.          call updia2d( t$25, ipa$36, 0[loc( latco ),0] )
  109.       endif
  111.       return
  111.       end
  111.       
    6.       
    6.       module gwdddriver
  113.       return
  113.       end
  113.       
