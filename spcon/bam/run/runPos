#!/bin/bash
#-------------------------------------------------------------------#
#
#-------------------------------------------------------------------#
#BOP
# !DESCRIPTION: script utilizado para rodar o pos-processamento do 
#               modelo global do CPTEC.
#
# !CALLING SEQUENCE:
#      
#   ./runPos <opções>
#
#     As <opções> válidas são:
#        * -t <val>  : truncamento [default: 62]
#        * -l <val>  : numero de niveis [default: 28]
#        * -p <val>  : prefixo dos arquivos do BAM (condição inicial e previsões) [default: CPT]
#        * -np <val> : numero de processadores [default: 72]
#        * -N <val>  : numero de nós [default: 24]
#        * -d <val>  : numero de Treads por processos MPI [default: 1]
#        * -I <val>  : Data da condição inicial (cold start)
#        * -F <val>  : Data da previsão final
#        * -ri       : Interpola o campo de saída para um grade regular [default: .FALSE.]
#        * -r <val>  : Define a resolução do campo de saida em graus
#        * -ft <val> : Define a tabela utilizada para definir quais campos devem 
#                      ser posprocessados [default: 'p']
#        * -ps <val) : Define o servidor PBS utilizado [default: eslogin]
#        * -b        : Arquivo de saida binário [default: .FALSE.]
#
#  example:
#
#     ./runPos -t 62 -l 28 -I 2013010100 -F 2013010118
#
# !REVISION HISTORY:
#    11-12-2016 - de Mattos, J.G.Z - Initial code
#
#
# !REMARKS:
#    As tabelas disponíveis para definir quais campos devem sair (opção <-ft>) são:
#    [as tabelas estão em pos/datain]
#
#       *  'p' utiliza a tabela rfd.pnt
#       *  's' utiliza a tabela rfd.sfc
#       *  'c' utiliza a tabela rfd.clm
#       *  'e' utiliza a tabela rfd.eta
#       *  'g' utiliza a tabela rfd.ens
#       *  ' ' utiliza a tabela rfd
#
#   O pós processamento pode ser executado em paralelo ou serial, isso é definido por
#   meio a opção <-ps> que define o servidor PBS utilizado, esta opção possui dois 
#   valores possíveis:
#
#       * eslogin : roda em paralelo nos nós principais do tupa
#       * aux     : roda sequencial nos nós auxiliares do tupa
#
#
# !BUGS:
#
#
#
#EOP
#-------------------------------------------------------------------#
#BOC

subwrd ( ) {
   str=$(echo "${@}" | awk '{ for (i=1; i<=NF-1; i++) printf("%s ",$i)}')
   n=$(echo "${@}" | awk '{ print $NF }')
   echo "${str}" | awk -v var=${n} '{print $var}'
}


#
# Verificando o numero de argumentos
# caso nao existam argumentos, exibe help
if [ $# -eq 0 ];then
   cat < ${0} | sed -n '/^#BOP/,/^#EOP/p'
   exit 0
fi

#
# Pegando as opções que foram passadas pela linha de comando
#
i=1
flag=0
while [ 1 ]; do

   arg=$(echo "${@}" | awk -v var=${i} '{print $var}')
   i=$((i+1))

   if [ -z ${arg} ];then
      break;
   fi

   while [ 1 ];do

      if [ ${arg} = '-t' ]; then TRC=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-l' ]; then LV=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-p' ]; then PREFIX=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-I' ]; then LABELI=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-F' ]; then LABELF=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-i' ]; then INITLZ=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-np' ]; then MPITasks=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-N' ]; then TasksPerNode=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-d' ]; then ThreadsPerMPITask=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-r' ]; then resolution=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-ft' ]; then ReqTable=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-ps' ]; then PBSServer=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-ri' ]; then RegInterp='.TRUE.'; i=$((i+0)); break; fi
      if [ ${arg} = '-b' ]; then BinaryFile='.TRUE.'; i=$((i+0)); break; fi


      if [ ${arg} = '-h' ]; then cat < ${0} | sed -n '/^#BOP/,/^#EOP/p' ; i=$((i+0)); exit 0; fi

      flag=1
      i=$((i-1))

      break;
   done
   if [ ${flag} -eq 1 ]; then break; fi
done

#
# Verificando argumentos, se não foram passados aplica valor padrão
#
# truncamento
if [ -z ${TRC} ];then
   TRC=62
fi

# numero de niveis verticais
if [ -z ${LV} ];then
   LV=28
fi

# prefixo dos arquivos
if [ -z ${PREFIX} ];then
   PREFIX=CPT
fi

# tipo de inicialização
if [ -z ${INITLZ} ];then
   INITLZ=2
fi

# Data da Condição Inicial
if [ -z ${LABELI} ];then
   echo -e "\033[31;1m LABELI not set \033[m"
   exit 1
fi

# Data final das previsões
if [ -z ${LABELF} ];then
   echo -e "\033[31;1m LABELF not set \033[m"
   exit 1
fi

# Arquivo de saida binário
if [ -z ${BinaryFile} ];then
   BinaryFile='.FALSE.'
fi

# Interpola Arquivo de saida para grade regular
if [ -z ${RegInterp} ];then
   RegInterp='.FALSE.'
fi

# Tabela usada para escolher o quais campos pos-processar
if [ -z ${ReqTable} ];then
   ReqTable='p'
fi

# Numero de processadores que serao utilizados no Job
if [ -z ${MPITasks} ];then
   MPITasks=72
fi

# Numero de processadores utilizados por tarefas MPI
if [ -z ${TasksPerNode} ];then
   TasksPerNode=24
fi

# Number of cores hosting OpenMP threads
if [ -z ${ThreadsPerMPITask} ]; then
   ThreadsPerMPITask=1
fi


val=$(echo ${RegInterp} | tr '[:upper:]' '[:lower:]')
if [ ${val} = '.true.' ];then
   if [ ${resolution} -lt 0 ];then
      resolution=-${resolution}
   fi
fi

# Qual máquina rodar: aux ou eslogin
if [ -z ${PBSServer} ]; then
   PBSServer='eslogin'
fi


#
# SETTING THE APPROPRIATED ENVIRONMENT
#

LOCALDIR=$(dirname $(readlink -e ${0})) # Local (path) onde está este script
source ${LOCALDIR}/EnvironmentalVariables

# Resolução/Truncamento

MRES=$(printf "TQ%04dL%03d" ${TRC} ${LV})
TRUN=$(printf "TQ%04d" ${TRC})
NLEV=$(printf "L%03d" ${LV})


# PBS
walltime=00:30:00
queue=pesq
queue_name="POS${TRC}"

# Nomes dos arquivos utilizados pelo pós
POSEXE=PostGrib
POSSCP=qsub_pos.qsb
POSNML=POSTIN-GRIB
POSLOG=Print.post.${LABELI}.${LABELF}.${tmstp}.MPI${MPITasks}.out

# Diretorios das simulações
POSRUN=${SUBTBASE}/pos/exec_${PREFIX}${LABELI}
DATAIN=${SUBTBASE}/model/dataout/${MRES}/${LABELI}
DATAOUT=${WORKBASE}/pos/dataout/${MRES}/${LABELI}
DATALIB=${SUBTBASE}/pos/datain

#
# CREATE DIRETORY TO RUN BAM MODEL
#

if [ -e ${POSRUN} ];then
   rm -fr ${POSRUN}
else
   mkdir -p ${POSRUN}
fi

if [ ! -e ${POSRUN}/setout ];then
   mkdir -p ${POSRUN}/setout
fi

#
# CREATE DIRETORY TO OUTPUT MODEL
#

# Forecasts Files
if [ ! -e ${DATAOUT} ];then
   mkdir -p ${DATAOUT}
fi

#
# COPY PostGrib EXECUTABLE FILE
#

if [ ! -e ${POSRUN}/${POSEXE} ]; then
   cp -pfr ${HOMEBASE}/pos/exec/${POSEXE} ${POSRUN} 
fi

#
# CREATE/MODIFY POSTIN-GRIB AND COPY TO POSRUN DIR
#

sed  -e "s;#TRUNC#;${TRUN};g" \
     -e "s;#LEV#;${NLEV};g" \
     -e "s;#LABELI#;${LABELI};g" \
     -e "s;#LABELF#;${LABELF};g" \
     -e "s;#PREFIX#;${PREFIX};g" \
     -e "s;#DATAIN#;${DATAIN};g" \
     -e "s;#DATAOUT#;${DATAOUT};g" \
     -e "s;#DATALIB#;${DATALIB};g" \
     -e "s;#Binary#;${BinaryFile};g" \
     -e "s;#REQTB#;${ReqTable};g" \
     -e "s;#REGINT#;${RegInterp};g" \
     -e "s;#RES#;${Resolution};g" \
     ${LOCALDIR}/${POSNML}.template > ${POSRUN}/${POSNML}


cat << EOF >${POSRUN}/${POSSCP}
#!/bin/bash
#PBS -o ${HSTMAQ}:${POSRUN}/setout/Out.pos.${PREFIX}.${LABELI}.${tmstp}.MPI${MPITasks}.out
#PBS -j oe
#PBS -l walltime=${walltime}
#PBS -l mppwidth=${MPITasks}
#PBS -l mppnppn=${TasksPerNode}
#PBS -l mppdepth=${ThreadsPerMPITask}
#PBS -V
#PBS -S /bin/bash
#PBS -N ${queue_name}
#PBS -q ${queue}
#PBS -A ${QUOTA}


cd ${POSRUN}

ulimit -s unlimited
ulimit -c unlimited

export PBS_SERVER=${PBSServar}
export KMP_STACKSIZE=128m

mq=$(uname -s | tr '[:upper:]' '[:lower:]')
if [ \${mq} = "linux" ]; then
   export F_UFMTENDIAN=10,11
fi

server=$(echo ${PBSServer} | tr '[:upper:]' '[:lower:]')
if [ \${server} = "aux" ]; then
   /usr/bin/time -v ./$(basename ${POSEXE}) < ${POSNML} > setout/${POSLOG} 2>&1
else
   /usr/bin/time -v aprun -m500h -n ${MPITasks} -N ${TasksPerNode} -d ${ThreadsPerMPITask} \
   ./$(basename ${POSEXE}) < ${POSNML} > setout/${POSLOG} 2>&1
fi

touch monitor.pos

EOF

# Executando o pos-processamento do modelo
cd ${POSRUN}
qsub ${POSSCP}

until [ -e ${POSRUN}/monitor.pos ]; do sleep 1s; done
rm -fr ${POSRUN}/monitor.pos

for arqctl in $(find ${DATAOUT} -name "*.ctl")
do

/opt/grads/2.0.a9/bin/gribmap -i ${arqctl} >&- 2>&-  &

done

exit 0
