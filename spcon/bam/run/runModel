#!/bin/bash
#-------------------------------------------------------------------#
#
#-------------------------------------------------------------------#
#BOP
# !DESCRIPTION: script utilizado para rodar o modelo global do CPTEC
#
# !CALLING SEQUENCE:
#      
#      ./runModel <opções>
#
#         As <opções> válidas são:
#            * -t <val> : truncamento [default: 62]
#            * -l <val> : numero de niveis [default: 28]
#            * -p <val> : prefixo dos arquivos do BAM (condição inicial e previsões) [default: NMC]
#            * -np <val>: numero de processadores [default: 72]
#            * -N <val> : numero de nós [default: 24]
#            * -d <val> : numero de Treads por processos MPI [default: 1]
#            * -I <val> : Data da condição inicial (cold start)
#            * -F <val> : Data da previsão final 
#            * -W <val> : Data da condição inicial (Warm start)
#            * -i <val> : Tipo de Inicialização [default: 2]
#            * -s <val> : Arquivo de SST [default: sstwkl]
#            * -ts <val>: TimeStep da previsão [default: 6]
#            * -r <val> : Generate Restart Files [default: .FALSE.]
#            * -tr <val>: TimeStep do Restart  [default: 6]
#
#  example:
#
#     ./runModel -t 62 -l 28 -I 2013010100 -F 2013010118
#
# !REVISION HISTORY:
#    22-11-2016 - de Mattos, J.G.Z - Initial code
#
#
# !REMARKS:
#    Os tipos de inicialização disponível por meio da opção <-i> são:
#
#       *  2 diabatic normal mode initialization (Cold Start)  
#       *  1 diabatic with no normal mode initialization (Cold Start)  
#       *  0 adiabatic with no normal mode initialization (Warm Start)  
#       * -1 diabatic with no normal mode initialization (Cold Start)  
#            with Surface variables read in instead of initialized  
#       * -2 diabatic normal mode initialization  
#            (Atmos.,Conv.,Rad,Cloud -> Cold Start) (Surface -> Warm Start)  
#            with Surface variables read in instead of initialized  
#       * -3 diabatic normal mode initialization  
#            (Atmos. -> Cold Start) (Conv.,Rad,Cloud,Surface -> Warm Start)  
#
#    Os arquivos para SST, passados por meio da opção <-s> são:
#      
#       * sstaoi - Optimum Interpolation SST  Climatology 
#       * sstanp - Optimum Interpolation SST Climatology 
#                  plus presisted SST anomaly
#       * sstwkl - Weekly run mean of SST for the week 
#                  finished at initial day minus one
#       * sstwkd - weekly run mean of SST direct access file
#       * sstmtd - monthly run mean of SST direct access file
#       * sstdyd - daily run mean of SST direct access file
#
# !BUGS:
#
#
#
#EOP
#-------------------------------------------------------------------#
#BOC

LOCALDIR=$(dirname $(readlink -e ${0})) # Local (path) onde está este script
source ${LOCALDIR}/EnvironmentalVariables

subwrd ( ) {
   str=$(echo "${@}" | awk '{ for (i=1; i<=NF-1; i++) printf("%s ",$i)}')
   n=$(echo "${@}" | awk '{ print $NF }')
   echo "${str}" | awk -v var=${n} '{print $var}'
}


#
# Verificando o numero de argumentos
# caso nao existam argumentos, exibe help
if [ $# -eq 0 ];then
   cat < ${0} | sed -n '/^#BOP/,/^#EOP/p'
   exit 0
fi

#
# Pegando as opções que foram passadas pela linha de comando
#
i=1
flag=0
while [ 1 ]; do

   arg=$(echo "${@}" | awk -v var=${i} '{print $var}')
   i=$((i+1))

   if [ -z ${arg} ];then
      break;
   fi

   while [ 1 ];do

      if [ ${arg} = '-t' ]; then TRC=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-l' ]; then LV=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-p' ]; then PREFIX=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-I' ]; then LABELI=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-W' ]; then LABELW=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-F' ]; then LABELF=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-i' ]; then INITLZ=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-s' ]; then NMSST=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-ts' ]; then DHFCT=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-tr' ]; then DHRES=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-r' ]; then GENRES='.TRUE.'; i=$((i+0)); break; fi
      if [ ${arg} = '-np' ]; then MPITasks=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-N' ]; then TasksPerNode=$(subwrd ${@} ${i}); i=$((i+1)); break; fi
      if [ ${arg} = '-d' ]; then ThreadsPerMPITask=$(subwrd ${@} ${i}); i=$((i+1)); break; fi

      if [ ${arg} = '-h' ]; then cat < ${0} | sed -n '/^#BOP/,/^#EOP/p' ; i=$((i+0)); exit 0; fi

      flag=1
      i=$((i-1))

      break;
   done
   if [ ${flag} -eq 1 ]; then break; fi
done

# truncamento
if [ -z ${TRC} ];then
   TRC=62
fi

# numero de niveis verticais
if [ -z ${LV} ];then
   LV=28
fi

# prefixo dos arquivos
if [ -z ${PREFIX} ];then
   PREFIX=CPT
fi

# tipo de inicialização
if [ -z ${INITLZ} ];then
   echo "entrou"
   INITLZ=2
fi

# Data da Condição Inicial (cold start)
if [ -z ${LABELI} ];then
   if [ ! -z ${LABELW} ];then
      LABELI=${LABELW}
      echo -e "\033[32;1m LABELI not set \033[m"
      echo -e "\033[32;1m using LABELI=LABELW \033[m"
   else
      echo -e "\033[31;1m LABELI or LABELW not set \033[m"
      exit 1
   fi
fi

# Data final das previsões
if [ -z ${LABELF} ];then
   echo -e "\033[31;1m LABELF not set \033[m"
   exit 1
fi

# Data da Condição Inicial (warm start)
# Caso não for definida:
# Se for cold start (INITLZ=2)
#     LABELW=LABELF
# Se for warm start (INITLZ=0)
#     LABELW=LABELI
if [ -z ${LABELW} ];then
   if [ ${INITLZ} -eq 2 ];then
      LABELW=${LABELF}
   else
      LABELW=${LABELI}
   fi
fi

# Arquivo de SST
if [ -z ${NMSST} ];then
   NMSST='sstwkl'
fi

# TimeStep da Previsão
if [ -z ${DHFCT} ];then
   DHFCT=6
fi

# Genetate Restart Files
if [ -z ${GENRES} ];then
   GENRES='.FALSE.'
fi

# TimeStep do Restart
if [ -z ${DHRES} ];then
   DHRES=6
fi

# Numero de processadores que serao utilizados no Job
if [ -z ${MPITasks} ];then
   MPITasks=72
fi

# Numero de processadores utilizados por tarefas MPI
if [ -z ${TasksPerNode} ];then
   TasksPerNode=24
fi

# Number of cores hosting OpenMP threads
if [ -z ${ThreadsPerMPITask} ]; then
   ThreadsPerMPITask=1
fi

#
# Definindo TimeStep/Imax/JMax do BAM dependente do Truncamento
#

case ${TRC} in
   21)TimeStep=3600; IMax=64; JMax=32;;
   31)TimeStep=1800; IMax=96; JMax=48;;
   42)TimeStep=1800; IMax=128; JMax=64;;
   62)TimeStep=900; IMax=192; JMax=96;;
   106)TimeStep=900; IMax=320; JMax=160;;
   126)TimeStep=600; IMax=384; JMax=192;;
   133)TimeStep=600; IMax=400; JMax=200;;
   159)TimeStep=600; IMax=480; JMax=240;;
   170)TimeStep=450; IMax=512; JMax=256;;
   213)TimeStep=300; IMax=640; JMax=320;;
   254)TimeStep=255; IMax=768; JMax=384;;
   299)TimeStep=200; IMax=900; JMax=450;;
   319)TimeStep=225; IMax=960; JMax=480;;
   341)TimeStep=200; IMax=1024; JMax=512;;
   382)TimeStep=180; IMax=1152; JMax=576;;
   511)TimeStep=150; IMax=1536; JMax=768;;
   533)TimeStep=150; IMax=1600; JMax=800;;
   666)TimeStep=240; IMax=2000; JMax=1000;;
   863)TimeStep=150; IMax=2592; JMax=1296;;
   1279)TimeStep=20; IMax=3840; JMax=1920;;
   1332)TimeStep=20; IMax=4000; JMax=2000;;
   *)echo -e "\033[32;1m Truncamento desconhecido ${TRC} \033[m"
esac

#
# SETTING RESTART TIME
#

LABELR=$(date -u -d "${LABELI:0:4}-${LABELI:4:2}-${LABELI:6:2} ${LABELI:8:2}:00:00 UTC +6 hour" +"%Y%m%d%H")

#
# SETTING THE APPROPRIATED ENVIRONMENT
#

MRES=$(printf "TQ%04dL%03d" ${TRC} ${LV}) 

# PBS
walltime=00:10:00
queue=pesq
queue_name="BAM${TRC}"

# Diretorios das simulações

BAMRUN=${SUBTBASE}/model/exec_${PREFIX}${LABELI}
# BAMEXE=${SUBTBASE}/model/exec/ParModel_MPI
BAMEXE=${HOMEBASE}/model/source/ParModel_MPI
BAMSCP=${BAMRUN}/qsub_bam.qsb
BAMLOG=${BAMRUN}/setout/Print.model.${LABELI}.${LABELF}.${tmstp}.MPI${MPITasks}.out

PATHIN=${SUBTBASE}/model/datain
PATHOU=${WORKBASE}/model/dataout/${MRES}/${LABELI}
RSTIN=${WORKBASE}/model/dataout/${MRES}/${LABELI}/RST
RSTOU=${WORKBASE}/model/dataout/${MRES}/${LABELR}/RST

# Arquivo para a inicialização por modos normais
# não lineares.
file=${PATHIN}/$(printf "NMI.T%04gL%03g" ${TRC} ${LV})
if [ -e ${file} ]; then
  EIGENINIT='.FALSE.'
else
  EIGENINIT='.TRUE.'
fi

# O arquivo mwaves.TXXXXGYYYYY (ASCII e sequencial) 
# contem a quantidade de ondas por latitude 
# para integracoes com truncamento XXXX e 
# numero de latitudes YYYYY apenas no caso 
# da grade reduzida. Eh desnecessario para a 
# grade regular pois todas as latitudes contem 
# o mesmo numero de ondas
file=${PATHIN}/$(printf "mwaves.T%04gG%05g" ${TRC} ${JMax})
if [ ! -e ${file} ];then
   MGIVEN='.FALSE.'
else
   MGIVEN='.TRUE.'
fi

# O arquivo gaussp.GYYYYY (binario e sequencial)
# contem pontos e pesos gausseanos (arrays CosGaussColat
# e GaussWeights de Utils.f90) para grades com YYYYY
# latitudes (regular ou reduzida).
file=${PATHIN}/$(printf "gaussp.G%05g" ${JMax})
if [ ! -e ${file} ];then
   GAUSSGIVEN='.FALSE.'
else
   GAUSSGIVEN='.TRUE.'
fi 

#
# CREATE DIRETORY TO RUN BAM MODEL
#

if [ -e ${BAMRUN} ];then
   rm -fr ${BAMRUN}
else
   mkdir -p ${BAMRUN}
fi

if [ ! -e ${BAMRUN}/setout ];then
   mkdir -p ${BAMRUN}/setout
fi

#
# CREATE DIRETORY TO OUTPUT MODEL
#

# Forecasts Files
if [ ! -e ${PATHOU} ];then
   mkdir -p ${PATHOU}
fi

# Restarts Files
if [ ! -e ${RSTOU} ];then
   mkdir -p ${RSTOU}
fi

#
# COPY BAM EXECUTABLE FILE
#

cp -pfr ${BAMEXE} ${BAMRUN}/

#
# CREATE/MODIFY MODELIN AND COPY TO BAMRUN DIR
#

sed  -e "s;#TRUNC#;${TRC};g" \
     -e "s;#NLEV#;${LV};g" \
     -e "s;#DELT#;${TimeStep};g" \
     -e "s;#LABELI#;${LABELI:8:2},${LABELI:6:2},${LABELI:4:2},${LABELI:0:4};g" \
     -e "s;#LABELW#;${LABELW:8:2},${LABELW:6:2},${LABELW:4:2},${LABELW:0:4};g" \
     -e "s;#LABELF#;${LABELF:8:2},${LABELF:6:2},${LABELF:4:2},${LABELF:0:4};g" \
     -e "s;#DHFCT#;${DHFCT};g" \
     -e "s;#DHRES#;${DHRES};g" \
     -e "s;#GENRES#;${GENRES};g" \
     -e "s;#PREFIX#;${PREFIX};g" \
     -e "s;#NMSST#;${NMSST};g" \
     -e "s;#PATHIN#;${PATHIN};g" \
     -e "s;#PATHOU#;${PATHOU};g" \
     -e "s;#RSTIN#;${RSTIN};g" \
     -e "s;#RSTOU#;${RSTOU};g" \
     -e "s;#EIGENINIT#;${EIGENINIT};g" \
     -e "s;#MGIVEN#;${MGIVEN};g" \
     -e "s;#GAUSSGIVEN#;${GAUSSGIVEN};g" \
     -e "s;#INITLZ#;${INITLZ};g" \
     ${LOCALDIR}/MODELIN.template > ${BAMRUN}/MODELIN


#
# BUILD SCRIPT TO SUBMIT BAM MODEL TO RUN IN THE TUPA
#

cat << EOF > ${BAMSCP}
#!/bin/bash
#PBS -o ${HSTMAQ}:${BAMRUN}/setout/Out.model.${PREFIX}.${LABELI}.${tmstp}.MPI${MPITasks}.out
#PBS -j oe
#PBS -l walltime=${walltime}
#PBS -l mppwidth=${MPITasks}
#PBS -l mppnppn=${TasksPerNode}
#PBS -l mppdepth=${ThreadsPerMPITask}
#PBS -V
#PBS -S /bin/bash
#PBS -N ${queue_name}
#PBS -q ${queue}
#PBS -A ${QUOTA}

ulimit -s unlimited
ulimit -c unlimited

export HUGETLB_MORECORE=yes
export HUGETLB_ELFMAP=W
export HUGETLB_FORCE_ELFMAP=yes+
export MPICH_ENV_DISPLAY=1
export HUGETLB_DEFAULT_PAGE_SIZE=2m
export OMP_NUM_THREADS=${ThreadsPerMPITask}

cd ${BAMRUN}

/usr/bin/time -v aprun -n ${MPITasks} -N ${TasksPerNode} -d ${ThreadsPerMPITask} \
${BAMRUN}/$(basename ${BAMEXE}) > ${BAMLOG} 2>&1

touch ${BAMRUN}/monitor.bam

EOF

# Executando o modelo
cd ${BAMRUN}
qsub ${BAMSCP}

until [ -e ${BAMRUN}/monitor.bam ]; do sleep 1s; done
rm -fr ${BAMRUN}/monitor.bam

exit 0
