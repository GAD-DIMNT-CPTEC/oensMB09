       !        
       !        Cray Inc. Decompilation
       !        WARNING - This output is provided for information only.
       !        
       !        Cray Inc. reserves the right to change the format of this
       !        information at any time and does not guarantee the
       !        readability or accuracy of this information.
       !        
       !        This information may not be compilable and corresponds to
       !        the internal representation of the program during the
       !        optimization phase of the compilation process.
       !        
       !        Source                :  getgi.f
       !        File                  :  getgi.cg
       !        Format                :  Fortran
       !        Target                :  X86, 64-bit
       !        
    2.       
    2.       subroutine getgi( lugi, mnum, mbuf, cbuf, nlen, nnum, iret )
    2.       $CARG_mnum_I1 = 0[loc( mnum ),0]
    2.       $CARG_mbuf_I2 = 0[loc( mbuf ),0]
   64.       0[loc( nlen ),0] = 0
   65.       0[loc( nnum ),0] = 0
   66.       0[loc( iret ),0] = 3
   67.       $Con_P19 = 0
   67.       $Con_P20 = 162
   67.       call baread( 0[loc( lugi ),0], $Con_P19, $Con_P20, lhead, substr[chead,0:162] )
   68.       if ( lhead == 162 ) then
   68.          if ( substr[chead,41:6] == 'GB1IX1' ) then
   69.             $_StackCntrl_O1 = $_StaticCntrl_O0
   69.             1[loc( $_StackCntrl_O1 ),0].L = loc( substr[chead,81:81] )
   69.             3[loc( $_StackCntrl_O1 ),0].L = loc( ios )
   69.             $_StackDv_P1 = $_StaticDV_P2
   69.             $LCS_IOitem_0 = loc( 0[loc( $_IOitem_P0 ),0] )
   69.             0[loc( $_StackDv_P1 ),0].L = pointer to array[1] of integer( $LCS_IOitem_0 )
   69.             1[loc( $_StackDv_P1 ),0].L = 32
   69.             2[loc( $_StackDv_P1 ),0].L = and( 0xffffffffffffffe0UL, 2[loc( $_StackDv_P1 ),0].L )
   69.             23[loc( $_StackDv_P1 )].B = 1
   69.             4[loc( $_StackDv_P1 ),0].L = int( $LCS_IOitem_0, 8 )
   69.             5[loc( $_StackDv_P1 ),0].L = 32
   69.             21[loc( $_StackDv_P1 )].B = 0
   69.             6[loc( $_StackDv_P1 ),0] = 0
   69.             6[loc( $_StackDv_P1 ),0].L = 1
   69.             7[loc( $_StackDv_P1 ),0].L = 3
   69.             8[loc( $_StackDv_P1 ),0].L = 1
   69.             $_StackIolist_O3 = $_StaticIolist_O2
   69.             2[loc( $_StackIolist_O3 ),0].L = int( loc( $_StackDv_P1 ), 8 )
   69.             2[loc( $_StackDv_P1 ),0].L = or( 65600, and( -4294967265UL, 2[loc( $_StackDv_P1 ),0].L ) )
   69.             t$5 = _frf( pointer to integer (kind=8)( loc( $_StackCntrl_O1 ) ), pointer to integer (kind=8)( loc( (&)0[loc( $_StackIolist_O3 ),0].L ) ), pointer to integer (kind=8)( loc( $_IO_Lib_Stack_O4 ) ) )
   69.             $nskp_S0 = 0[loc( $_IOitem_P0 ),0]
   69.             $MR_nlen_13 = 1[loc( $_IOitem_P0 ),0]
   69.             0[loc( nlen ),0] = $MR_nlen_13
   69.             $MR_nnum_S1 = 2[loc( $_IOitem_P0 ),0]
   69.             $LCS_nnum_1 = loc( nnum )
   69.             0[$LCS_nnum_1,0] = $MR_nnum_S1
   70.             if ( ios == 0 ) then
   72.                $MR_nnum_S2 = $MR_nnum_S1 - $CARG_mnum_I1
   72.                0[$LCS_nnum_1,0] = $MR_nnum_S2
   73.                $LCS_2 = $MR_nlen_13 * $MR_nnum_S2
   73.                nbuf = $LCS_2
   74.                $LCS_iret_3 = loc( iret )
   74.                0[$LCS_iret_3,0] = 0
   71.                $nskp_S3 = $nskp_S0 + $CARG_mnum_I1 * $MR_nlen_13
   71.                nskp = $nskp_S3
   75.                if ( $LCS_2 > $CARG_mbuf_I2 ) then
   76.                   $MR_nnum_S2 = $CARG_mbuf_I2 / $MR_nlen_13
   76.                   0[$LCS_nnum_1,0] = $MR_nnum_S2
   77.                   $nbuf_S4 = $MR_nlen_13 * $MR_nnum_S2
   77.                   nbuf = $nbuf_S4
   78.                   0[$LCS_iret_3,0] = 1
   78.                endif
   80.                if ( $MR_nlen_13 * $MR_nnum_S2 > 0 ) then
   81.                   call baread( 0[loc( lugi ),0], nskp, nbuf, lbuf, substr[cbuf,0:1] )
   82.                   $nbuf_S5 = nbuf
   82.                   if ( lbuf - $nbuf_S5 /= 0 ) then
   82.                      0[loc( iret ),0] = 2
   82.                   endif
   82.                endif
   82.             endif
   82.          endif
   82.       endif
   88.       return
   88.       end
   88.       
