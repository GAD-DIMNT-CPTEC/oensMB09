       !        
       !        Cray Inc. Decompilation
       !        WARNING - This output is provided for information only.
       !        
       !        Cray Inc. reserves the right to change the format of this
       !        information at any time and does not guarantee the
       !        readability or accuracy of this information.
       !        
       !        This information may not be compilable and corresponds to
       !        the internal representation of the program during the
       !        optimization phase of the compilation process.
       !        
       !        Source                :  getgbemh.f
       !        File                  :  getgbemh.opt
       !        Format                :  Fortran
       !        Target                :  X86, 64-bit
       !        
    2.       
    2.       subroutine getgbemh( lugb, lugi, j, jpds, jgds, jens, mbuf, cbuf, nlen, nnum, mnum, kg, kf, k, kpds, kgds, kens, iret )
    2.       t$1 = mbuf
  207.       t$2 = _zla( 0, mbuf )
  211.       if ( j >= 0 ) then
  212.          if ( mnum >= 0 ) then
  213.             irgi = 0
  213.          else
  216.             irgi = 1
  215.             mnum = -1 + -mnum
  215.          endif
  218.          jr = j + -mnum
  219.          if ( j + -mnum < 0 ) then
  217.             goto 10
  219.          else if ( j + -mnum < nnum ) then
  219.             goto 20
  219.          else if ( irgi == 0 ) then
  219.    20       continue
  220.             call getgb1s(  _substr(cbuf(1),1,1), nlen, nnum, jr, jpds(1), jgds(1), jens(1), kr, kpds(1), kgds(1), kens(1), lskip, lgrib, irgs )
  222.             if ( irgs == 0 ) then
  222.                k = mnum + kr
  222.             endif
  223.             if ( irgi == 1 ) then
  223.                if ( irgs == 0 ) then
  223.                   mnum = -1 + -mnum
  223.                endif
  224.                if ( irgs > 0 ) then
  224.                   mnum = mnum + nnum
  224.                endif
  224.             endif
  224.          else
  224.    10       continue
  226.             mnum = j
  227.             irgi = 1
  228.             irgs = 1
  228.          endif
  228.       else
  231.          mnum = -1 + -j
  232.          irgi = 1
  233.          irgs = 1
  233.       endif
  237.       jr = 0
  238.       if ( ( irgi == 1 .and. irgs == 1 ) /= .false. ) then
  234.          do
  239.             if ( lugi > 0 ) then
  240.                call getgi( lugi, mnum, mbuf,  _substr(cbuf(1),1,1), nlen, nnum, irgi )
  240.             else
  242.                call getgir( lugb, 32000, 4000, mnum, mbuf,  _substr(cbuf(1),1,1), nlen, nnum, irgi )
  242.             endif
  244.             if ( irgi <= 1 ) then
  245.                call getgb1s(  _substr(cbuf(1),1,1), nlen, nnum, jr, jpds(1), jgds(1), jens(1), kr, kpds(1), kgds(1), kens(1), lskip, lgrib, irgs )
  247.                if ( irgs == 0 ) then
  247.                   k = mnum + kr
  247.                endif
  248.                if ( irgi == 1 ) then
  248.                   if ( irgs == 0 ) then
  248.                      mnum = -1 + -mnum
  248.                   endif
  249.                   if ( irgs > 0 ) then
  249.                      mnum = mnum + nnum
  249.                   endif
  249.                endif
  249.             endif
  250.             if ( ( irgi == 1 .and. irgs == 1 ) == .false. ) exit
  250.          enddo
  250.       endif
  254.       if ( irgi > 1 ) then
  255.          iret = 96
  256.       else if ( irgs /= 0 ) then
  257.          iret = 99
  257.       else
  259.          kg = lgrib
  260.          kf = lengds( kgds(1) )
  261.          iret = 0
  261.       endif
  265.       return
  265.       end
  265.       
