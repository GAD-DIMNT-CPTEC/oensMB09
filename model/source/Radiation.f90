!
!  $Author: panetta $
!  $Date: 2007/07/20 13:58:43 $
!  $Revision: 1.11 $
!
MODULE Radiation

  ! InitRadiation
  ! InitSpmrad
  ! InitRadtim
  ! InitGetoz
  !
  ! spmrad ------| radtim
  !              !
  !              ! getoz
  !              !
  !              ! cldgen
  !              !
  !              ! cldgn2
  !              !
  !              ! cldgn3
  !              !
  !              ! swrad   ------| setsw ------| clear
  !              !                             |
  !              !                             | cloudy
  !              ! cliradintf
  !              !
  !              ! lwrad   ------| lwflux -----| crunch
  !                              !
  !                              ! cldslw
  !
  ! radtim
  !
  ! rqvirt

  USE Clirad, ONLY:cliradintf

  USE Utils, ONLY: &
       tmstmp2

  USE Constants, ONLY :     &
       ndavl,          &
       delq,           &
       qmin,           &
       hl,             &
       gasr,           &
       rmwmd,          &
       rmwmdi,         &
       e0c,            &
       pai,            &
       cp,             &
       grav,           &
       solcon,         &
       r8, i8

  USE Options, ONLY :     &
       tbase, &
       nferr, &
       nfprt, &
       nfctrl, &
       iswrad, &
       ilwrad, &
       ifozone

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: InitRadiation
  PUBLIC :: InitSpmrad
  PUBLIC :: InitRadtim
  PUBLIC :: InitGetoz
  PUBLIC :: spmrad
  PUBLIC :: radtim
  PUBLIC :: rqvirt
  PUBLIC :: COSZMED

  REAL(KIND=r8) :: b2502 (32)
  REAL(KIND=r8) :: b2501 (32)
  REAL(KIND=r8) :: blkwin(32)
  REAL(KIND=r8) :: blkco2(32)
  INTEGER, PARAMETER :: nlm_getoz=18
  REAL(KIND=r8), ALLOCATABLE :: ozone(:,:,:)
  LOGICAL :: first_getoz
  INTEGER :: mon_getoz
  REAL(KIND=r8)    :: year_getoz
  LOGICAL :: inter_getoz
  REAL(KIND=r8)    :: pai12
  REAL(KIND=r8)    :: pai2i
  REAL(KIND=r8)    :: fim24
  INTEGER :: monday(12)
  REAL(KIND=r8)    :: ozsig(18)    !ozsig(nlm_getoz)

CONTAINS

  SUBROUTINE InitRadiation()

    INTEGER, PARAMETER :: nl=37
    INTEGER, PARAMETER :: ns=4

    b2501(:) = (/ &
         16.280e0_r8, 17.471e0_r8, 18.701e0_r8, 19.974e0_r8, 21.292e0_r8, &
         22.661e0_r8, 24.086e0_r8, 25.575e0_r8, 27.135e0_r8, 28.775e0_r8, &
         30.506e0_r8, 32.339e0_r8, 34.286e0_r8, 36.361e0_r8, 38.578e0_r8, &
         40.954e0_r8, 43.505e0_r8, 46.248e0_r8, 49.203e0_r8, 52.388e0_r8, &
         55.824e0_r8, 59.532e0_r8, 63.533e0_r8, 67.849e0_r8, 72.502e0_r8, &
         77.516e0_r8, 82.913e0_r8, 88.717e0_r8, 94.952e0_r8, 101.64e0_r8, &
         108.806e0_r8,116.472e0_r8 /)
    b2502(:) = (/ &
         16.379e0_r8, 18.744e0_r8, 21.345e0_r8, 24.195e0_r8,  27.311e0_r8, &
         30.708e0_r8, 34.405e0_r8, 38.417e0_r8, 42.763e0_r8,  47.461e0_r8, &
         52.529e0_r8, 57.985e0_r8, 63.850e0_r8, 70.141e0_r8,  76.880e0_r8, &
         84.088e0_r8, 91.784e0_r8,  99.99e0_r8,108.726e0_r8, 118.016e0_r8, &
         127.881e0_r8,138.344e0_r8,149.429e0_r8,161.160e0_r8, 173.561e0_r8, &
         186.659e0_r8,200.478e0_r8,215.046e0_r8,230.390e0_r8, 246.539e0_r8, &
         263.523e0_r8,281.368e0_r8 /)
    blkwin(:) = (/ &
         0.593e0_r8, 0.774e0_r8, 0.993e0_r8, 1.258e0_r8, 1.573e0_r8, &
         1.944e0_r8, 2.377e0_r8, 2.877e0_r8, 3.450e0_r8, 4.102e0_r8, &
         4.838e0_r8, 5.664e0_r8, 6.585e0_r8, 7.606e0_r8, 8.733e0_r8, &
         9.969e0_r8,11.320e0_r8,12.788e0_r8,14.380e0_r8,16.097e0_r8, &
         17.944e0_r8,19.923e0_r8,22.038e0_r8,24.292e0_r8,26.685e0_r8, &
         29.221e0_r8,31.902e0_r8,34.729e0_r8,37.703e0_r8,40.825e0_r8, &
         44.097e0_r8,47.520e0_r8   /)
    blkco2(:) = (/ &
         8.789e0_r8, 10.385e0_r8, 12.159e0_r8, 14.117e0_r8, 16.264e0_r8, &
         18.606e0_r8, 21.145e0_r8, 23.884e0_r8, 26.826e0_r8, 29.973e0_r8, &
         33.325e0_r8, 36.883e0_r8, 40.647e0_r8, 44.617e0_r8, 48.792e0_r8, &
         53.170e0_r8, 57.750e0_r8, 62.530e0_r8, 67.509e0_r8, 72.683e0_r8, &
         78.050e0_r8, 83.609e0_r8, 89.354e0_r8, 95.285e0_r8,101.397e0_r8, &
         107.688e0_r8,114.155e0_r8,120.794e0_r8,127.601e0_r8,134.574e0_r8, &
         141.710e0_r8,149.004e0_r8 /)

    ALLOCATE(ozone(nlm_getoz,nl,ns))

    !
    !     four season climatological ozone data in nmc sigma layers
    !
    !     for seasonal variation
    !     season=1 - winter          season=2 - spring
    !     season=3 - summer          season=4 - fall
    !     unit of ozone mixing ratio is in ( 10**-4 g/g ).  the data is
    !     in 18 sigma layers from top to bottom.  for every layer, there
    !     are 37 latitudes at 5 degree interval from north pole to south
    !     pole.
    !     mrf86 18 layers
    !
    !
    !     1. winter
    !
    !     wint1(18,6)
    !
    ozone(1:18, 1:6, 1) = RESHAPE( (/ &
         .068467e0_r8,.052815e0_r8,.035175e0_r8,.022334e0_r8,.013676e0_r8,.007363e0_r8, &
         .003633e0_r8,.001582e0_r8,.001111e0_r8,.000713e0_r8,.000517e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .069523e0_r8,.052249e0_r8,.034255e0_r8,.021379e0_r8,.012306e0_r8,.006727e0_r8, &
         .003415e0_r8,.001578e0_r8,.001072e0_r8,.000681e0_r8,.000517e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .070579e0_r8,.051684e0_r8,.033335e0_r8,.020423e0_r8,.010935e0_r8,.006091e0_r8, &
         .003197e0_r8,.001573e0_r8,.001034e0_r8,.000650e0_r8,.000517e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .074885e0_r8,.049987e0_r8,.030140e0_r8,.017894e0_r8,.009881e0_r8,.005543e0_r8, &
         .002907e0_r8,.001379e0_r8,.000961e0_r8,.000644e0_r8,.000512e0_r8,.000463e0_r8, &
         .000451e0_r8,.000408e0_r8,.000385e0_r8,.000361e0_r8,.000351e0_r8,.000349e0_r8, &
         .079190e0_r8,.048290e0_r8,.026945e0_r8,.015366e0_r8,.008826e0_r8,.004995e0_r8, &
         .002616e0_r8,.001184e0_r8,.000887e0_r8,.000637e0_r8,.000508e0_r8,.000486e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .082443e0_r8,.047591e0_r8,.025358e0_r8,.014294e0_r8,.008233e0_r8,.004664e0_r8, &
         .002430e0_r8,.001068e0_r8,.000851e0_r8,.000644e0_r8,.000508e0_r8,.000474e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8/), &
         (/18,6/))
    !
    !     wint2(18,6)
    !
    ozone(1:18, 7:12, 1) = RESHAPE( (/ &
         .085695e0_r8,.046892e0_r8,.023772e0_r8,.013223e0_r8,.007640e0_r8,.004333e0_r8, &
         .002244e0_r8,.000951e0_r8,.000815e0_r8,.000650e0_r8,.000508e0_r8,.000463e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .089618e0_r8,.042869e0_r8,.019963e0_r8,.010502e0_r8,.005966e0_r8,.003525e0_r8, &
         .001936e0_r8,.000906e0_r8,.000769e0_r8,.000625e0_r8,.000508e0_r8,.000452e0_r8, &
         .000451e0_r8,.000408e0_r8,.000385e0_r8,.000361e0_r8,.000351e0_r8,.000349e0_r8, &
         .093540e0_r8,.038846e0_r8,.016155e0_r8,.007781e0_r8,.004292e0_r8,.002716e0_r8, &
         .001628e0_r8,.000862e0_r8,.000724e0_r8,.000600e0_r8,.000508e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .097097e0_r8,.034916e0_r8,.012983e0_r8,.006240e0_r8,.003666e0_r8,.002259e0_r8, &
         .001336e0_r8,.000730e0_r8,.000629e0_r8,.000549e0_r8,.000499e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .100654e0_r8,.030986e0_r8,.009812e0_r8,.004698e0_r8,.003041e0_r8,.001803e0_r8, &
         .001044e0_r8,.000599e0_r8,.000533e0_r8,.000499e0_r8,.000491e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .101724e0_r8,.026500e0_r8,.007228e0_r8,.003391e0_r8,.002058e0_r8,.001285e0_r8, &
         .000811e0_r8,.000531e0_r8,.000478e0_r8,.000449e0_r8,.000440e0_r8,.000421e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8/), &
         (/18,6/))
    !
    !     wint3(18,6)
    !
    ozone(1:18, 13:18, 1) = RESHAPE( (/ &
         .102794e0_r8,.022015e0_r8,.004645e0_r8,.002084e0_r8,.001076e0_r8,.000767e0_r8, &
         .000577e0_r8,.000463e0_r8,.000423e0_r8,.000399e0_r8,.000389e0_r8,.000401e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .103456e0_r8,.018235e0_r8,.003195e0_r8,.001379e0_r8,.000771e0_r8,.000585e0_r8, &
         .000474e0_r8,.000411e0_r8,.000380e0_r8,.000362e0_r8,.000343e0_r8,.000348e0_r8, &
         .000346e0_r8,.000328e0_r8,.000317e0_r8,.000305e0_r8,.000302e0_r8,.000302e0_r8, &
         .104118e0_r8,.014455e0_r8,.001745e0_r8,.000674e0_r8,.000467e0_r8,.000403e0_r8, &
         .000370e0_r8,.000359e0_r8,.000337e0_r8,.000325e0_r8,.000296e0_r8,.000294e0_r8, &
         .000293e0_r8,.000302e0_r8,.000306e0_r8,.000302e0_r8,.000302e0_r8,.000302e0_r8, &
         .104106e0_r8,.012997e0_r8,.001479e0_r8,.000639e0_r8,.000468e0_r8,.000422e0_r8, &
         .000392e0_r8,.000372e0_r8,.000342e0_r8,.000325e0_r8,.000296e0_r8,.000294e0_r8, &
         .000293e0_r8,.000302e0_r8,.000306e0_r8,.000302e0_r8,.000302e0_r8,.000302e0_r8, &
         .104093e0_r8,.011539e0_r8,.001213e0_r8,.000604e0_r8,.000468e0_r8,.000442e0_r8, &
         .000414e0_r8,.000385e0_r8,.000347e0_r8,.000325e0_r8,.000296e0_r8,.000294e0_r8, &
         .000293e0_r8,.000302e0_r8,.000306e0_r8,.000302e0_r8,.000302e0_r8,.000302e0_r8, &
         .104087e0_r8,.010726e0_r8,.000971e0_r8,.000538e0_r8,.000440e0_r8,.000434e0_r8, &
         .000418e0_r8,.000397e0_r8,.000375e0_r8,.000343e0_r8,.000296e0_r8,.000294e0_r8, &
         .000293e0_r8,.000302e0_r8,.000306e0_r8,.000302e0_r8,.000302e0_r8,.000302e0_r8/), &
         (/18,6/))
    !
    !     wint4(18,6)
    !
    ozone(1:18, 19:24, 1) = RESHAPE( (/ &
         .102665e0_r8,.010977e0_r8,.001237e0_r8,.000590e0_r8,.000498e0_r8,.000479e0_r8, &
         .000458e0_r8,.000436e0_r8,.000421e0_r8,.000387e0_r8,.000326e0_r8,.000298e0_r8, &
         .000246e0_r8,.000227e0_r8,.000211e0_r8,.000200e0_r8,.000194e0_r8,.000186e0_r8, &
         .100892e0_r8,.012873e0_r8,.001886e0_r8,.000785e0_r8,.000643e0_r8,.000568e0_r8, &
         .000519e0_r8,.000487e0_r8,.000471e0_r8,.000437e0_r8,.000368e0_r8,.000305e0_r8, &
         .000201e0_r8,.000151e0_r8,.000117e0_r8,.000098e0_r8,.000090e0_r8,.000093e0_r8, &
         .100534e0_r8,.013704e0_r8,.002028e0_r8,.000861e0_r8,.000701e0_r8,.000604e0_r8, &
         .000546e0_r8,.000513e0_r8,.000504e0_r8,.000462e0_r8,.000381e0_r8,.000307e0_r8, &
         .000201e0_r8,.000151e0_r8,.000117e0_r8,.000098e0_r8,.000090e0_r8,.000093e0_r8, &
         .100218e0_r8,.015035e0_r8,.002537e0_r8,.001037e0_r8,.000790e0_r8,.000726e0_r8, &
         .000673e0_r8,.000628e0_r8,.000579e0_r8,.000512e0_r8,.000440e0_r8,.000374e0_r8, &
         .000307e0_r8,.000253e0_r8,.000227e0_r8,.000208e0_r8,.000194e0_r8,.000186e0_r8, &
         .099903e0_r8,.016365e0_r8,.003045e0_r8,.001214e0_r8,.000879e0_r8,.000848e0_r8, &
         .000801e0_r8,.000744e0_r8,.000654e0_r8,.000562e0_r8,.000499e0_r8,.000441e0_r8, &
         .000410e0_r8,.000358e0_r8,.000342e0_r8,.000322e0_r8,.000302e0_r8,.000302e0_r8, &
         .099547e0_r8,.017725e0_r8,.003693e0_r8,.001578e0_r8,.001125e0_r8,.000985e0_r8, &
         .000879e0_r8,.000795e0_r8,.000712e0_r8,.000643e0_r8,.000584e0_r8,.000521e0_r8, &
         .000482e0_r8,.000384e0_r8,.000351e0_r8,.000322e0_r8,.000302e0_r8,.000302e0_r8/), &
         (/18,6/))
    !
    !     wint5(18,6)
    !
    ozone(1:18, 25:30, 1) = RESHAPE( (/ &
         .099191e0_r8,.019085e0_r8,.004340e0_r8,.001943e0_r8,.001371e0_r8,.001122e0_r8, &
         .000957e0_r8,.000847e0_r8,.000770e0_r8,.000724e0_r8,.000669e0_r8,.000601e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .098107e0_r8,.020617e0_r8,.004758e0_r8,.002137e0_r8,.001516e0_r8,.001211e0_r8, &
         .000999e0_r8,.000848e0_r8,.000778e0_r8,.000730e0_r8,.000677e0_r8,.000603e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .097023e0_r8,.022148e0_r8,.005177e0_r8,.002332e0_r8,.001660e0_r8,.001300e0_r8, &
         .001041e0_r8,.000849e0_r8,.000786e0_r8,.000737e0_r8,.000686e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .093464e0_r8,.026177e0_r8,.008525e0_r8,.003892e0_r8,.002452e0_r8,.001609e0_r8, &
         .001116e0_r8,.000851e0_r8,.000809e0_r8,.000762e0_r8,.000690e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .089906e0_r8,.030206e0_r8,.011873e0_r8,.005453e0_r8,.003244e0_r8,.001918e0_r8, &
         .001192e0_r8,.000852e0_r8,.000832e0_r8,.000787e0_r8,.000694e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .080939e0_r8,.032414e0_r8,.014163e0_r8,.007241e0_r8,.004328e0_r8,.002522e0_r8, &
         .001481e0_r8,.000934e0_r8,.000861e0_r8,.000787e0_r8,.000694e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8/), &
         (/18,6/))
    !
    !     wint6(18,6)
    !
    ozone(1:18, 31:36, 1) = RESHAPE( (/ &
         .071972e0_r8,.034622e0_r8,.016453e0_r8,.009029e0_r8,.005413e0_r8,.003127e0_r8, &
         .001770e0_r8,.001015e0_r8,.000890e0_r8,.000787e0_r8,.000694e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .069820e0_r8,.035028e0_r8,.016929e0_r8,.009389e0_r8,.005645e0_r8,.003260e0_r8, &
         .001843e0_r8,.001055e0_r8,.000905e0_r8,.000787e0_r8,.000694e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .067669e0_r8,.035434e0_r8,.017406e0_r8,.009749e0_r8,.005876e0_r8,.003393e0_r8, &
         .001916e0_r8,.001094e0_r8,.000920e0_r8,.000787e0_r8,.000694e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .065518e0_r8,.035975e0_r8,.017854e0_r8,.010100e0_r8,.006534e0_r8,.003985e0_r8, &
         .002321e0_r8,.001240e0_r8,.000966e0_r8,.000774e0_r8,.000640e0_r8,.000548e0_r8, &
         .000479e0_r8,.000384e0_r8,.000346e0_r8,.000316e0_r8,.000302e0_r8,.000302e0_r8, &
         .063367e0_r8,.036516e0_r8,.018302e0_r8,.010452e0_r8,.007192e0_r8,.004577e0_r8, &
         .002727e0_r8,.001387e0_r8,.001012e0_r8,.000762e0_r8,.000585e0_r8,.000490e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .061216e0_r8,.037359e0_r8,.019151e0_r8,.010633e0_r8,.006845e0_r8,.004382e0_r8, &
         .002691e0_r8,.001511e0_r8,.001061e0_r8,.000749e0_r8,.000568e0_r8,.000465e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8/), &
         (/18,6/))
    !
    !     wint7(18)
    !
    ozone(1:18, 37, 1) = (/ &
         .059066e0_r8,.038201e0_r8,.019999e0_r8,.010813e0_r8,.006498e0_r8,.004188e0_r8, &
         .002656e0_r8,.001636e0_r8,.001110e0_r8,.000737e0_r8,.000551e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8/)
    !
    !     2. spring
    !
    ozone(1:18, 1:6, 2) = RESHAPE( (/ &
         .074229e0_r8,.050084e0_r8,.030930e0_r8,.018676e0_r8,.011965e0_r8,.008165e0_r8, &
         .005428e0_r8,.003399e0_r8,.002098e0_r8,.001138e0_r8,.000780e0_r8,.000632e0_r8, &
         .000603e0_r8,.000559e0_r8,.000538e0_r8,.000574e0_r8,.000614e0_r8,.000515e0_r8, &
         .074927e0_r8,.049459e0_r8,.029215e0_r8,.018025e0_r8,.011754e0_r8,.007786e0_r8, &
         .004972e0_r8,.002926e0_r8,.001817e0_r8,.001025e0_r8,.000758e0_r8,.000632e0_r8, &
         .000603e0_r8,.000559e0_r8,.000538e0_r8,.000574e0_r8,.000614e0_r8,.000515e0_r8, &
         .075625e0_r8,.048835e0_r8,.027500e0_r8,.017375e0_r8,.011544e0_r8,.007407e0_r8, &
         .004516e0_r8,.002453e0_r8,.001536e0_r8,.000912e0_r8,.000737e0_r8,.000632e0_r8, &
         .000603e0_r8,.000559e0_r8,.000538e0_r8,.000574e0_r8,.000614e0_r8,.000515e0_r8, &
         .077409e0_r8,.048159e0_r8,.026661e0_r8,.016596e0_r8,.010962e0_r8,.006972e0_r8, &
         .004160e0_r8,.002132e0_r8,.001391e0_r8,.000868e0_r8,.000686e0_r8,.000601e0_r8, &
         .000603e0_r8,.000559e0_r8,.000538e0_r8,.000574e0_r8,.000614e0_r8,.000515e0_r8, &
         .079194e0_r8,.047483e0_r8,.025822e0_r8,.015818e0_r8,.010380e0_r8,.006537e0_r8, &
         .003804e0_r8,.001811e0_r8,.001245e0_r8,.000825e0_r8,.000635e0_r8,.000570e0_r8, &
         .000603e0_r8,.000559e0_r8,.000538e0_r8,.000574e0_r8,.000614e0_r8,.000515e0_r8, &
         .084591e0_r8,.046553e0_r8,.025037e0_r8,.015156e0_r8,.009841e0_r8,.006124e0_r8, &
         .003534e0_r8,.001693e0_r8,.001170e0_r8,.000793e0_r8,.000631e0_r8,.000537e0_r8, &
         .000551e0_r8,.000509e0_r8,.000486e0_r8,.000516e0_r8,.000548e0_r8,.000446e0_r8/), &
         (/18,6/))
    ozone(1:18, 7:12, 2) = RESHAPE( (/ &
         .089988e0_r8,.045622e0_r8,.024253e0_r8,.014495e0_r8,.009303e0_r8,.005711e0_r8, &
         .003264e0_r8,.001574e0_r8,.001096e0_r8,.000762e0_r8,.000627e0_r8,.000503e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000460e0_r8,.000486e0_r8,.000398e0_r8, &
         .092863e0_r8,.042419e0_r8,.020704e0_r8,.012034e0_r8,.007417e0_r8,.004504e0_r8, &
         .002590e0_r8,.001334e0_r8,.000977e0_r8,.000731e0_r8,.000622e0_r8,.000503e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000460e0_r8,.000486e0_r8,.000398e0_r8, &
         .095737e0_r8,.039215e0_r8,.017155e0_r8,.009572e0_r8,.005532e0_r8,.003296e0_r8, &
         .001916e0_r8,.001094e0_r8,.000858e0_r8,.000699e0_r8,.000618e0_r8,.000503e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000460e0_r8,.000486e0_r8,.000398e0_r8, &
         .097501e0_r8,.035382e0_r8,.014856e0_r8,.008207e0_r8,.004619e0_r8,.002720e0_r8, &
         .001610e0_r8,.001012e0_r8,.000829e0_r8,.000687e0_r8,.000610e0_r8,.000503e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000460e0_r8,.000486e0_r8,.000398e0_r8, &
         .099264e0_r8,.031548e0_r8,.012557e0_r8,.006841e0_r8,.003705e0_r8,.002144e0_r8, &
         .001304e0_r8,.000930e0_r8,.000799e0_r8,.000675e0_r8,.000601e0_r8,.000503e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000460e0_r8,.000486e0_r8,.000398e0_r8, &
         .101718e0_r8,.026523e0_r8,.008473e0_r8,.004382e0_r8,.002392e0_r8,.001505e0_r8, &
         .001036e0_r8,.000836e0_r8,.000727e0_r8,.000618e0_r8,.000550e0_r8,.000494e0_r8, &
         .000501e0_r8,.000479e0_r8,.000473e0_r8,.000509e0_r8,.000541e0_r8,.000445e0_r8/), &
         (/18,6/))
    ozone(1:18, 13:18, 2) = RESHAPE( (/ &
         .104172e0_r8,.021499e0_r8,.004389e0_r8,.001922e0_r8,.001078e0_r8,.000865e0_r8, &
         .000767e0_r8,.000743e0_r8,.000654e0_r8,.000562e0_r8,.000499e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8, &
         .104145e0_r8,.018082e0_r8,.003274e0_r8,.001493e0_r8,.000919e0_r8,.000762e0_r8, &
         .000678e0_r8,.000641e0_r8,.000584e0_r8,.000531e0_r8,.000495e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8, &
         .104118e0_r8,.014665e0_r8,.002159e0_r8,.001063e0_r8,.000759e0_r8,.000659e0_r8, &
         .000589e0_r8,.000539e0_r8,.000514e0_r8,.000499e0_r8,.000491e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8, &
         .107719e0_r8,.013052e0_r8,.001822e0_r8,.000953e0_r8,.000701e0_r8,.000604e0_r8, &
         .000551e0_r8,.000525e0_r8,.000509e0_r8,.000499e0_r8,.000491e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8, &
         .111320e0_r8,.011439e0_r8,.001485e0_r8,.000843e0_r8,.000642e0_r8,.000549e0_r8, &
         .000512e0_r8,.000512e0_r8,.000504e0_r8,.000499e0_r8,.000491e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8, &
         .112375e0_r8,.011255e0_r8,.001357e0_r8,.000744e0_r8,.000585e0_r8,.000533e0_r8, &
         .000512e0_r8,.000512e0_r8,.000504e0_r8,.000499e0_r8,.000491e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8/), &
         (/18,6/))
    ozone(1:18, 19:24, 2) = RESHAPE( (/ &
         .109850e0_r8,.010424e0_r8,.001079e0_r8,.000567e0_r8,.000498e0_r8,.000479e0_r8, &
         .000463e0_r8,.000448e0_r8,.000418e0_r8,.000399e0_r8,.000389e0_r8,.000367e0_r8, &
         .000351e0_r8,.000328e0_r8,.000320e0_r8,.000337e0_r8,.000355e0_r8,.000304e0_r8, &
         .107002e0_r8,.009961e0_r8,.001025e0_r8,.000533e0_r8,.000497e0_r8,.000460e0_r8, &
         .000422e0_r8,.000385e0_r8,.000332e0_r8,.000300e0_r8,.000288e0_r8,.000249e0_r8, &
         .000202e0_r8,.000158e0_r8,.000132e0_r8,.000114e0_r8,.000104e0_r8,.000093e0_r8, &
         .107735e0_r8,.010146e0_r8,.001120e0_r8,.000576e0_r8,.000526e0_r8,.000477e0_r8, &
         .000430e0_r8,.000385e0_r8,.000332e0_r8,.000300e0_r8,.000288e0_r8,.000249e0_r8, &
         .000202e0_r8,.000158e0_r8,.000132e0_r8,.000114e0_r8,.000104e0_r8,.000093e0_r8, &
         .107021e0_r8,.012233e0_r8,.001533e0_r8,.000643e0_r8,.000556e0_r8,.000505e0_r8, &
         .000471e0_r8,.000448e0_r8,.000403e0_r8,.000362e0_r8,.000355e0_r8,.000296e0_r8, &
         .000251e0_r8,.000207e0_r8,.000180e0_r8,.000161e0_r8,.000152e0_r8,.000140e0_r8, &
         .106308e0_r8,.014320e0_r8,.001946e0_r8,.000709e0_r8,.000585e0_r8,.000533e0_r8, &
         .000512e0_r8,.000512e0_r8,.000473e0_r8,.000425e0_r8,.000423e0_r8,.000342e0_r8, &
         .000301e0_r8,.000257e0_r8,.000232e0_r8,.000212e0_r8,.000205e0_r8,.000209e0_r8, &
         .100592e0_r8,.015718e0_r8,.002411e0_r8,.001007e0_r8,.000802e0_r8,.000642e0_r8, &
         .000559e0_r8,.000526e0_r8,.000501e0_r8,.000474e0_r8,.000470e0_r8,.000439e0_r8, &
         .000430e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8/), &
         (/18,6/))
    ozone(1:18, 25:30, 2) = RESHAPE( (/ &
         .094877e0_r8,.017116e0_r8,.002877e0_r8,.001305e0_r8,.001018e0_r8,.000751e0_r8, &
         .000606e0_r8,.000539e0_r8,.000529e0_r8,.000524e0_r8,.000516e0_r8,.000535e0_r8, &
         .000558e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .094163e0_r8,.020198e0_r8,.004594e0_r8,.001772e0_r8,.001077e0_r8,.000806e0_r8, &
         .000649e0_r8,.000565e0_r8,.000547e0_r8,.000537e0_r8,.000521e0_r8,.000535e0_r8, &
         .000558e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .093449e0_r8,.023279e0_r8,.006312e0_r8,.002240e0_r8,.001135e0_r8,.000862e0_r8, &
         .000692e0_r8,.000591e0_r8,.000564e0_r8,.000549e0_r8,.000525e0_r8,.000535e0_r8, &
         .000558e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .089886e0_r8,.026029e0_r8,.008558e0_r8,.003312e0_r8,.001655e0_r8,.001124e0_r8, &
         .000807e0_r8,.000631e0_r8,.000602e0_r8,.000568e0_r8,.000525e0_r8,.000535e0_r8, &
         .000558e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .086323e0_r8,.028778e0_r8,.010805e0_r8,.004383e0_r8,.002175e0_r8,.001386e0_r8, &
         .000923e0_r8,.000671e0_r8,.000640e0_r8,.000587e0_r8,.000525e0_r8,.000535e0_r8, &
         .000558e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .082715e0_r8,.031096e0_r8,.013350e0_r8,.006131e0_r8,.003205e0_r8,.002043e0_r8, &
         .001304e0_r8,.000842e0_r8,.000734e0_r8,.000631e0_r8,.000555e0_r8,.000494e0_r8, &
         .000480e0_r8,.000408e0_r8,.000385e0_r8,.000361e0_r8,.000351e0_r8,.000349e0_r8/), &
         (/18,6/))
    ozone(1:18, 31:36, 2) = RESHAPE( (/ &
         .079108e0_r8,.033415e0_r8,.015895e0_r8,.007878e0_r8,.004234e0_r8,.002700e0_r8, &
         .001686e0_r8,.001014e0_r8,.000829e0_r8,.000675e0_r8,.000584e0_r8,.000454e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .074807e0_r8,.034651e0_r8,.017056e0_r8,.008574e0_r8,.004769e0_r8,.002986e0_r8, &
         .001827e0_r8,.001079e0_r8,.000853e0_r8,.000675e0_r8,.000584e0_r8,.000454e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .070506e0_r8,.035887e0_r8,.018218e0_r8,.009270e0_r8,.005304e0_r8,.003271e0_r8, &
         .001969e0_r8,.001145e0_r8,.000878e0_r8,.000675e0_r8,.000584e0_r8,.000454e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .067669e0_r8,.037799e0_r8,.019680e0_r8,.009612e0_r8,.005481e0_r8,.003476e0_r8, &
         .002093e0_r8,.001123e0_r8,.000837e0_r8,.000631e0_r8,.000546e0_r8,.000447e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .064832e0_r8,.039712e0_r8,.021142e0_r8,.009954e0_r8,.005658e0_r8,.003681e0_r8, &
         .002218e0_r8,.001100e0_r8,.000796e0_r8,.000587e0_r8,.000508e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .063734e0_r8,.039842e0_r8,.022004e0_r8,.010859e0_r8,.005712e0_r8,.003589e0_r8, &
         .002155e0_r8,.001174e0_r8,.000856e0_r8,.000612e0_r8,.000508e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8/), &
         (/18,6/))
    ozone(1:18, 37, 2) = (/ &
         .062636e0_r8,.039972e0_r8,.022867e0_r8,.011765e0_r8,.005766e0_r8,.003498e0_r8, &
         .002092e0_r8,.001248e0_r8,.000917e0_r8,.000637e0_r8,.000508e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8/)
    !
    !     3. summer
    !
    ozone(1:18, 1:6, 3) = RESHAPE( (/ &
         .059066e0_r8,.038201e0_r8,.019999e0_r8,.010813e0_r8,.006498e0_r8,.004188e0_r8, &
         .002656e0_r8,.001636e0_r8,.001110e0_r8,.000737e0_r8,.000551e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .061216e0_r8,.037359e0_r8,.019151e0_r8,.010633e0_r8,.006845e0_r8,.004382e0_r8, &
         .002691e0_r8,.001511e0_r8,.001061e0_r8,.000749e0_r8,.000568e0_r8,.000465e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .063367e0_r8,.036516e0_r8,.018302e0_r8,.010452e0_r8,.007192e0_r8,.004577e0_r8, &
         .002727e0_r8,.001387e0_r8,.001012e0_r8,.000762e0_r8,.000585e0_r8,.000490e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .065518e0_r8,.035975e0_r8,.017854e0_r8,.010100e0_r8,.006534e0_r8,.003985e0_r8, &
         .002321e0_r8,.001240e0_r8,.000966e0_r8,.000774e0_r8,.000640e0_r8,.000548e0_r8, &
         .000479e0_r8,.000384e0_r8,.000346e0_r8,.000316e0_r8,.000302e0_r8,.000302e0_r8, &
         .067669e0_r8,.035434e0_r8,.017406e0_r8,.009749e0_r8,.005876e0_r8,.003393e0_r8, &
         .001916e0_r8,.001094e0_r8,.000920e0_r8,.000787e0_r8,.000694e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .069820e0_r8,.035028e0_r8,.016929e0_r8,.009389e0_r8,.005645e0_r8,.003260e0_r8, &
         .001843e0_r8,.001055e0_r8,.000905e0_r8,.000787e0_r8,.000694e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8/), &
         (/18,6/))
    ozone(1:18, 7:12, 3) = RESHAPE( (/ &
         .071972e0_r8,.034622e0_r8,.016453e0_r8,.009029e0_r8,.005413e0_r8,.003127e0_r8, &
         .001770e0_r8,.001015e0_r8,.000890e0_r8,.000787e0_r8,.000694e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .080939e0_r8,.032414e0_r8,.014163e0_r8,.007241e0_r8,.004328e0_r8,.002522e0_r8, &
         .001481e0_r8,.000934e0_r8,.000861e0_r8,.000787e0_r8,.000694e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .089906e0_r8,.030206e0_r8,.011873e0_r8,.005453e0_r8,.003244e0_r8,.001918e0_r8, &
         .001192e0_r8,.000852e0_r8,.000832e0_r8,.000787e0_r8,.000694e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .093464e0_r8,.026177e0_r8,.008525e0_r8,.003892e0_r8,.002452e0_r8,.001609e0_r8, &
         .001116e0_r8,.000851e0_r8,.000809e0_r8,.000762e0_r8,.000690e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .097023e0_r8,.022148e0_r8,.005177e0_r8,.002332e0_r8,.001660e0_r8,.001300e0_r8, &
         .001041e0_r8,.000849e0_r8,.000786e0_r8,.000737e0_r8,.000686e0_r8,.000606e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .098107e0_r8,.020617e0_r8,.004758e0_r8,.002137e0_r8,.001516e0_r8,.001211e0_r8, &
         .000999e0_r8,.000848e0_r8,.000778e0_r8,.000730e0_r8,.000677e0_r8,.000603e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8/), &
         (/18,6/))
    ozone(1:18, 13:18, 3) = RESHAPE( (/ &
         .099191e0_r8,.019085e0_r8,.004340e0_r8,.001943e0_r8,.001371e0_r8,.001122e0_r8, &
         .000957e0_r8,.000847e0_r8,.000770e0_r8,.000724e0_r8,.000669e0_r8,.000601e0_r8, &
         .000557e0_r8,.000412e0_r8,.000362e0_r8,.000326e0_r8,.000309e0_r8,.000302e0_r8, &
         .099547e0_r8,.017725e0_r8,.003693e0_r8,.001578e0_r8,.001125e0_r8,.000985e0_r8, &
         .000879e0_r8,.000795e0_r8,.000712e0_r8,.000643e0_r8,.000584e0_r8,.000521e0_r8, &
         .000482e0_r8,.000384e0_r8,.000351e0_r8,.000322e0_r8,.000302e0_r8,.000302e0_r8, &
         .099903e0_r8,.016365e0_r8,.003045e0_r8,.001214e0_r8,.000879e0_r8,.000848e0_r8, &
         .000801e0_r8,.000744e0_r8,.000654e0_r8,.000562e0_r8,.000499e0_r8,.000441e0_r8, &
         .000410e0_r8,.000358e0_r8,.000342e0_r8,.000322e0_r8,.000302e0_r8,.000302e0_r8, &
         .100218e0_r8,.015035e0_r8,.002537e0_r8,.001037e0_r8,.000790e0_r8,.000726e0_r8, &
         .000673e0_r8,.000628e0_r8,.000579e0_r8,.000512e0_r8,.000440e0_r8,.000374e0_r8, &
         .000307e0_r8,.000253e0_r8,.000227e0_r8,.000208e0_r8,.000194e0_r8,.000186e0_r8, &
         .100534e0_r8,.013704e0_r8,.002028e0_r8,.000861e0_r8,.000701e0_r8,.000604e0_r8, &
         .000546e0_r8,.000513e0_r8,.000504e0_r8,.000462e0_r8,.000381e0_r8,.000307e0_r8, &
         .000201e0_r8,.000151e0_r8,.000117e0_r8,.000098e0_r8,.000090e0_r8,.000093e0_r8, &
         .100892e0_r8,.012873e0_r8,.001886e0_r8,.000785e0_r8,.000643e0_r8,.000568e0_r8, &
         .000519e0_r8,.000487e0_r8,.000471e0_r8,.000437e0_r8,.000368e0_r8,.000305e0_r8, &
         .000201e0_r8,.000151e0_r8,.000117e0_r8,.000098e0_r8,.000090e0_r8,.000093e0_r8/), &
         (/18,6/))
    ozone(1:18, 19:24, 3) = RESHAPE( (/ &
         .102665e0_r8,.010977e0_r8,.001237e0_r8,.000590e0_r8,.000498e0_r8,.000479e0_r8, &
         .000458e0_r8,.000436e0_r8,.000421e0_r8,.000387e0_r8,.000326e0_r8,.000298e0_r8, &
         .000246e0_r8,.000227e0_r8,.000211e0_r8,.000200e0_r8,.000194e0_r8,.000186e0_r8, &
         .104087e0_r8,.010726e0_r8,.000971e0_r8,.000538e0_r8,.000440e0_r8,.000434e0_r8, &
         .000418e0_r8,.000397e0_r8,.000375e0_r8,.000343e0_r8,.000296e0_r8,.000294e0_r8, &
         .000293e0_r8,.000302e0_r8,.000306e0_r8,.000302e0_r8,.000302e0_r8,.000302e0_r8, &
         .104093e0_r8,.011539e0_r8,.001213e0_r8,.000604e0_r8,.000468e0_r8,.000442e0_r8, &
         .000414e0_r8,.000385e0_r8,.000347e0_r8,.000325e0_r8,.000296e0_r8,.000294e0_r8, &
         .000293e0_r8,.000302e0_r8,.000306e0_r8,.000302e0_r8,.000302e0_r8,.000302e0_r8, &
         .104106e0_r8,.012997e0_r8,.001479e0_r8,.000639e0_r8,.000468e0_r8,.000422e0_r8, &
         .000392e0_r8,.000372e0_r8,.000342e0_r8,.000325e0_r8,.000296e0_r8,.000294e0_r8, &
         .000293e0_r8,.000302e0_r8,.000306e0_r8,.000302e0_r8,.000302e0_r8,.000302e0_r8, &
         .104118e0_r8,.014455e0_r8,.001745e0_r8,.000674e0_r8,.000467e0_r8,.000403e0_r8, &
         .000370e0_r8,.000359e0_r8,.000337e0_r8,.000325e0_r8,.000296e0_r8,.000294e0_r8, &
         .000293e0_r8,.000302e0_r8,.000306e0_r8,.000302e0_r8,.000302e0_r8,.000302e0_r8, &
         .103456e0_r8,.018235e0_r8,.003195e0_r8,.001379e0_r8,.000771e0_r8,.000585e0_r8, &
         .000474e0_r8,.000411e0_r8,.000380e0_r8,.000362e0_r8,.000343e0_r8,.000348e0_r8, &
         .000346e0_r8,.000328e0_r8,.000317e0_r8,.000305e0_r8,.000302e0_r8,.000302e0_r8/), &
         (/18,6/))
    ozone(1:18, 25:30, 3) = RESHAPE( (/ &
         .102794e0_r8,.022015e0_r8,.004645e0_r8,.002084e0_r8,.001076e0_r8,.000767e0_r8, &
         .000577e0_r8,.000463e0_r8,.000423e0_r8,.000399e0_r8,.000389e0_r8,.000401e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .101724e0_r8,.026500e0_r8,.007228e0_r8,.003391e0_r8,.002058e0_r8,.001285e0_r8, &
         .000811e0_r8,.000531e0_r8,.000478e0_r8,.000449e0_r8,.000440e0_r8,.000421e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .100654e0_r8,.030986e0_r8,.009812e0_r8,.004698e0_r8,.003041e0_r8,.001803e0_r8, &
         .001044e0_r8,.000599e0_r8,.000533e0_r8,.000499e0_r8,.000491e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .097097e0_r8,.034916e0_r8,.012983e0_r8,.006240e0_r8,.003666e0_r8,.002259e0_r8, &
         .001336e0_r8,.000730e0_r8,.000629e0_r8,.000549e0_r8,.000499e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .093540e0_r8,.038846e0_r8,.016155e0_r8,.007781e0_r8,.004292e0_r8,.002716e0_r8, &
         .001628e0_r8,.000862e0_r8,.000724e0_r8,.000600e0_r8,.000508e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .089618e0_r8,.042869e0_r8,.019963e0_r8,.010502e0_r8,.005966e0_r8,.003525e0_r8, &
         .001936e0_r8,.000906e0_r8,.000769e0_r8,.000625e0_r8,.000508e0_r8,.000452e0_r8, &
         .000451e0_r8,.000408e0_r8,.000385e0_r8,.000361e0_r8,.000351e0_r8,.000349e0_r8/), &
         (/18,6/))
    ozone(1:18, 31:36, 3) = RESHAPE( (/ &
         .085695e0_r8,.046892e0_r8,.023772e0_r8,.013223e0_r8,.007640e0_r8,.004333e0_r8, &
         .002244e0_r8,.000951e0_r8,.000815e0_r8,.000650e0_r8,.000508e0_r8,.000463e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .082443e0_r8,.047591e0_r8,.025358e0_r8,.014294e0_r8,.008233e0_r8,.004664e0_r8, &
         .002430e0_r8,.001068e0_r8,.000851e0_r8,.000644e0_r8,.000508e0_r8,.000474e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .079190e0_r8,.048290e0_r8,.026945e0_r8,.015366e0_r8,.008826e0_r8,.004995e0_r8, &
         .002616e0_r8,.001184e0_r8,.000887e0_r8,.000637e0_r8,.000508e0_r8,.000486e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .074885e0_r8,.049987e0_r8,.030140e0_r8,.017894e0_r8,.009881e0_r8,.005543e0_r8, &
         .002907e0_r8,.001379e0_r8,.000961e0_r8,.000644e0_r8,.000512e0_r8,.000463e0_r8, &
         .000451e0_r8,.000408e0_r8,.000385e0_r8,.000361e0_r8,.000351e0_r8,.000349e0_r8, &
         .070579e0_r8,.051684e0_r8,.033335e0_r8,.020423e0_r8,.010935e0_r8,.006091e0_r8, &
         .003197e0_r8,.001573e0_r8,.001034e0_r8,.000650e0_r8,.000517e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .069523e0_r8,.052249e0_r8,.034255e0_r8,.021379e0_r8,.012306e0_r8,.006727e0_r8, &
         .003415e0_r8,.001578e0_r8,.001072e0_r8,.000681e0_r8,.000517e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8/), &
         (/18,6/))
    ozone(1:18, 37, 3) = (/ &
         .068467e0_r8,.052815e0_r8,.035175e0_r8,.022334e0_r8,.013676e0_r8,.007363e0_r8, &
         .003633e0_r8,.001582e0_r8,.001111e0_r8,.000713e0_r8,.000517e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8/)
    !
    !     4. fall
    !
    ozone(1:18, 1:6, 4) = RESHAPE( (/ &
         .062636e0_r8,.039972e0_r8,.022867e0_r8,.011765e0_r8,.005766e0_r8,.003498e0_r8, &
         .002092e0_r8,.001248e0_r8,.000917e0_r8,.000637e0_r8,.000508e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .063734e0_r8,.039842e0_r8,.022004e0_r8,.010859e0_r8,.005712e0_r8,.003589e0_r8, &
         .002155e0_r8,.001174e0_r8,.000856e0_r8,.000612e0_r8,.000508e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .064832e0_r8,.039712e0_r8,.021142e0_r8,.009954e0_r8,.005658e0_r8,.003681e0_r8, &
         .002218e0_r8,.001100e0_r8,.000796e0_r8,.000587e0_r8,.000508e0_r8,.000441e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .067669e0_r8,.037799e0_r8,.019680e0_r8,.009612e0_r8,.005481e0_r8,.003476e0_r8, &
         .002093e0_r8,.001123e0_r8,.000837e0_r8,.000631e0_r8,.000546e0_r8,.000447e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .070506e0_r8,.035887e0_r8,.018218e0_r8,.009270e0_r8,.005304e0_r8,.003271e0_r8, &
         .001969e0_r8,.001145e0_r8,.000878e0_r8,.000675e0_r8,.000584e0_r8,.000454e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .074807e0_r8,.034651e0_r8,.017056e0_r8,.008574e0_r8,.004769e0_r8,.002986e0_r8, &
         .001827e0_r8,.001079e0_r8,.000853e0_r8,.000675e0_r8,.000584e0_r8,.000454e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8/), &
         (/18,6/))
    ozone(1:18, 7:12, 4) = RESHAPE( (/ &
         .079108e0_r8,.033415e0_r8,.015895e0_r8,.007878e0_r8,.004234e0_r8,.002700e0_r8, &
         .001686e0_r8,.001014e0_r8,.000829e0_r8,.000675e0_r8,.000584e0_r8,.000454e0_r8, &
         .000401e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .082715e0_r8,.031096e0_r8,.013350e0_r8,.006131e0_r8,.003205e0_r8,.002043e0_r8, &
         .001304e0_r8,.000842e0_r8,.000734e0_r8,.000631e0_r8,.000555e0_r8,.000494e0_r8, &
         .000480e0_r8,.000408e0_r8,.000385e0_r8,.000361e0_r8,.000351e0_r8,.000349e0_r8, &
         .086323e0_r8,.028778e0_r8,.010805e0_r8,.004383e0_r8,.002175e0_r8,.001386e0_r8, &
         .000923e0_r8,.000671e0_r8,.000640e0_r8,.000587e0_r8,.000525e0_r8,.000535e0_r8, &
         .000558e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .089886e0_r8,.026029e0_r8,.008558e0_r8,.003312e0_r8,.001655e0_r8,.001124e0_r8, &
         .000807e0_r8,.000631e0_r8,.000602e0_r8,.000568e0_r8,.000525e0_r8,.000535e0_r8, &
         .000558e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .093449e0_r8,.023279e0_r8,.006312e0_r8,.002240e0_r8,.001135e0_r8,.000862e0_r8, &
         .000692e0_r8,.000591e0_r8,.000564e0_r8,.000549e0_r8,.000525e0_r8,.000535e0_r8, &
         .000558e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .094163e0_r8,.020198e0_r8,.004594e0_r8,.001772e0_r8,.001077e0_r8,.000806e0_r8, &
         .000649e0_r8,.000565e0_r8,.000547e0_r8,.000537e0_r8,.000521e0_r8,.000535e0_r8, &
         .000558e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8/), &
         (/18,6/))
    ozone(1:18, 13:18, 4) = RESHAPE( (/ &
         .094877e0_r8,.017116e0_r8,.002877e0_r8,.001305e0_r8,.001018e0_r8,.000751e0_r8, &
         .000606e0_r8,.000539e0_r8,.000529e0_r8,.000524e0_r8,.000516e0_r8,.000535e0_r8, &
         .000558e0_r8,.000459e0_r8,.000436e0_r8,.000416e0_r8,.000406e0_r8,.000395e0_r8, &
         .100592e0_r8,.015718e0_r8,.002411e0_r8,.001007e0_r8,.000802e0_r8,.000642e0_r8, &
         .000559e0_r8,.000526e0_r8,.000501e0_r8,.000474e0_r8,.000470e0_r8,.000439e0_r8, &
         .000430e0_r8,.000358e0_r8,.000333e0_r8,.000311e0_r8,.000302e0_r8,.000302e0_r8, &
         .106308e0_r8,.014320e0_r8,.001946e0_r8,.000709e0_r8,.000585e0_r8,.000533e0_r8, &
         .000512e0_r8,.000512e0_r8,.000473e0_r8,.000425e0_r8,.000423e0_r8,.000342e0_r8, &
         .000301e0_r8,.000257e0_r8,.000232e0_r8,.000212e0_r8,.000205e0_r8,.000209e0_r8, &
         .107021e0_r8,.012233e0_r8,.001533e0_r8,.000643e0_r8,.000556e0_r8,.000505e0_r8, &
         .000471e0_r8,.000448e0_r8,.000403e0_r8,.000362e0_r8,.000355e0_r8,.000296e0_r8, &
         .000251e0_r8,.000207e0_r8,.000180e0_r8,.000161e0_r8,.000152e0_r8,.000140e0_r8, &
         .107735e0_r8,.010146e0_r8,.001120e0_r8,.000576e0_r8,.000526e0_r8,.000477e0_r8, &
         .000430e0_r8,.000385e0_r8,.000332e0_r8,.000300e0_r8,.000288e0_r8,.000249e0_r8, &
         .000202e0_r8,.000158e0_r8,.000132e0_r8,.000114e0_r8,.000104e0_r8,.000093e0_r8, &
         .107002e0_r8,.009961e0_r8,.001025e0_r8,.000533e0_r8,.000497e0_r8,.000460e0_r8, &
         .000422e0_r8,.000385e0_r8,.000332e0_r8,.000300e0_r8,.000288e0_r8,.000249e0_r8, &
         .000202e0_r8,.000158e0_r8,.000132e0_r8,.000114e0_r8,.000104e0_r8,.000093e0_r8/), &
         (/18,6/))
    ozone(1:18, 19:24, 4) = RESHAPE( (/ &
         .109850e0_r8,.010424e0_r8,.001079e0_r8,.000567e0_r8,.000498e0_r8,.000479e0_r8, &
         .000463e0_r8,.000448e0_r8,.000418e0_r8,.000399e0_r8,.000389e0_r8,.000367e0_r8, &
         .000351e0_r8,.000328e0_r8,.000320e0_r8,.000337e0_r8,.000355e0_r8,.000304e0_r8, &
         .112375e0_r8,.011255e0_r8,.001357e0_r8,.000744e0_r8,.000585e0_r8,.000533e0_r8, &
         .000512e0_r8,.000512e0_r8,.000504e0_r8,.000499e0_r8,.000491e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8, &
         .111320e0_r8,.011439e0_r8,.001485e0_r8,.000843e0_r8,.000642e0_r8,.000549e0_r8, &
         .000512e0_r8,.000512e0_r8,.000504e0_r8,.000499e0_r8,.000491e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8, &
         .107719e0_r8,.013052e0_r8,.001822e0_r8,.000953e0_r8,.000701e0_r8,.000604e0_r8, &
         .000551e0_r8,.000525e0_r8,.000509e0_r8,.000499e0_r8,.000491e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8, &
         .104118e0_r8,.014665e0_r8,.002159e0_r8,.001063e0_r8,.000759e0_r8,.000659e0_r8, &
         .000589e0_r8,.000539e0_r8,.000514e0_r8,.000499e0_r8,.000491e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8, &
         .104145e0_r8,.018082e0_r8,.003274e0_r8,.001493e0_r8,.000919e0_r8,.000762e0_r8, &
         .000678e0_r8,.000641e0_r8,.000584e0_r8,.000531e0_r8,.000495e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8/), &
         (/18,6/))
    ozone(1:18, 25:30, 4) = RESHAPE( (/ &
         .104172e0_r8,.021499e0_r8,.004389e0_r8,.001922e0_r8,.001078e0_r8,.000865e0_r8, &
         .000767e0_r8,.000743e0_r8,.000654e0_r8,.000562e0_r8,.000499e0_r8,.000486e0_r8, &
         .000501e0_r8,.000502e0_r8,.000509e0_r8,.000561e0_r8,.000607e0_r8,.000515e0_r8, &
         .101718e0_r8,.026523e0_r8,.008473e0_r8,.004382e0_r8,.002392e0_r8,.001505e0_r8, &
         .001036e0_r8,.000836e0_r8,.000727e0_r8,.000618e0_r8,.000550e0_r8,.000494e0_r8, &
         .000501e0_r8,.000479e0_r8,.000473e0_r8,.000509e0_r8,.000541e0_r8,.000445e0_r8, &
         .099264e0_r8,.031548e0_r8,.012557e0_r8,.006841e0_r8,.003705e0_r8,.002144e0_r8, &
         .001304e0_r8,.000930e0_r8,.000799e0_r8,.000675e0_r8,.000601e0_r8,.000503e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000460e0_r8,.000486e0_r8,.000398e0_r8, &
         .097501e0_r8,.035382e0_r8,.014856e0_r8,.008207e0_r8,.004619e0_r8,.002720e0_r8, &
         .001610e0_r8,.001012e0_r8,.000829e0_r8,.000687e0_r8,.000610e0_r8,.000503e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000460e0_r8,.000486e0_r8,.000398e0_r8, &
         .095737e0_r8,.039215e0_r8,.017155e0_r8,.009572e0_r8,.005532e0_r8,.003296e0_r8, &
         .001916e0_r8,.001094e0_r8,.000858e0_r8,.000699e0_r8,.000618e0_r8,.000503e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000460e0_r8,.000486e0_r8,.000398e0_r8, &
         .092863e0_r8,.042419e0_r8,.020704e0_r8,.012034e0_r8,.007417e0_r8,.004504e0_r8, &
         .002590e0_r8,.001334e0_r8,.000977e0_r8,.000731e0_r8,.000622e0_r8,.000503e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000460e0_r8,.000486e0_r8,.000398e0_r8/), &
         (/18,6/))
    ozone(1:18, 31:36, 4) = RESHAPE( (/ &
         .089988e0_r8,.045622e0_r8,.024253e0_r8,.014495e0_r8,.009303e0_r8,.005711e0_r8, &
         .003264e0_r8,.001574e0_r8,.001096e0_r8,.000762e0_r8,.000627e0_r8,.000503e0_r8, &
         .000501e0_r8,.000459e0_r8,.000436e0_r8,.000460e0_r8,.000486e0_r8,.000398e0_r8, &
         .084591e0_r8,.046553e0_r8,.025037e0_r8,.015156e0_r8,.009841e0_r8,.006124e0_r8, &
         .003534e0_r8,.001693e0_r8,.001170e0_r8,.000793e0_r8,.000631e0_r8,.000537e0_r8, &
         .000551e0_r8,.000509e0_r8,.000486e0_r8,.000516e0_r8,.000548e0_r8,.000446e0_r8, &
         .079194e0_r8,.047483e0_r8,.025822e0_r8,.015818e0_r8,.010380e0_r8,.006537e0_r8, &
         .003804e0_r8,.001811e0_r8,.001245e0_r8,.000825e0_r8,.000635e0_r8,.000570e0_r8, &
         .000603e0_r8,.000559e0_r8,.000538e0_r8,.000574e0_r8,.000614e0_r8,.000515e0_r8, &
         .077409e0_r8,.048159e0_r8,.026661e0_r8,.016596e0_r8,.010962e0_r8,.006972e0_r8, &
         .004160e0_r8,.002132e0_r8,.001391e0_r8,.000868e0_r8,.000686e0_r8,.000601e0_r8, &
         .000603e0_r8,.000559e0_r8,.000538e0_r8,.000574e0_r8,.000614e0_r8,.000515e0_r8, &
         .075625e0_r8,.048835e0_r8,.027500e0_r8,.017375e0_r8,.011544e0_r8,.007407e0_r8, &
         .004516e0_r8,.002453e0_r8,.001536e0_r8,.000912e0_r8,.000737e0_r8,.000632e0_r8, &
         .000603e0_r8,.000559e0_r8,.000538e0_r8,.000574e0_r8,.000614e0_r8,.000515e0_r8, &
         .074927e0_r8,.049459e0_r8,.029215e0_r8,.018025e0_r8,.011754e0_r8,.007786e0_r8, &
         .004972e0_r8,.002926e0_r8,.001817e0_r8,.001025e0_r8,.000758e0_r8,.000632e0_r8, &
         .000603e0_r8,.000559e0_r8,.000538e0_r8,.000574e0_r8,.000614e0_r8,.000515e0_r8/), &
         (/18,6/))
    ozone(1:18, 37, 4) = (/ &
         .074229e0_r8,.050084e0_r8,.030930e0_r8,.018676e0_r8,.011965e0_r8,.008165e0_r8, &
         .005428e0_r8,.003399e0_r8,.002098e0_r8,.001138e0_r8,.000780e0_r8,.000632e0_r8, &
         .000603e0_r8,.000559e0_r8,.000538e0_r8,.000574e0_r8,.000614e0_r8,.000515e0_r8/)

    ozsig(:) = (/ &
         .020747_r8,.073986_r8,.124402_r8,.174576_r8,.224668_r8,.274735_r8, &
         .324767_r8,.374806_r8,.424818_r8,.497450_r8,.593540_r8,.688125_r8, &
         .777224_r8,.856317_r8,.920400_r8,.960480_r8,.981488_r8,.995004_r8/)


    first_getoz=.TRUE.

  END SUBROUTINE InitRadiation

  SUBROUTINE InitSpmrad
    pai12      = pai/12.e0_r8
    pai2i      = 1.0e0_r8/(2.0e0_r8*pai)
    fim24      = 24.0e0_r8/360.0e0_r8
  END SUBROUTINE InitSpmrad

  SUBROUTINE InitRadtim(monl)
    INTEGER, INTENT(in ) :: monl(12)
    INTEGER              :: m
    monday(1)=0
    DO m=2,12
       monday(m)=monday(m-1)+monl(m-1)
    END DO
  END SUBROUTINE InitRadtim
  SUBROUTINE InitGetoz(yrl,kmax,sl)
    IMPLICIT NONE
    REAL(KIND=r8),    INTENT(IN   ) :: yrl
    INTEGER, INTENT(IN   ) :: kmax
    REAL(KIND=r8),    INTENT(in   ) :: sl (kmax)
    INTEGER                :: l, ll

    IF(first_getoz)THEN
       mon_getoz=yrl/12.0_r8
       year_getoz=yrl
       IF(nlm_getoz.NE.kmax)THEN
          inter_getoz=.TRUE.
       ELSE
          inter_getoz=.FALSE.
          DO l=1,nlm_getoz
             ll=nlm_getoz-l+1
             IF(ABS(ozsig(l)-sl(ll)).GT.0.0001_r8)inter_getoz=.TRUE.
          END DO
       ENDIF
       first_getoz=.FALSE.
    ENDIF
  END SUBROUTINE InitGetoz

  SUBROUTINE COSZMED(idatec,tod,yrl,colrad,lonrad,cos2,ncols)
    IMPLICIT NONE
    INTEGER, INTENT(IN   )  :: ncols
    INTEGER, INTENT(IN   )  :: idatec(4)
    REAL(KIND=r8)   , INTENT(IN   )  :: tod
    REAL(KIND=r8)   , INTENT(IN   )  :: yrl
    REAL(KIND=r8)   , INTENT(IN   )  :: colrad
    REAL(KIND=r8)   , INTENT(in   )  :: lonrad (ncols)
    REAL(KIND=r8)   , INTENT(INOUT  )  :: cos2

    REAL(KIND=r8)                    :: sindel
    REAL(KIND=r8)                    :: cosdel
    REAL(KIND=r8)                    :: cosmax
    REAL(KIND=r8)                    :: ctime
    REAL(KIND=r8)                    :: frh
    REAL(KIND=r8)                    :: btime
    REAL(KIND=r8)                    :: atime
    REAL(KIND=r8)                    :: zenith1
    REAL(KIND=r8)                    :: zenith2
    REAL(KIND=r8)                    :: zenith  (ncols)
    REAL(KIND=r8)                    :: f3600 =3.6e3_r8
    INTEGER                 :: ncount
    REAL(KIND=r8)                    :: alon=0.0_r8
    REAL(KIND=r8)              :: sdelt
    REAL(KIND=r8)              :: ratio
    REAL(KIND=r8)              :: etime
    REAL(KIND=r8)              :: xday
    INTEGER                 :: i
    CALL radtim(idatec,sdelt ,ratio ,etime ,tod   ,xday  ,yrl)

    sindel = SIN(sdelt)
    cosdel = COS(sdelt)
    ctime  = alon/15.0e0_r8
    cos2   = 0.0e0_r8
    cosmax = 0.0e0_r8
    btime  = 0.0e0_r8
    atime  = 0.0e0_r8
    zenith1  = sindel*COS(colrad)
    zenith2  = cosdel*SIN(colrad)
    frh=( MOD(tod+0.03125_r8,f3600)-0.03125_r8)/f3600
    ncount =0
    DO i=1,ncols
       btime       = fim24*lonrad(i)+ctime
       atime       = etime+pai12*(12.0_r8-idatec(1)-frh-btime)
       zenith(i)   = zenith1 + zenith2*COS(atime)
       IF(zenith(i).GT.0.0e0_r8) THEN
          ncount   =ncount+1
          cosmax     =cosmax+zenith(i)
       END IF
    END DO
    IF(ncount.EQ.0) ncount=1
    cos2=cosmax/REAL(ncount,r8)
  END SUBROUTINE COSZMED

  ! crunch: Computation of the gaseous transmission functions




  SUBROUTINE crunch(indx1 ,indx2 ,ncols ,kmax  ,h0p   ,h1p   ,ozone ,txuf  , &
       tv1   ,tv2   ,tui   ,tui2  ,x1    ,x2    ,cc    ,rawi  , &
       x3    ,x4    ,ch    ,css   ,ccu   ,shi   ,shu   ,wdel  , &
       fw    ,pai   ,tai   ,ozai  ,ubar  ,vbar  ,wbar  ,ubarm , &
       vbarm ,wbarm ,fluxu ,fluxd )
    !
    !
    !  Input formal parameters :: index1, index2
    !  parameters used to calculate trnasmission functions
    !  From one level to another
    !==========================================================================
    ! ncols......Number of grid points on a gaussian latitude circle
    ! kmax......Number of grid points at vertical
    ! indx1.....parameters used to calculate trnasmission functions
    ! indx2.....parameters used to calculate trnasmission functions
    ! h0p.......constant h0p = 0.0e0 fac converts to degrees / time step
    ! h1p.......constant h1p = 1.0e0 fac converts to degrees / time step
    ! ozone.....set ozone logical variable  ozone = (.NOT. noz)
    ! txuf......1.used as matrix of g-functions for paths from each level
    !             to all other layers.
    !           2.used for transmission in co2 band.
    !           3.used for transmission in ozone band.
    !           4.in cldslw used for probability of clear line-of-sight
    !             from each level to all other layers for max overlap.
    ! tv1.......Working dimension
    ! tv2 ......Working dimension
    ! tui.......Working dimension
    ! tui2......Working dimension
    ! x1........path water vapor(e-type) and working dimension
    ! x2........path water vapor(band-center) and working dimension
    ! cc........planck function at level temperature for co2 bands.
    ! rawi......water vapor amount in layer.
    ! x3........path water vapor (band-wings) and working dimension
    ! x4........Working dimension
    ! ch........Probability of clear line-of-sight from level to top of
    !           the atmosphere.
    ! css.......Large scale cloud amount and working dimension
    ! ccu.......Cumulus cloud amount and working dimension
    ! shi.......Total transmission function (water vapor + CO2 + ozone)
    !           g-function for a path from level to top of atmosphere.
    ! shu.......Total transmission function (water vapor + CO2 + ozone)
    !           g-function for a path from level  of atmosphere to surface
    ! wdel......Ozone path, water vapor (e-TYPE) transmission function in
    !           9.6 mcm band
    ! fw........Ozone path multiplied bye pressure
    ! pai.......Pressure at middle of layer
    ! tai.......Temperature at middle of layer
    ! ozai......ozone amount in layer.
    ! ubar......scaled water vapor path length in window.
    ! vbar......scaled water vapor path length in center.
    ! wbar......scaled water vapor path length in wing.
    ! ubarm.....ubarm(i,2) = (ubar(i,2) + ubar(i,1)) * hp5
    ! vbarm.... planck function at level temperature for ozone band.
    ! wbarm.... ubarm(i,2) = (ubar(i,2) + ubar(i,1)) * hp5
    ! fluxu.....Ozone path
    ! fluxd.....Ozone path mutiplicated by pressure
    !
    !==========================================================================
    INTEGER, INTENT(IN   ) :: ncols
    INTEGER, INTENT(IN   ) :: kmax
    INTEGER, INTENT(IN   ) :: indx1
    INTEGER, INTENT(IN   ) :: indx2
    REAL(KIND=r8),    INTENT(IN   ) :: h0p
    REAL(KIND=r8),    INTENT(IN   ) :: h1p
    LOGICAL, INTENT(IN   ) :: ozone
    REAL(KIND=r8),    INTENT(INOUT  ) :: txuf  (ncols,kmax+2,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: tv1   (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(IN   ) :: tv2   (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(IN   ) :: tui   (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(IN   ) :: tui2  (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(INOUT  ) :: x1    (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(INOUT  ) :: x2    (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(IN   ) :: cc    (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(IN   ) :: rawi  (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(INOUT  ) :: x3    (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(INOUT  ) :: x4    (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: ch    (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: css   (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: ccu   (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(INOUT  ) :: shi   (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(INOUT  ) :: shu   (ncols,kmax+1)
    REAL(KIND=r8),    INTENT(INOUT  ) :: wdel  (ncols,kmax+1)
    REAL(KIND=r8),    INTENT(INOUT  ) :: fw    (ncols,kmax+1)

    ! Local Variables --->> Global Variables

    REAL(KIND=r8),    INTENT(IN   ) :: pai  (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: tai  (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: ozai (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: ubar (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: vbar (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: wbar (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: ubarm(ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: vbarm(ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: wbarm(ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: fluxu(ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: fluxd(ncols,kmax+2)

    REAL(KIND=r8)                   :: adel  (ncols,kmax+1)
    REAL(KIND=r8)                   :: bdel  (ncols,kmax+1)
    REAL(KIND=r8)                   :: yv    (ncols,kmax+1)
    REAL(KIND=r8)                   :: zv    (ncols,kmax+1)
    REAL(KIND=r8)                   :: wv    (ncols,kmax+1)
    REAL(KIND=r8)                   :: fu    (ncols,kmax+1)
    REAL(KIND=r8)                   :: yw    (ncols,kmax+1)
    REAL(KIND=r8)                   :: zw    (ncols,kmax+1)
    REAL(KIND=r8)                   :: ww    (ncols,kmax+1)

    !  Local Parameter

    REAL(KIND=r8), PARAMETER        :: h9p8  = -9.79e0_r8
    REAL(KIND=r8), PARAMETER        :: h27p  = -27.0e0_r8
    REAL(KIND=r8), PARAMETER        :: hp61  = 6.15384615e-1_r8
    REAL(KIND=r8), PARAMETER        :: h15p1 = 15.1e0_r8
    REAL(KIND=r8), PARAMETER        :: h3p1  = -3.1e0_r8
    REAL(KIND=r8), PARAMETER        :: hp9   = 0.9e0_r8
    REAL(KIND=r8), PARAMETER        :: hp04  = -0.04e0_r8
    REAL(KIND=r8), PARAMETER        :: h16p  = 16.0e0_r8
    REAL(KIND=r8), PARAMETER        :: h6p7  = -6.7e0_r8
    REAL(KIND=r8), PARAMETER        :: h1013 = 1013.25e0_r8
    REAL(KIND=r8), PARAMETER        :: h1381 = 1381.12e0_r8
    REAL(KIND=r8), PARAMETER        :: hp88  = 0.8796e0_r8
    REAL(KIND=r8), PARAMETER        :: hp677 = 6.7675e-1_r8
    REAL(KIND=r8), PARAMETER        :: h4p4  = -4.398e0_r8
    REAL(KIND=r8), PARAMETER        :: hp38  = 3.84615384e-1_r8

    INTEGER                :: ip
    !INTEGER                :: ix
    INTEGER                :: i  ! loop indices
    INTEGER                :: k  ! loop indices
    !INTEGER                :: isub
    !INTEGER                :: ksub
    !INTEGER                :: imtn
    INTEGER                :: ip1
    INTEGER                ::  n
    INTEGER                :: i0
    INTEGER                :: i1
    INTEGER                :: i2

    REAL(KIND=r8)                   :: x1_s
    REAL(KIND=r8)                   :: x2_s
    REAL(KIND=r8)                   :: x3_s
    REAL(KIND=r8)                   :: adel_s
    REAL(KIND=r8)                   :: bdel_s
    REAL(KIND=r8)                   :: wdel_s
    REAL(KIND=r8)                   :: fw_s
    REAL(KIND=r8)                   :: fu_s
    REAL(KIND=r8)                   :: yw_s
    REAL(KIND=r8)                   :: ww_s
    REAL(KIND=r8)                   :: yv_s
    REAL(KIND=r8)                   :: wv_s
    REAL(KIND=r8)                   :: zv_s
    REAL(KIND=r8)                   :: zw_s

    IF (ozone) THEN
       IF (indx1 == indx2) THEN
          IF (indx2 == 1) THEN
             DO k = 1, kMax+1
                DO i = 1, ncols
                   x1(i,k) = ABS(ubar(i,k+1))
                   x2(i,k) = ABS(vbar(i,k+1))
                   x3(i,k) = ABS(wbar(i,k+1))
                   adel(i,k) = ABS(tai(i,k+1))
                   bdel(i,k) = ABS(ch(i,k+1))
                END DO
             END DO
          ELSE
             DO k = 1, kmax+1
                DO i = 1, ncols
                   x1(i,k)   = ubar(i,kmax+2) - ubar(i,k)
                   x2(i,k)   = vbar(i,kmax+2) - vbar(i,k)
                   x3(i,k)   = wbar(i,kmax+2) - wbar(i,k)
                   adel(i,k) = tai(i,kmax+2)  - tai(i,k)
                   bdel(i,k) = ch(i,kmax+2)   - ch(i,k)
                   wdel(i,k) = fluxu(i,kmax+2) - fluxu(i,k)
                   fw(i,k) = fluxd(i,kmax+2) - fluxd(i,k)
                   x1(i,k) = ABS(x1(i,k))
                   x2(i,k) = ABS(x2(i,k))
                   x3(i,k) = ABS(x3(i,k))
                   adel(i,k) = ABS(adel(i,k))
                   bdel(i,k) = ABS(bdel(i,k))
                   wdel(i,k) = ABS(wdel(i,k))
                   fw  (i,k) = ABS(fw  (i,k))
                END DO
             END DO
          END IF

          DO k=1,kmax+1
             DO i = 1, ncols
                fu_s = h9p8 * x1(i,k)
                yw_s = EXP(LOG(x1(i,k) + 1.0e-100_r8)*.83_r8)
                ww_s = EXP(LOG(x3(i,k) + 1.0e-100_r8)*.6_r8)
                ww_s = h1p + h16p  * ww_s
                ww_s = h6p7 * x3(i,k) / ww_s
                ww_s = h27p * yw_s + ww_s
                yw_s = EXP(LOG(adel(i,k) + 1.0e-100_r8)*.56_r8)
                yw_s = h1p  + h15p1     * yw_s
                yv_s = h3p1 * adel(i,k) / yw_s
                yv_s = yv_s       + ww_s
                yw_s = EXP(LOG(bdel(i,k) + 1.0e-100_r8)*.57_r8)
                yw_s = h1p  + hp9       * yw_s
                wv_s = hp04 * bdel(i,k) / yw_s
                wv_s = wv_s + ww_s
                fw_s   = fw(i,k)/ (wdel(i,k) * h1013)
                zv_s   = h1381 * wdel(i,k)  / (hp88 * fw_s)
                adel_s = h1p + zv_s
                adel_s = SQRT(adel_s)
                adel_s = h4p4 * fw_s * (adel_s - h1p)
                zv_s = EXP(adel_s)
                fw_s = h1p - hp677 * (h1p - zv_s)
                adel_s = EXP(yv_s)
                bdel_s = EXP(wv_s)
                wdel_s = EXP(fu_s)
                yw_s = SQRT(x2(i,k))
                zw_s = SQRT(x3(i,k))
                ww_s = ((h1p   + 32.2095e0_r8  * x1(i,k)) &
                     /  (h1p        + 52.85e0_r8      * x1(i,k)) &
                     +  (0.534874e0_r8 + 199.0e0_r8      * x1(i,k) &
                     -  1990.63e0_r8  * x1(i,k)      * x1(i,k)) &
                     *  zw_s &
                     / (h1p         + 333.244e0_r8    * x1(i,k))) &
                     / ((h1p        + 74.144e0_r8     * x1(i,k)) &
                     / (0.43368e0_r8   + 24.7442e0_r8    * x1(i,k)) &
                     * zw_s      + h1p)
                wv_s = (h1p   + 9.22411e0_r8  * yw_s &
                     + 33.1236e0_r8    * x2(i,k) &
                     + 176.396e0_r8    * x2(i,k)      * x2(i,k))
                wv_s = h1p   / wv_s
                ww_s = MAX(ww_s, h0p)
                wv_s = MAX(wv_s, h0p)
                x1_s = MIN(x1(i,k), 0.06e0_r8)
                x2_s = MIN(x2(i,k), 2.0e0_r8)
                x3_s = MIN(x3(i,k), 8.0e0_r8)
                yw_s = SQRT(x2_s)
                zw_s = SQRT(x3_s)
                fu_s = x1_s * x1_s
                yv_s = (0.0851069e0_r8 * yw_s        &
                     - 0.187096e0_r8   * x2_s  * yw_s &
                     + 0.323105e0_r8   * x2_s) * 0.1e0_r8
                zv_s = 0.239186e0_r8   * x2_s        &
                     - 0.0922289e0_r8  * x2_s  * yw_s &
                     - 0.0167413e0_r8  * x2_s  * x2_s
                zv_s = zv_s * 1.0e-3_r8
                yw_s = (5.6383e-4_r8    + 1.05173e0_r8  * x1_s &
                     - 39.0722e0_r8 * fu_s) &
                     / (h1p   + 202.357e0_r8  * x1_s) &
                     + (0.0779555e0_r8  + 4.40720e0_r8  * x1_s &
                     + 3.15851e0_r8 * fu_s)   * zw_s &
                     / (h1p   + 40.2298e0_r8  * x1_s) &
                     + (-0.0381305e0_r8 - 3.63684e0_r8  * x1_s &
                     + 7.98951e0_r8 * fu_s)   * x3_s &
                     / (h1p   + 62.5692e0_r8  * x1_s) &
                     + (6.21039e-3_r8 + 0.710061e0_r8 * x1_s &
                     - 2.85241e0_r8 * fu_s)   * x3_s &
                     / (h1p   + 70.2912e0_r8  * x1_s) &
                     * zw_s
                yw_s = 0.1e0_r8    * yw_s
                zw_s = (-2.99542e-4_r8 + 0.238219e0_r8 * x1_s &
                     + 0.519264e0_r8   * fu_s) &
                     / (h1p         + 10.7775e0_r8  * x1_s) &
                     + (-2.91325e-2_r8 - 2.30007e0_r8  * x1_s &
                     + 10.946e0_r8     * fu_s)   * zw_s &
                     / (h1p         + 63.519e0_r8   * x1_s) &
                     + (1.43812e-2_r8  + 1.80265e0_r8  * x1_s &
                     - 10.1311e0_r8    * fu_s)   * x3_s &
                     / (h1p         + 98.4758e0_r8  * x1_s) &
                     + (-2.39016e-3_r8 - 3.71427e-1_r8 * x1_s &
                     + 2.35443e0_r8    * fu_s)   * x3_s &
                     / (h1p         + 120.228e0_r8  * x1_s) &
                     * zw_s
                zw_s = 1.0e-3_r8   * zw_s
                adel_s = hp38 * adel_s + hp61 * bdel_s
                fw_s   = fw_s * wdel_s
                !
                yw(i,k) = yw_s
                ww(i,k) = ww_s
                yv(i,k) = yv_s
                wv(i,k) = wv_s
                fw(i,k) = fw_s
                zv(i,k) = zv_s
                adel(i,k)= adel_s
                zw(i,k) = zw_s
                x1(i,k) = x1_s
                x2(i,k) = x2_s
                x3(i,k) = x3_s
             END DO
          END DO

          IF (indx2 == 1) THEN
             DO k = 2, kmax+2
                DO i = 1, ncols
                   x1(i,k)   = wv(i,k-1) * tv1(i,1)
                   x2(i,k)   = yv(i,k-1) * tui(i,1) + h1p &
                        + zv(i,k-1)   * tui2(i,1)
                   x3(i,k)   = ww(i,k-1) * tv2(i,1)
                   x4(i,k)   = yw(i,k-1) * tui(i,1) + h1p &
                        + zw(i,k-1)   * tui2(i,1)
                   fw(i,k-1) = adel(i,k-1) * cc(i,1) &
                        + fw(i,k-1)   * rawi(i,1)
                END DO
             END DO

             DO k = 2, kmax+2
                DO i = 1, ncols
                   shi(i,k) = x1(i,k)*x2(i,k) + x3(i,k)*x4(i,k) + fw(i,k-1)
                END DO
             END DO

          ELSE

             DO k = 1, kmax+1
                DO i = 1, ncols
                   x1(i,k) =  wv(i,k) * tv1(i,(kmax+3)) &
                        * (yv(i,k) * tui(i,(kmax+3))  + h1p &
                        + zv(i,k)  * tui2(i,(kmax+3)))
                   x2(i,k) = ww(i,k)  * tv2(i,(kmax+3)) &
                        * (yw(i,k) * tui(i,(kmax+3))  + h1p &
                        +  zw(i,k) * tui2(i,(kmax+3)))
                   x3(i,k) =  wv(i,k) * tv1(i,(kmax+2)) &
                        * (yv(i,k) * tui(i,(kmax+2))    + h1p &
                        + zv(i,k)  * tui2(i,(kmax+2)))
                   x4(i,k) = ww(i,k)  * tv2(i,(kmax+2)) &
                        * (yw(i,k) * tui(i,(kmax+2))    + h1p &
                        +  zw(i,k) * tui2(i,(kmax+2)))
                   shu(i,k) = (cc(i,(kmax+3))-cc(i,(kmax+2)))*adel(i,k) &
                        + (rawi(i,(kmax+3)) - rawi(i,(kmax+2))) * fw(i,k)
                   shu(i,k) = x1(i,k) + x2(i,k) - x3(i,k) - x4(i,k) &
                        + shu(i,k)
                END DO
             END DO

          END IF
       ELSE
          IF (indx2 == (kmax+2)) THEN
             DO ip = indx1, indx2
                DO k = indx1, ip
                   DO i = 1, (ncols)
                      x1(i,k-1)   = ubar(i,ip) - ubarm(i,k)
                      x2(i,k-1)   = vbar(i,ip) - vbarm(i,k)
                      x3(i,k-1)   = wbar(i,ip) - wbarm(i,k)
                      adel(i,k-1) = tai(i,ip)  - css(i,k)
                      bdel(i,k-1) = ch(i,ip)   - ccu(i,k)
                      wdel(i,k-1) = fluxu(i,ip) - ozai(i,k)
                      fw(i,k-1)   = fluxd(i,ip) - pai(i,k)
                   END DO
                END DO
                DO k = 1, ip-1
                   DO i  = 1, ncols
                      x1_s = ABS(x1(i,k))
                      x2_s = ABS(x2(i,k))
                      x3_s = ABS(x3(i,k))
                      adel_s = ABS(adel(i,k))
                      bdel_s = ABS(bdel(i,k))
                      wdel_s = ABS(wdel(i,k))
                      fw_s = ABS(fw(i,k))
                      fu_s = h9p8 * x1_s
                      yw_s = EXP(LOG(x1_s + 1.0e-100_r8)*.83_r8)
                      ww_s = EXP(LOG(x3_s + 1.0e-100_r8)*.6_r8)
                      ww_s = h1p + h16p  * ww_s
                      ww_s = h6p7 * x3_s / ww_s
                      ww_s = h27p * yw_s + ww_s
                      yw_s = EXP(LOG(adel_s + 1.0e-100_r8)*.56_r8)
                      yw_s = h1p  + h15p1     * yw_s
                      yv_s = h3p1 * adel_s / yw_s
                      yv_s = yv_s       + ww_s
                      yw_s = EXP(LOG(bdel_s + 1.0e-100_r8)*.57_r8)
                      yw_s = h1p  + hp9       * yw_s
                      wv_s = hp04 * bdel_s / yw_s
                      wv_s = wv_s + ww_s
                      fw_s = fw_s / (wdel_s * h1013)
                      zv_s = h1381   * wdel_s  / (hp88 * fw_s)
                      adel_s = h1p   + zv_s
                      adel_s = SQRT(adel_s)
                      adel_s = h4p4 * fw_s * (adel_s - h1p)
                      zv_s = EXP(adel_s)
                      fw_s = h1p - hp677 * (h1p - zv_s)
                      adel_s = EXP(yv_s)
                      bdel_s = EXP(wv_s)
                      wdel_s = EXP(fu_s)
                      yw_s = SQRT(x2_s)
                      zw_s = SQRT(x3_s)
                      ww_s = ((h1p   + 32.2095e0_r8  * x1_s) &
                           /  (h1p        + 52.85e0_r8      * x1_s) &
                           +  (0.534874e0_r8 + 199.0e0_r8      * x1_s  &
                           -  1990.63e0_r8   * x1_s      * x1_s) &
                           *  zw_s     &
                           / (h1p         + 333.244e0_r8    * x1_s))&
                           / ((h1p        + 74.144e0_r8     * x1_s) &
                           / (0.43368e0_r8   + 24.7442e0_r8    * x1_s) &
                           * zw_s      + h1p)
                      wv_s = (h1p   + 9.22411e0_r8  * yw_s  &
                           + 33.1236e0_r8    * x2_s   &
                           + 176.396e0_r8    * x2_s      * x2_s)
                      wv_s = h1p   / wv_s
                      ww_s = MAX(ww_s, h0p)
                      wv_s = MAX(wv_s, h0p)
                      x1_s = MIN(x1_s, 0.06e0_r8)
                      x2_s = MIN(x2_s, 2.0e0_r8)
                      x3_s = MIN(x3_s, 8.0e0_r8)
                      yw_s = SQRT(x2_s)
                      zw_s = SQRT(x3_s)
                      fu_s = x1_s * x1_s
                      yv_s = (0.0851069e0_r8  * yw_s &
                           -  0.187096e0_r8 * x2_s  * yw_s &
                           +  0.323105e0_r8 * x2_s) * 0.1e0_r8
                      zv_s =  0.239186e0_r8   * x2_s &
                           -  0.0922289e0_r8  * x2_s  * yw_s &
                           -  0.0167413e0_r8  * x2_s  * x2_s
                      zv_s =  zv_s * 1.0e-3_r8
                      yw_s = (5.6383e-4_r8    + 1.05173e0_r8  * x1_s &
                           - 39.0722e0_r8 * fu_s) &
                           / (h1p   + 202.357e0_r8  * x1_s) &
                           + (0.0779555e0_r8  + 4.40720e0_r8  * x1_s  &
                           + 3.15851e0_r8 * fu_s)   * zw_s  &
                           / (h1p   + 40.2298e0_r8  * x1_s) &
                           + (-0.0381305e0_r8 - 3.63684e0_r8  * x1_s  &
                           + 7.98951e0_r8 * fu_s)   * x3_s  &
                           / (h1p   + 62.5692e0_r8  * x1_s) &
                           + (6.21039e-3_r8 + 0.710061e0_r8 * x1_s  &
                           - 2.85241e0_r8 * fu_s)   * x3_s  &
                           / (h1p   + 70.2912e0_r8  * x1_s) &
                           * zw_s
                      yw_s = 0.1e0_r8    * yw_s
                      zw_s = (-2.99542e-4_r8 + 0.238219e0_r8 * x1_s &
                           + 0.519264e0_r8   * fu_s) &
                           / (h1p         + 10.7775e0_r8  * x1_s) &
                           + (-2.91325e-2_r8 - 2.30007e0_r8  * x1_s &
                           + 10.946e0_r8     * fu_s)   * zw_s &
                           / (h1p         + 63.519e0_r8   * x1_s) &
                           + (1.43812e-2_r8  + 1.80265e0_r8  * x1_s &
                           - 10.1311e0_r8    * fu_s)   * x3_s &
                           / (h1p         + 98.4758e0_r8  * x1_s) &
                           + (-2.39016e-3_r8 - 3.71427e-1_r8 * x1_s &
                           + 2.35443e0_r8    * fu_s)   * x3_s &
                           / (h1p         + 120.228e0_r8  * x1_s) &
                           * zw_s
                      zw_s = 1.0e-3_r8   * zw_s
                      !
                      adel(i,k) = adel_s
                      bdel(i,k) = bdel_s
                      wdel(i,k) = wdel_s
                      fw(i,k)   = fw_s
                      !
                      ! fu(i,k) nao usa depois
                      yw(i,k)   = yw_s
                      ww(i,k)   = ww_s
                      yv(i,k)   = yv_s
                      wv(i,k)   = wv_s
                      zv(i,k)   = zv_s
                      zw(i,k)   = zw_s
                   END DO
                END DO
                DO k = 1, ip-1
                   DO i = 1, ncols
                      x1_s =  wv(i,k)  * tv1 (i,k) &
                           * (yv(i,k)  * tui (i,k)    + h1p &
                           +  zv(i,k)  * tui2(i,k))
                      x2_s =  ww(i,k)  * tv2 (i,k) &
                           * (yw(i,k)  * tui (i,k)    + h1p &
                           +  zw(i,k)  * tui2(i,k))
                      x3_s =  wv(i,k)  * tv1 (i,2+k-1) &
                           * (yv(i,k)  * tui (i,2+k-1) + h1p &
                           +  zv(i,k)  * tui2(i,2+k-1))
                      x4(i,k) =  ww(i,k)  * tv2 (i,2+k-1) &
                           * (yw(i,k)  * tui (i,2+k-1)   + h1p &
                           +  zw(i,k)  * tui2(i,2+k-1))
                      txuf(i,k,ip) =  x1_s  + x2_s &
                           -  x3_s      - x4(i,k) &
                           + (cc(i,1+k-1)    - cc(i,2+k-1)) &
                           * (hp38       * adel(i,k) &
                           +  hp61       * bdel(i,k)) &
                           + (rawi(i,1+k-1)  - rawi(i,2+k-1)) &
                           *  fw(i,k)      * wdel(i,k)
                      !
                      x1(i,k) = x1_s
                      x2(i,k) = x2_s
                      x3(i,k) = x3_s
                   END DO
                END DO
             END DO
          END IF


          IF (indx2 /= (kmax+2)) THEN
             DO ip = indx1, indx2
                DO k = indx1, (kmax+2)-ip
                   DO i = 1, (ncols)
                      x1(i,k-0)   = ubar(i,ip) - ubarm(i,k+ip)
                      x2(i,k-0)   = vbar(i,ip) - vbarm(i,k+ip)
                      x3(i,k-0)   = wbar(i,ip) - wbarm(i,k+ip)
                      adel(i,k-0) = tai(i,ip)  - css(i,k+ip)
                      bdel(i,k-0) = ch(i,ip) - ccu(i,k+ip)
                      wdel(i,k-0) = fluxu(i,ip) - ozai(i,k+ip)
                      fw(i,k-0)   = fluxd(i,ip) - pai(i,k+ip)
                   END DO
                END DO

                DO k = 1, (kmax+2)-ip
                   DO i  = 1, ncols
                      x1(i,k) = ABS(x1(i,k))
                      x2(i,k) = ABS(x2(i,k))
                      x3(i,k) = ABS(x3(i,k))
                      adel(i,k) = ABS(adel(i,k))
                      bdel(i,k) = ABS(bdel(i,k))
                      wdel(i,k) = ABS(wdel(i,k))
                      fw(i,k) = ABS(fw(i,k))
                      fu(i,k) = h9p8 * x1(i,k)
                      yw(i,k) = EXP(LOG(x1(i,k) + 1.0e-100_r8)*.83_r8)
                      ww(i,k) = EXP(LOG(x3(i,k) + 1.0e-100_r8)*.6_r8)
                      ww(i,k) = h1p + h16p  * ww(i,k)
                      ww(i,k) = h6p7 * x3(i,k) / ww(i,k)
                      ww(i,k) = h27p * yw(i,k) + ww(i,k)
                      yw(i,k) = EXP(LOG(adel(i,k) + 1.0e-100_r8)*.56_r8)
                      yw(i,k) = h1p  + h15p1  * yw(i,k)
                      yv(i,k) = h3p1 * adel(i,k) / yw(i,k)
                      yv(i,k) = yv(i,k)   + ww(i,k)
                      yw(i,k) = EXP(LOG(bdel(i,k) + 1.0e-100_r8)*.57_r8)
                      yw(i,k) = h1p  + hp9  * yw(i,k)
                      wv(i,k) = hp04 * bdel(i,k) / yw(i,k)
                      wv(i,k) = wv(i,k) + ww(i,k)
                      fw(i,k)    = fw(i,k) / (wdel(i,k) * h1013)
                      zv(i,k)    = h1381   * wdel(i,k)  / (hp88 * fw(i,k))
                      adel(i,k) = h1p      + zv(i,k)
                      adel(i,k) = SQRT(adel(i,k))
                      adel(i,k) = h4p4 * fw(i,k) * (adel(i,k) - h1p)
                      zv(i,k) = EXP(adel(i,k))
                      fw(i,k) = h1p - hp677 * (h1p - zv(i,k))
                      adel(i,k) = EXP(yv(i,k))
                      bdel(i,k) = EXP(wv(i,k))
                      wdel(i,k) = EXP(fu(i,k))
                      yw(i,k) = SQRT(x2(i,k))
                      zw(i,k) = SQRT(x3(i,k))
                      ww(i,k) = ((h1p      + 32.2095e0_r8    * x1(i,k)) &
                           /  (h1p   + 52.85e0_r8  * x1(i,k)) &
                           +  (0.534874e0_r8 + 199.0e0_r8  * x1(i,k)  &
                           -  1990.63e0_r8   * x1(i,k)  * x1(i,k)) &
                           *  zw(i,k)        &
                           / (h1p   + 333.244e0_r8  * x1(i,k)))&
                           / ((h1p   + 74.144e0_r8  * x1(i,k)) &
                           / (0.43368e0_r8   + 24.7442e0_r8  * x1(i,k)) &
                           * zw(i,k)   + h1p)
                      wv(i,k) = (h1p      + 9.22411e0_r8    * yw(i,k)  &
                           + 33.1236e0_r8    * x2(i,k)      &
                           + 176.396e0_r8    * x2(i,k)  * x2(i,k))
                      wv(i,k) = h1p      / wv(i,k)
                      ww(i,k) = MAX(ww(i,k), h0p)
                      wv(i,k) = MAX(wv(i,k), h0p)
                      x1(i,k) = MIN(x1(i,k), 0.06e0_r8)
                      x2(i,k) = MIN(x2(i,k), 2.0e0_r8)
                      x3(i,k) = MIN(x3(i,k), 8.0e0_r8)
                      yw(i,k) = SQRT(x2(i,k))
                      zw(i,k) = SQRT(x3(i,k))
                      fu(i,k) = x1(i,k) * x1(i,k)
                      yv(i,k) = (0.0851069e0_r8  * yw(i,k) &
                           -  0.187096e0_r8   * x2(i,k)  * yw(i,k) &
                           +  0.323105e0_r8   * x2(i,k)) * 0.1e0_r8
                      zv(i,k) =  0.239186e0_r8   * x2(i,k) &
                           -  0.0922289e0_r8  * x2(i,k)  * yw(i,k) &
                           -  0.0167413e0_r8  * x2(i,k)  * x2(i,k)
                      zv(i,k) =  zv(i,k) * 1.0e-3_r8

                      yw(i,k) = (5.6383e-4_r8    + 1.05173e0_r8  * x1(i,k) &
                           - 39.0722e0_r8     * fu(i,k)) &
                           / (h1p    + 202.357e0_r8  * x1(i,k)) &
                           + (0.0779555e0_r8  + 4.40720e0_r8  * x1(i,k)  &
                           + 3.15851e0_r8     * fu(i,k)) * zw(i,k)  &
                           / (h1p    + 40.2298e0_r8  * x1(i,k)) &
                           + (-0.0381305e0_r8 - 3.63684e0_r8  * x1(i,k)  &
                           + 7.98951e0_r8     * fu(i,k)) * x3(i,k)  &
                           / (h1p    + 62.5692e0_r8  * x1(i,k)) &
                           + (6.21039e-3_r8   + 0.710061e0_r8 * x1(i,k)  &
                           - 2.85241e0_r8     * fu(i,k)) * x3(i,k)  &
                           / (h1p    + 70.2912e0_r8  * x1(i,k)) &
                           * zw(i,k)
                      yw(i,k) = 0.1e0_r8       * yw(i,k)
                      zw(i,k) = (-2.99542e-4_r8 + 0.238219e0_r8 * x1(i,k) &
                           + 0.519264e0_r8   * fu(i,k)) &
                           / (h1p   + 10.7775e0_r8  * x1(i,k)) &
                           + (-2.91325e-2 - 2.30007e0_r8  * x1(i,k) &
                           + 10.946e0_r8   * fu(i,k))   * zw(i,k) &
                           / (h1p   + 63.519e0_r8   * x1(i,k)) &
                           + (1.43812e-2_r8  + 1.80265e0_r8  * x1(i,k) &
                           - 10.1311e0_r8    * fu(i,k))   * x3(i,k) &
                           / (h1p   + 98.4758e0_r8  * x1(i,k)) &
                           + (-2.39016e-3_r8 - 3.71427e-1_r8 * x1(i,k) &
                           + 2.35443e0_r8    * fu(i,k))   * x3(i,k) &
                           / (h1p   + 120.228e0_r8  * x1(i,k)) &
                           * zw(i,k)
                      zw(i,k) = 1.0e-3_r8       * zw(i,k)
                   END DO
                END DO

                DO k = 1, (kmax+2)-ip
                   DO i = 1, ncols
                      x1(i,k) =  wv(i,k)  * tv1 (i,ip+k) &
                           * (yv(i,k)  * tui (i,ip+k)  + h1p &
                           +  zv(i,k)  * tui2(i,ip+k))
                      x2(i,k) =  ww(i,k)  * tv2 (i,ip+k) &
                           * (yw(i,k)  * tui (i,ip+k)  + h1p &
                           +  zw(i,k)  * tui2(i,ip+k))
                      x3(i,k) =  wv(i,k)  * tv1 (i,ip+0+k-1) &
                           * (yv(i,k)  * tui (i,ip+0+k-1) + h1p &
                           +  zv(i,k)  * tui2(i,ip+0+k-1))
                      x4(i,k) =  ww(i,k)  * tv2 (i,ip+0+k-1) &
                           * (yw(i,k)  * tui (i,ip+0+k-1)   + h1p &
                           +  zw(i,k)  * tui2(i,ip+0+k-1))
                      txuf(i,ip+k,ip) =  x1(i,k)    + x2(i,k) &
                           -  x3(i,k)  - x4(i,k) &
                           + (cc(i,ip+1+k-1) - cc(i,ip+0+k-1)) &
                           * (hp38  * adel(i,k) &
                           +  hp61  * bdel(i,k)) &
                           + (rawi(i,ip+1+k-1)  - rawi(i,ip+0+k-1)) &
                           *  fw(i,k)  * wdel(i,k)
                   END DO
                END DO
             END DO
          END IF

       END IF
    ENDIF

    IF (.not.ozone) THEN
       IF (indx1 == indx2) THEN
          IF (indx2 == 1) THEN
             DO k = 1, kMax+1
                DO i = 1, ncols
                   x1(i,k) = ABS(ubar(i,k+1))
                   x2(i,k) = ABS(vbar(i,k+1))
                   x3(i,k) = ABS(wbar(i,k+1))
                   adel(i,k) = ABS(tai(i,k+1))
                   bdel(i,k) = ABS(ch(i,k+1))
                END DO
             END DO
          ELSE
             DO k = 1, kmax+1
                DO i = 1, ncols
                   x1(i,k)   = ubar(i,kmax+2) - ubar(i,k)
                   x2(i,k)   = vbar(i,kmax+2) - vbar(i,k)
                   x3(i,k)   = wbar(i,kmax+2) - wbar(i,k)
                   adel(i,k) = tai(i,kmax+2)  - tai(i,k)
                   bdel(i,k) = ch(i,kmax+2)   - ch(i,k)
                END DO
             END DO

             DO k = 1, kMax+1
                DO i = 1, ncols
                   x1(i,k) = ABS(x1(i,k))
                   x2(i,k) = ABS(x2(i,k))
                   x3(i,k) = ABS(x3(i,k))
                   adel(i,k) = ABS(adel(i,k))
                   bdel(i,k) = ABS(bdel(i,k))
                END DO
             END DO


          END IF
          DO k=1,(kmax+1)
             DO i = 1, (ncols)
                fu(i,k) = h9p8 * x1(i,k)
                yw(i,k) = EXP(LOG(x1(i,k) + 1.0e-100_r8)*.83_r8)
                ww(i,k) = EXP(LOG(x3(i,k) + 1.0e-100_r8)*.6_r8)
                ww(i,k) = h1p + h16p  * ww(i,k)
                ww(i,k) = h6p7 * x3(i,k) / ww(i,k)
                ww(i,k) = h27p * yw(i,k) + ww(i,k)
                yw(i,k) = EXP(LOG(adel(i,k) + 1.0e-100_r8)*.56_r8)
                yw(i,k) = h1p  + h15p1     * yw(i,k)
                yv(i,k) = h3p1 * adel(i,k) / yw(i,k)
                yv(i,k) = yv(i,k)       + ww(i,k)
                yw(i,k) = EXP(LOG(bdel(i,k) + 1.0e-100_r8)*.57_r8)
                yw(i,k) = h1p  + hp9       * yw(i,k)
                wv(i,k) = hp04 * bdel(i,k) / yw(i,k)
                wv(i,k) = wv(i,k) + ww(i,k)
             END DO
          END DO

          DO k=1,(kmax+1)
             DO i = 1, (ncols)
                fw(i,k) = h1p
             END DO
          END DO


          DO k = 1, kMax+1
             DO i = 1, ncols
                adel(i,k) = EXP(yv(i,k))
                bdel(i,k) = EXP(wv(i,k))
                wdel(i,k) = EXP(fu(i,k))
             END DO
          END DO

          DO k = 1, kMax+1
             DO i = 1, ncols
                yw(i,k) = SQRT(x2(i,k))
                zw(i,k) = SQRT(x3(i,k))
             END DO
          END DO

          DO k=1,(kmax+1)
             DO i = 1, (ncols)
                ww(i,k) = ((h1p   + 32.2095e0_r8  * x1(i,k)) &
                     /  (h1p        + 52.85e0_r8      * x1(i,k)) &
                     +  (0.534874e0_r8 + 199.0e0_r8      * x1(i,k) &
                     -  1990.63e0_r8   * x1(i,k)      * x1(i,k)) &
                     *  zw(i,k) &
                     / (h1p         + 333.244e0_r8    * x1(i,k))) &
                     / ((h1p        + 74.144e0_r8     * x1(i,k)) &
                     / (0.43368e0_r8   + 24.7442e0_r8    * x1(i,k)) &
                     * zw(i,k)      + h1p)
                wv(i,k) = (h1p   + 9.22411e0_r8  * yw(i,k) &
                     + 33.1236e0_r8    * x2(i,k) &
                     + 176.396e0_r8    * x2(i,k)      * x2(i,k))
                wv(i,k) = h1p   / wv(i,k)
             END DO
          END DO

          DO k = 1, kMax+1
             DO i = 1, ncols
                ww(i,k) = MAX(ww(i,k), h0p)
                wv(i,k) = MAX(wv(i,k), h0p)
                x1(i,k) = MIN(x1(i,k), 0.06e0_r8)
                x2(i,k) = MIN(x2(i,k), 2.0e0_r8)
                x3(i,k) = MIN(x3(i,k), 8.0e0_r8)
                yw(i,k) = SQRT(x2(i,k))
                zw(i,k) = SQRT(x3(i,k))
             END DO
          END DO
          DO k=1,(kmax+1)
             DO i = 1, (ncols)
                fu(i,k) = x1(i,k) * x1(i,k)
                yv(i,k) = (0.0851069e0_r8 * yw(i,k)        &
                     - 0.187096e0_r8   * x2(i,k)  * yw(i,k) &
                     + 0.323105e0_r8   * x2(i,k)) * 0.1e0_r8
                zv(i,k) = 0.239186e0_r8   * x2(i,k)        &
                     - 0.0922289e0_r8  * x2(i,k)  * yw(i,k) &
                     - 0.0167413e0_r8  * x2(i,k)  * x2(i,k)
                zv(i,k) = zv(i,k) * 1.0e-3_r8
                yw(i,k) = (5.6383e-4_r8    + 1.05173e0_r8  * x1(i,k) &
                     - 39.0722e0_r8 * fu(i,k)) &
                     / (h1p   + 202.357e0_r8  * x1(i,k)) &
                     + (0.0779555e0_r8  + 4.40720e0_r8  * x1(i,k) &
                     + 3.15851e0_r8 * fu(i,k))   * zw(i,k) &
                     / (h1p   + 40.2298e0_r8  * x1(i,k)) &
                     + (-0.0381305e0_r8 - 3.63684e0_r8  * x1(i,k) &
                     + 7.98951e0_r8 * fu(i,k))   * x3(i,k) &
                     / (h1p   + 62.5692e0_r8  * x1(i,k)) &
                     + (6.21039e-3_r8 + 0.710061e0_r8 * x1(i,k) &
                     - 2.85241e0_r8 * fu(i,k))   * x3(i,k) &
                     / (h1p   + 70.2912e0_r8  * x1(i,k)) &
                     * zw(i,k)
                yw(i,k) = 0.1e0_r8    * yw(i,k)
                zw(i,k) = (-2.99542e-4_r8 + 0.238219e0_r8 * x1(i,k) &
                     + 0.519264e0_r8   * fu(i,k)) &
                     / (h1p         + 10.7775e0_r8  * x1(i,k)) &
                     + (-2.91325e-2_r8 - 2.30007e0_r8  * x1(i,k) &
                     + 10.946e0_r8     * fu(i,k))   * zw(i,k) &
                     / (h1p         + 63.519e0_r8   * x1(i,k)) &
                     + (1.43812e-2_r8  + 1.80265e0_r8  * x1(i,k) &
                     - 10.1311e0_r8    * fu(i,k))   * x3(i,k) &
                     / (h1p         + 98.4758e0_r8  * x1(i,k)) &
                     + (-2.39016e-3_r8 - 3.71427e-1_r8 * x1(i,k) &
                     + 2.35443e0_r8    * fu(i,k))   * x3(i,k) &
                     / (h1p         + 120.228e0_r8  * x1(i,k)) &
                     * zw(i,k)
                zw(i,k) = 1.0e-3_r8   * zw(i,k)
             END DO
          END DO
          DO k=1,(kmax+1)
             DO i = 1, (ncols)
                adel(i,k) = hp38 * adel(i,k) + hp61 * bdel(i,k)
                fw(i,k)   = fw(i,k) * wdel(i,k)
             END DO
          END DO

          IF (indx2 == 1) THEN

             DO k = 2, (kmax+2)
                DO i = 1, (ncols)
                   x1(i,k)   = wv(i,k-1) * tv1(i,1)
                   x2(i,k)   = yv(i,k-1) * tui(i,1) + h1p &
                        + zv(i,k-1)   * tui2(i,1)
                   x3(i,k)   = ww(i,k-1) * tv2(i,1)
                   x4(i,k)   = yw(i,k-1) * tui(i,1) + h1p &
                        + zw(i,k-1)   * tui2(i,1)
                   fw(i,k-1) = adel(i,k-1) * cc(i,1) &
                        + fw(i,k-1)   * rawi(i,1)
                END DO
             END DO

             DO k = 2, (kmax+2)
                DO i = 1, (ncols)
                   shi(i,k) = x1(i,k)*x2(i,k) + x3(i,k)*x4(i,k) + fw(i,k-1)
                END DO
             END DO

          ELSE

             DO k = 1, (kmax+1)
                DO i = 1, (ncols)
                   x1(i,k) =  wv(i,k) * tv1(i,(kmax+3)) &
                        * (yv(i,k) * tui(i,(kmax+3))  + h1p &
                        + zv(i,k)  * tui2(i,(kmax+3)))
                   x2(i,k) = ww(i,k)  * tv2(i,(kmax+3)) &
                        * (yw(i,k) * tui(i,(kmax+3))  + h1p &
                        +  zw(i,k) * tui2(i,(kmax+3)))
                   x3(i,k) =  wv(i,k) * tv1(i,(kmax+2)) &
                        * (yv(i,k) * tui(i,(kmax+2))    + h1p &
                        + zv(i,k)  * tui2(i,(kmax+2)))
                   x4(i,k) = ww(i,k)  * tv2(i,(kmax+2)) &
                        * (yw(i,k) * tui(i,(kmax+2))    + h1p &
                        +  zw(i,k) * tui2(i,(kmax+2)))
                   shu(i,k) = (cc(i,(kmax+3))-cc(i,(kmax+2)))*adel(i,k) &
                        + (rawi(i,(kmax+3)) - rawi(i,(kmax+2))) * fw(i,k)
                END DO
             END DO
             DO k=1,(kmax+1)
                DO i = 1, (ncols)
                   shu(i,k) = x1(i,k) + x2(i,k) - x3(i,k) - x4(i,k) &
                        + shu(i,k)
                END DO
             END DO

          END IF
       ELSE
          DO ip = indx1, indx2

             IF (indx2 == (kmax+2)) THEN
                ip1 = ip
                n   = ip - 1
                i0  = 0
                i1  = 1
                i2  = 2
             ELSE
                ip1 = (kmax+2) - ip
                n   = ip1
                i0  = ip
                i1  = 0
                i2  = 0
             END IF

             DO k = indx1, ip1
                DO i = 1, (ncols)
                   x1(i,k-i1)   = ubar(i,ip) - ubarm(i,k+i0)
                   x2(i,k-i1)   = vbar(i,ip) - vbarm(i,k+i0)
                   x3(i,k-i1)   = wbar(i,ip) - wbarm(i,k+i0)
                   adel(i,k-i1) = tai(i,ip)  - css(i,k+i0)
                   bdel(i,k-i1) = ch(i,ip)   - ccu(i,k+i0)
                END DO
             END DO


             DO k = 1, n
                DO i  = 1, ncols
                   x1(i,k) = ABS(x1(i,k))
                   x2(i,k) = ABS(x2(i,k))
                   x3(i,k) = ABS(x3(i,k))
                   adel(i,k) = ABS(adel(i,k))
                   bdel(i,k) = ABS(bdel(i,k))
                END DO
             END DO

             DO k= 1, n
                DO i= 1, ncols
                   fu(i,k) = h9p8 * x1(i,k)
                   yw(i,k) = EXP(LOG(x1(i,k) + 1.0e-100_r8)*.83_r8)
                   ww(i,k) = EXP(LOG(x3(i,k) + 1.0e-100_r8)*.6_r8)
                   ww(i,k) = h1p + h16p  * ww(i,k)
                   ww(i,k) = h6p7 * x3(i,k) / ww(i,k)
                   ww(i,k) = h27p * yw(i,k) + ww(i,k)
                   yw(i,k) = EXP(LOG(adel(i,k) + 1.0e-100_r8)*.56_r8)
                   yw(i,k) = h1p  + h15p1     * yw(i,k)
                   yv(i,k) = h3p1 * adel(i,k) / yw(i,k)
                   yv(i,k) = yv(i,k)       + ww(i,k)
                   yw(i,k) = EXP(LOG(bdel(i,k) + 1.0e-100_r8)*.57_r8)
                   yw(i,k) = h1p  + hp9       * yw(i,k)
                   wv(i,k) = hp04 * bdel(i,k) / yw(i,k)
                   wv(i,k) = wv(i,k) + ww(i,k)
                END DO
             END DO


             DO k=1, n
                DO i = 1, ncols
                   fw(i,k) = h1p
                END DO
             END DO

             DO k = 1, n
                DO i = 1, ncols
                   adel(i,k) = EXP(yv(i,k))
                   bdel(i,k) = EXP(wv(i,k))
                   wdel(i,k) = EXP(fu(i,k))
                END DO
             END DO
             DO k = 1, n
                DO i = 1, ncols
                   yw(i,k) = SQRT(x2(i,k))
                   zw(i,k) = SQRT(x3(i,k))
                END DO
             END DO

             DO k = 1, n
                DO i = 1, ncols
                   ww(i,k) = ((h1p   + 32.2095e0_r8  * x1(i,k)) &
                        /  (h1p        + 52.85e0_r8      * x1(i,k)) &
                        +  (0.534874e0_r8 + 199.0e0_r8      * x1(i,k)  &
                        -  1990.63e0_r8   * x1(i,k)      * x1(i,k)) &
                        *  zw(i,k)     &
                        / (h1p         + 333.244e0_r8    * x1(i,k)))&
                        / ((h1p        + 74.144e0_r8     * x1(i,k)) &
                        / (0.43368e0_r8   + 24.7442e0_r8    * x1(i,k)) &
                        * zw(i,k)      + h1p)
                   wv(i,k) = (h1p   + 9.22411e0_r8  * yw(i,k)  &
                        + 33.1236e0_r8    * x2(i,k)   &
                        + 176.396e0_r8    * x2(i,k)      * x2(i,k))
                   wv(i,k) = h1p   / wv(i,k)
                END DO
             END DO

             DO k = 1, n
                DO i = 1, ncols
                   ww(i,k) = MAX(ww(i,k), h0p)
                   wv(i,k) = MAX(wv(i,k), h0p)
                   x1(i,k) = MIN(x1(i,k), 0.06e0_r8)
                   x2(i,k) = MIN(x2(i,k), 2.0e0_r8)
                   x3(i,k) = MIN(x3(i,k), 8.0e0_r8)
                   yw(i,k) = SQRT(x2(i,k))
                   zw(i,k) = SQRT(x3(i,k))
                END DO
             END DO

             DO k =1, n
                DO i = 1, ncols
                   fu(i,k) = x1(i,k) * x1(i,k)
                   yv(i,k) = (0.0851069e0_r8  * yw(i,k) &
                        -  0.187096e0_r8 * x2(i,k)  * yw(i,k) &
                        +  0.323105e0_r8 * x2(i,k)) * 0.1e0_r8
                   zv(i,k) =  0.239186e0_r8   * x2(i,k) &
                        -  0.0922289e0_r8  * x2(i,k)  * yw(i,k) &
                        -  0.0167413e0_r8  * x2(i,k)  * x2(i,k)
                   zv(i,k) =  zv(i,k) * 1.0e-3_r8

                   yw(i,k) = (5.6383e-4_r8    + 1.05173e0_r8  * x1(i,k) &
                        - 39.0722e0_r8 * fu(i,k)) &
                        / (h1p   + 202.357e0_r8  * x1(i,k)) &
                        + (0.0779555e0_r8  + 4.40720e0_r8  * x1(i,k)  &
                        + 3.15851e0_r8 * fu(i,k))   * zw(i,k)  &
                        / (h1p   + 40.2298e0_r8  * x1(i,k)) &
                        + (-0.0381305e0_r8 - 3.63684e0_r8  * x1(i,k)  &
                        + 7.98951e0_r8 * fu(i,k))   * x3(i,k)  &
                        / (h1p   + 62.5692e0_r8  * x1(i,k)) &
                        + (6.21039e-3_r8 + 0.710061e0_r8 * x1(i,k)  &
                        - 2.85241e0_r8 * fu(i,k))   * x3(i,k)  &
                        / (h1p   + 70.2912e0_r8  * x1(i,k)) &
                        * zw(i,k)
                   yw(i,k) = 0.1e0_r8    * yw(i,k)
                   zw(i,k) = (-2.99542e-4_r8 + 0.238219e0_r8 * x1(i,k) &
                        + 0.519264e0_r8   * fu(i,k)) &
                        / (h1p         + 10.7775e0_r8  * x1(i,k)) &
                        + (-2.91325e-2_r8 - 2.30007e0_r8  * x1(i,k) &
                        + 10.946e0_r8     * fu(i,k))   * zw(i,k) &
                        / (h1p         + 63.519e0_r8   * x1(i,k)) &
                        + (1.43812e-2_r8  + 1.80265e0_r8  * x1(i,k) &
                        - 10.1311e0_r8    * fu(i,k))   * x3(i,k) &
                        / (h1p         + 98.4758e0_r8  * x1(i,k)) &
                        + (-2.39016e-3_r8 - 3.71427e-1_r8 * x1(i,k) &
                        + 2.35443e0_r8    * fu(i,k))   * x3(i,k) &
                        / (h1p         + 120.228e0_r8  * x1(i,k)) &
                        * zw(i,k)
                   zw(i,k) = 1.0e-3_r8   * zw(i,k)
                END DO
             END DO

             DO k = 1, n
                DO i = 1, ncols
                   x1(i,k) =  wv(i,k)  * tv1 (i,i0+k) &
                        * (yv(i,k)  * tui (i,i0+k)    + h1p &
                        +  zv(i,k)  * tui2(i,i0+k))
                   x2(i,k) =  ww(i,k)  * tv2 (i,i0+k) &
                        * (yw(i,k)  * tui (i,i0+k)    + h1p &
                        +  zw(i,k)  * tui2(i,i0+k))
                   x3(i,k) =  wv(i,k)  * tv1 (i,i0+i2+k-1) &
                        * (yv(i,k)  * tui (i,i0+i2+k-1) + h1p &
                        +  zv(i,k)  * tui2(i,i0+i2+k-1))
                   x4(i,k) =  ww(i,k)  * tv2 (i,i0+i2+k-1) &
                        * (yw(i,k)  * tui (i,i0+i2+k-1)   + h1p &
                        +  zw(i,k)  * tui2(i,i0+i2+k-1))
                   txuf(i,i0+k,ip) =  x1(i,k)  + x2(i,k) &
                        -  x3(i,k)      - x4(i,k) &
                        + (cc(i,i0+1+k-1)    - cc(i,i0+i2+k-1)) &
                        * (hp38       * adel(i,k) &
                        +  hp61       * bdel(i,k)) &
                        + (rawi(i,i0+1+k-1)  - rawi(i,i0+i2+k-1)) &
                        *  fw(i,k)      * wdel(i,k)
                END DO
             END DO
          END DO
       END IF
    END IF
  END SUBROUTINE crunch




  ! lwflux :computes carbon dioxide and ozone fluxes and upward and downward
  !         fluxes txuf for water vapor; the transmittances are also
  !         calculated.



  SUBROUTINE lwflux(pai   ,tai   ,ozai  ,ubar  ,vbar  ,wbar  ,ubarm ,vbarm , &
       wbarm ,fluxu ,fluxd ,txuf  ,tv1   ,tv2   ,tui   ,x1    , &
       x2    ,cc    ,rawi  ,x3    ,x4    ,ch    ,dp    ,css   , &
       ccu   ,shi   ,shh   ,shu   ,sumsav,h0p   ,h1p   ,h1p5  , &
       hp5   ,dtb   ,dtbinv,pr    ,ntm1  ,ozone ,co2val, &
       ncols ,kmax  )
    !
    !==========================================================================
    !
    !   ncols......Number of grid points on a gaussian latitude circle
    !   kmax......Number of grid points at vertical
    !   co2val....co2val is wgne standard value in ppm "co2val = /345.0/
    !   h0p.......constant h0p = 0.0e0 fac converts to degrees / time step
    !   h1p.......constant h1p = 1.0e0 fac converts to degrees / time step
    !   h1p5......Fact converts absorption to rate in degrees/ time step
    !             constant h1p5   = 1.5e0
    !   hp5.......constant hp5    = 0.5e0
    !   dtb.......temperature increment in b250.  Constant dtb  = 5.0e0
    !   dtbinv....constant dtbinv = h1p / dtb
    !   pr(1).....constant pr(1)  = h1p / 3.0e01
    !   pr(1).....constant pr(2)  = h1p / 3.0e02
    !   ntm1......number of rows in b250 - 1. constant  ntm1   = 31
    !   ozone.....set ozone logical variable  ozone = (.NOT. noz)
    !             true if there is ozone  absorption computation
    !   txuf......1.used as matrix of g-functions for paths from each level
    !               to all other layers.
    !             2.used for transmission in co2 band.
    !             3.used for transmission in ozone band.
    !             4.in cldslw used for probability of clear line-of-sight
    !               from each level to all other layers for max overlap.
    !   tv1.......Working dimension
    !   tv2 ......Working dimension
    !   tui.......Working dimension
    !   x1........path water vapor(e-type) and working dimension
    !   x2........path water vapor(band-center) and working dimension
    !   cc........planck function at level temperature for co2 bands.
    !   rawi......water vapor amount in layer
    !   x3........path water vapor (band-wings) and working dimension
    !   x4........Working dimension
    !   ch........Probability of clear line-of-sight from level to top of
    !             the atmosphere.
    !   dp........Pressure difference between levels
    !   css.......Large scale cloud amount and working dimension
    !   ccu.......Cumulus cloud amount and working dimension
    !   shi.......Total transmission function (water vapor + CO2 + ozone)
    !             g-function for a path from level to top of atmosphere.
    !   shh.......planck function at level temperature for water vapor
    !              bands.
    !   shu.......Total transmission function (water vapor + CO2 + ozone)
    !             g-function for a path from level  of atmosphere to surface
    !   sumsav....
    !   pai.......Pressure at middle of layer
    !   tai.......Temperature at middle of layer
    !   ozai......ozone amount in layer.
    !   ubar......scaled water vapor path length in window.
    !   vbar......scaled water vapor path length in center.
    !   wbar......scaled water vapor path length in wing.
    !   ubarm.....ubarm(i,2) = (ubar(i,2) + ubar(i,1)) * hp5
    !   vbarm.... planck function at level temperature for ozone band.
    !   wbarm.... ubarm(i,2) = (ubar(i,2) + ubar(i,1)) * hp5
    !   fluxu.....Ozone path
    !   fluxd.....Ozone path mutiplicated by pressure
    !
    !==========================================================================
    INTEGER, INTENT(in   ) :: ncols
    INTEGER, INTENT(in   ) :: kmax
    REAL(KIND=r8),    INTENT(in   ) :: co2val
    REAL(KIND=r8),    INTENT(in   ) :: h0p
    REAL(KIND=r8),    INTENT(in   ) :: h1p
    REAL(KIND=r8),    INTENT(in   ) :: h1p5
    REAL(KIND=r8),    INTENT(in   ) :: hp5
    REAL(KIND=r8),    INTENT(in   ) :: dtb
    REAL(KIND=r8),    INTENT(in   ) :: dtbinv
    REAL(KIND=r8),    INTENT(in   ) :: pr(2)
    INTEGER, INTENT(in   ) :: ntm1
    LOGICAL, INTENT(in   ) :: ozone
    REAL(KIND=r8),    INTENT(inout  ) :: txuf  (ncols,kmax+2,kmax+2)
    REAL(KIND=r8),    INTENT(inout  ) :: tv1   (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(inout  ) :: tv2   (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(inout) :: tui   (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(inout  ) :: x1    (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(inout  ) :: x2    (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(inout  ) :: cc    (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(inout  ) :: rawi  (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(inout  ) :: x3    (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(inout  ) :: x4    (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(inout  ) :: ch    (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(in   ) :: dp    (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(inout  ) :: css   (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(inout  ) :: ccu   (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(inout  ) :: shi   (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(inout  ) :: shh   (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(inout  ) :: shu   (ncols,kmax+1)
    REAL(KIND=r8),    INTENT(inout  ) :: sumsav(ncols)

    REAL(KIND=r8),    INTENT(INOUT) :: pai   (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(INOUT) :: tai   (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(INOUT) :: ozai  (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: ubar  (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: vbar  (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: wbar  (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: ubarm (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: vbarm (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(IN   ) :: wbarm (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(INOUT) :: fluxu (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(INOUT) :: fluxd (ncols,kmax+2)



    REAL(KIND=r8)                   :: tui2  (ncols,kmax+3)
    REAL(KIND=r8)                   :: wdel  (ncols,kmax+1)
    REAL(KIND=r8)                   :: fw   (ncols,kmax+1)
    INTEGER                :: it    (ncols,kmax+3)


    !
    !     REAL(KIND=r8) constants
    !
    REAL(KIND=r8), PARAMETER :: hp25=0.26_r8
    REAL(KIND=r8), PARAMETER :: temp1=165.0_r8
    REAL(KIND=r8), PARAMETER :: h250p=250.0_r8
    REAL(KIND=r8), PARAMETER :: pp=1.0_r8

    INTEGER :: i
    INTEGER :: j
    INTEGER :: k
    INTEGER :: ix
    INTEGER :: ip
    INTEGER :: indx1
    INTEGER :: indx2

    DO i = 1, ncols
       shi(i,1) = h0p
    END DO

    DO k=1,(kmax+2)
       DO j=1,(kmax+2)
          DO i = 1, ncols
             txuf(i,j,k) = h0p
          END DO
       END DO
    END DO

    DO k=1,kmax+3
       DO i = 1, ncols
          rawi(i,k) = (tui(i,k) - temp1) * dtbinv + h1p5
          it(i,k)   = rawi(i,k)
       END DO
    END DO

    DO k = 1, kmax+3
       DO i = 1, ncols
          it(i,k) = MAX(1,MIN(it(i,k), ntm1))
       END DO
    END DO

    DO k=1,(kmax+3)
       DO i = 1, (ncols)
          rawi(i,k) = it  (i,k)  -  h1p
          rawi(i,k) = tui (i,k)  - (temp1 + rawi(i,k) * dtb)
          rawi(i,k) = rawi(i,k)  *  dtbinv
       END DO
    END DO

    DO k = 1, kmax+3
       DO i = 1, ncols
          IF(it(i,k) .LE. ntm1 )THEN
             x1(i,k)=b2501(it(i,k))
             x2(i,k)=b2501(it(i,k)+1)
          ENDIF
       END DO
    END DO

    DO k=1,(kmax+3)
       DO i = 1, (ncols)
          tv1(i,k) = x1(i,k) + (x2(i,k) - x1(i,k)) * rawi(i,k)
       END DO
    END DO

    DO k = 1, kmax+3
       DO i = 1, ncols
          IF(it(i,k) .LE. ntm1 )THEN
             x2(i,k)=b2502(it(i,k)+1)
             x1(i,k)=b2502(it(i,k))
          ENDIF
       END DO
    END DO

    DO k=1,(kmax+3)
       DO i = 1, (ncols)
          tv2(i,k) = x1(i,k) + (x2(i,k) - x1(i,k)) * rawi(i,k)
       END DO
    END DO

    DO k=1,(kmax+2)
       DO i = 1, (ncols)
          shh(i,k) = tv1(i,k) + tv2(i,k)
       END DO
    END DO

    DO i = 1, ncols
       sumsav(i) = tv1(i,(kmax+3)) + tv2(i,(kmax+3))
    END DO

    DO k=1,(kmax+3)
       DO i = 1, (ncols)
          tui (i,k)  = tui(i,k) - h250p
          tui2(i,k)  = tui(i,k) * tui(i,k)
       END DO
    END DO
    !
    !     carbon dioxide and ozone fluxes are calculated here.
    !
    DO k = 1, kmax+3
       DO i = 1, ncols
          IF(it(i,k) .LE. ntm1 )THEN
             x1(i,k)=blkco2(it(i,k)+1)
             x2(i,k)=blkco2(it(i,k))
          ENDIF
       END DO
    END DO

    DO k=1,(kmax+3)
       DO i = 1, (ncols)
          cc(i,k) = x2(i,k) + (x1(i,k) - x2(i,k)) * rawi(i,k)
       ENDDO
    END DO

    DO k = 1, kmax+3
       DO i = 1, ncols
          IF(it(i,k) .LE. ntm1 )THEN
             x2(i,k)=blkwin(it(i,k))
             x1(i,k)=blkwin(it(i,k)+1)
          ENDIF
       END DO
    END DO

    DO k=1,(kmax+3)
       DO i = 1, (ncols)
          rawi(i,k) = x2(i,k) + (x1(i,k) - x2(i,k)) * rawi(i,k)
       END DO
    END DO
    !
    !     compute transmittances in the 15 micron and 9.6 micron bands.
    !
    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          x1(i,k) = 2.5e-2_r8 * (tai(i,k+1) - 240.0e0_r8)
       END DO
    END DO

    ch(1:ncols,2:(kmax+2))=exp(x1(1:ncols,1:(kmax+1)))

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          x1(i,k) = 8.9e-3_r8 * (tai(i,k+1) - 240.0e0_r8)
       END DO
    END DO

    tai(1:ncols,2:(kmax+2))=exp(x1(1:ncols,1:(kmax+1)))

    DO i = 1, ncols
       tai(i,1) = h0p
       ch(i,1)  = h0p
    END DO

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          x1(i,k) = pai(i,k)
       END DO
    END DO

    DO k=1,kmax+1
       DO i = 1, ncols
          x1(i,k)=MAX(pp,x1(i,k))
       END DO
    END DO

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          fw(i,k) = x1(i,k) * pr(1)
       END DO
    END DO

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          x2(i,k) = EXP(0.85_r8* LOG(fw(i,k)))
       ENDDO
    END DO

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          tai(i,k+1) = x2(i,k) * tai(i,k+1)
          x1(i,k)  = x1(i,k) * pr(2)
       END DO
    END DO

    x1(1:(ncols*(kmax+1)),1) = sqrt(x1(1:(ncols*(kmax+1)),1))

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          ch(i,k+1) = x1(i,k) * ch(i,k+1)
          !
          !     hp25 = 0.26 for co2 = 330 ppmv
          !
          tai(i,k+1) = dp(i,k+1) * tai(i,k+1) * hp25 * co2val / 330.0_r8
          ch(i,k+1)  = dp(i,k+1) * ch (i,k+1) * hp25 * co2val / 330.0_r8
       END DO
    END DO

    DO ip = 2, (kmax+2)
       DO i = 1, ncols
          tai(i,ip) = tai(i,ip-1) + tai(i,ip)
          ch(i,ip)  = ch(i,ip-1)  + ch(i,ip)
       END DO
    END DO

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          css(i,k+1) = (tai(i,k+1)  + tai(i,k))  * hp5
          ccu(i,k+1) = ( ch(i,k+1)  +  ch(i,k))  * hp5
       END DO
    END DO

    IF ( ozone ) THEN

       DO i = 1, ncols
          fluxd(i,1) = h0p
       END DO

       DO k=1,(kmax+2)
          DO i = 1, (ncols)
             fluxu(i,k) = h0p
          END DO
       END DO

       DO k=1,(kmax+1)
          DO i = 1, (ncols)
             fluxd(i,k+1) = pai(i,k) * ozai(i,k+1)
          END DO
       END DO

       DO ix = 2, (kmax+2)
          DO i = 1, ncols
             fluxd(i,ix) = fluxd(i,ix-1) + fluxd(i,ix)
             fluxu(i,ix) = fluxu(i,ix-1) + ozai(i,ix)
          END DO
       END DO

       DO k = 1, (kmax+1)
          DO i = 1, (ncols)
             pai (i,k+1)  = (fluxd(i,k) + fluxd(i,k+1)) * hp5
             ozai(i,k+1)  = (fluxu(i,k) + fluxu(i,k+1)) * hp5
          ENDDO
       END DO

       DO k=1,kmax+1
          DO i=1, ncols
             wdel(i,k)=ABS(fluxu(i,k+1))
             fw(i,k)= ABS(fluxd(i,k+1))
          END DO
       END DO
    END IF
    indx1 = 1
    indx2 = 1
    CALL crunch(indx1 ,indx2 ,ncols  ,kmax  ,h0p   ,h1p   ,ozone ,txuf  , &
         tv1   ,tv2   ,tui   ,tui2  ,x1    ,x2    ,cc    ,rawi  , &
         x3    ,x4    ,ch    ,css   ,ccu   ,shi   ,shu   ,wdel  , &
         fw    ,pai   ,tai   ,ozai  ,ubar  ,vbar  ,wbar  ,ubarm , &
         vbarm ,wbarm ,fluxu ,fluxd )
    indx1 = 2
    indx2 = 2
    CALL crunch(indx1 ,indx2 ,ncols ,kmax  ,h0p   ,h1p   ,ozone ,txuf  , &
         tv1   ,tv2   ,tui   ,tui2  ,x1    ,x2    ,cc    ,rawi  , &
         x3    ,x4    ,ch    ,css   ,ccu   ,shi   ,shu   ,wdel  , &
         fw    ,pai   ,tai   ,ozai  ,ubar  ,vbar  ,wbar  ,ubarm , &
         vbarm ,wbarm ,fluxu ,fluxd )

    !
    !     downward flux txuf for water vapor
    !

    indx1 = 2
    indx2 = (kmax+2)
    CALL crunch(indx1 ,indx2 ,ncols ,kmax  ,h0p   ,h1p   ,ozone ,txuf  , &
         tv1   ,tv2   ,tui   ,tui2  ,x1    ,x2    ,cc    ,rawi  , &
         x3    ,x4    ,ch    ,css   ,ccu   ,shi   ,shu   ,wdel  , &
         fw    ,pai   ,tai   ,ozai  ,ubar  ,vbar  ,wbar  ,ubarm , &
         vbarm ,wbarm ,fluxu ,fluxd )
    !
    !     upward flux txuf for water vapor
    !
    indx1 = 1
    indx2 = (kmax+1)

    CALL crunch(indx1 ,indx2 ,ncols  ,kmax  ,h0p   ,h1p   ,ozone ,txuf  , &
         tv1   ,tv2   ,tui   ,tui2  ,x1    ,x2    ,cc    ,rawi  , &
         x3    ,x4    ,ch    ,css   ,ccu   ,shi   ,shu   ,wdel  , &
         fw    ,pai   ,tai   ,ozai  ,ubar  ,vbar  ,wbar  ,ubarm , &
         vbarm ,wbarm ,fluxu ,fluxd )

    DO k = 1,(kmax+2)
       DO i = 1, (ncols)
          shh(i,k) = shh(i,k) + rawi(i,k) + cc(i,k)
       END DO
    END DO

    DO i = 1, ncols
       sumsav(i) = sumsav(i) + rawi(i,(kmax+3)) + cc(i,(kmax+3))
    END DO
  END SUBROUTINE lwflux



  !cldslw:  Estimate a contribution from cloudiness
  !    Using cloud amount of large scale (css) and and  cumulus(ccu) clouds



  SUBROUTINE cldslw(ncols ,kmax  ,nlcs  ,h1p   ,cs    ,x1    , &
       x2    ,cc    ,x3    ,x4    ,ch    ,css   ,ccu)
    !
    !==========================================================================
    !  imax.......Number of grid points on a gaussian latitude circle
    !  kmax.......Number of grid points at vertical
    !  nlcs.......nlcs=30
    !  h1p........h1p    = 1.0e0      fac converts to degrees / time step
    !  cs.........probability of clear line-of-sight from each level to
    !             all other layers.
    !  x1.........Water vapor path (e-type ) and working dimension
    !  x2.........Water vapor path (band-center) and working dimension
    !  cc.........planck function at level temperature for co2 bands.
    !  x3.........water vapor path (band-wings), working dimension
    !  x4.........Working dimension
    !  ch.........probability of clear line-of-sight from level to top of
    !             the atmosphere.
    !  css........Large scale cloud amount
    !             css=css*(1-exp(-0.01*dp)) for ice cloud t < 253.0
    !  ccu........Cumulus cloud amount
    !=========================================================================!
    ! >>> icld=1     : old cloud emisivity setting                           !
    !       ccu = ccu*(1-exp(-0.05*dp))                                      !
    !       css = css*(1-exp(-0.01*dp))          for ice cloud t<253.0       !
    !       css = css*(1-exp(-0.05*dp))          for     cloud t>253.0       !
    ! >>> icld=2     : new cloud emisivity setting                           !
    !       ccu = 1.0-exp(-0.12*ccu*dp)                                      !
    !       css = 0.0                                    for  t<-82.5c        !
    !       css = 1-exp(-1.5e-6*(t-tcrit)**2*css*dp)     for -82.5<t<-10.0    !
    !       css = 1-exp(-5.2e-3*(t-273.)-0.06)*css*dp)   for -10.0<t< 0.0     !
    !       css = 1-exp(-0.06*css*dp)                    for t> 0.0c          !
    ! >>> icld = 3   : ccm3 based cloud emisivity                             !
    !=========================================================================!
    !==========================================================================

    INTEGER, INTENT(in   ) :: ncols
    INTEGER, INTENT(in   ) :: kmax
    INTEGER, INTENT(in   ) :: nlcs
    REAL(KIND=r8),    INTENT(in   ) :: h1p
    REAL(KIND=r8),    INTENT(inout  ) :: cs  (ncols,kmax+2,nlcs)
    REAL(KIND=r8),    INTENT(inout  ) :: x1  (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(inout  ) :: x2  (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(inout  ) :: cc  (ncols,kmax+3)
    REAL(KIND=r8),    INTENT(inout  ) :: x3  (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(inout  ) :: x4  (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(inout  ) :: ch  (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(in   ) :: css (ncols,kmax+2)
    REAL(KIND=r8),    INTENT(in   ) :: ccu (ncols,kmax+2)

    INTEGER :: i
    INTEGER :: k
    INTEGER :: j
    INTEGER :: ip
    INTEGER :: il
    INTEGER :: ix
    INTEGER :: ipm1
    INTEGER :: ipp1

    DO k=1,(kmax+2)
       DO i=1,(ncols)
          ch(i,k) = h1p
          cc(i,k) = h1p
          x1(i,k) = h1p
          x2(i,k) = h1p
          x3(i,k) = h1p
       END DO
    END DO

    DO k=1,(kmax+2)
       DO j=1,(kmax+2)
          DO i=1,(ncols)
             cs(i,j,k) = h1p
          END DO
       END DO
    END DO

    DO ip=2,(kmax+2)
       DO i=1,ncols
          x1(i,ip) = h1p - ccu(i,ip-1)
       END DO

       DO i=1,ncols
          x1(i,ip)=MIN(x1(i,ip),x1(i,ip-1))
       END DO
       DO i=1,ncols
          ch(i,ip) = ch(i,ip-1) * (h1p - css(i,ip-1))
       END DO
    END DO

    DO k=1,(kmax+1)
       DO i=1,(ncols)
          ch(i,k+1) = ch(i,k+1) * x1(i,k+1)
       END DO
    END DO

    DO il=1,(kmax+1)
       ip=(kmax+2)-il
       DO i=1,ncols
          x2(i,ip) = h1p - ccu(i,ip)
       END DO

       DO i=1,ncols
          x2(i,ip)=MIN(x2(i,ip),x1(i,ip+1))
       END DO

       DO i=1,ncols
          cc(i,ip) = cc(i,ip+1) * (h1p - css(i,ip))
       END DO
    END DO

    DO k=1,(kmax+1)
       DO i=1,(ncols)
          cc(i,k) = cc(i,k) * x2(i,k)
       END DO
    END DO

    DO ip=2,(kmax+2)
       ipm1   = ip - 1

       DO ix=1,ipm1
          DO i=1,ncols
             x4(i,ix)    = h1p - ccu(i,ip-1)
             cs(i,ix,ip) = cs(i,ix,ip-1) * (h1p - css(i,ip-1))
          END DO
       END DO

       IF (ip .GT. 2) THEN
          DO j=1,ipm1
             DO i=1,ncols
                cs(i,j,ip-1) = cs(i,j,ip-1) * x3(i,j)
             END DO
          END DO
       END IF

       DO k=1,ipm1
          DO i=1,ncols
             x4(i,k)=MIN(x4(i,k),x3(i,k))
             x3(i,k) = x4(i,k)
          END DO
       END DO

    END DO

    DO j=1,ipm1
       DO i=1,ncols
          cs(i,j,(kmax+2)) = cs(i,j,(kmax+2)) * x4(i,j)
       END DO
    END DO

    DO k=1,kmax+2
       DO i=1,ncols
          x3(i,k) = h1p
       END DO
    END DO

    DO il=1,(kmax+1)
       ip   = (kmax+2) - il
       ipp1 = ip + 1

       DO ix=ipp1,(kmax+2)
          DO i=1,ncols
             x4(i,ix)    = h1p - ccu(i,ip)
             cs(i,ix,ip) = cs(i,ix,ip+1) * (h1p - css(i,ip))
          END DO
       END DO

       IF (il .GT. 1) THEN
          DO k=ip,((kmax+1)-ip)! DO k=ip,((kmax+2)-ip)
             DO  i=1, ncols
                cs(i,k+2,ip+1) = cs(i,k+2,ip+1) * x3(i,k+2)
             END DO
          END DO
       END IF

       DO k=ipp1,((kmax+2)-ip)
          DO i=1,ncols
             x4(i,j) = MIN(x4(i,j),x3(i,j))
             x3(i,k) = x4(i,k)
          END DO
       END DO

    END DO

    DO k=ipp1,((kmax+2)-ip)
       DO i=1, ncols
          cs(i,k,ip) = cs(i,k,ip) * x4(i,k)
       END DO
    END DO

  END SUBROUTINE cldslw




  ! lwrad  :compute upward and downward fluxes.



  SUBROUTINE lwrad(dtc3  ,noz   ,icld  ,tg    ,pl20  ,pl    ,tl    ,ql    , &
       o3l   ,cld   ,clu   ,ulwclr,ulwtop,atlclr,atl   ,rsclr , &
       rs    ,dlwclr,dlwbot,clwp  ,fice  ,rei   ,emisd ,co2val, &
       ncols ,kmax  ,nls   ,nlcs                                 )
    IMPLICIT NONE
    ! input variables
    !
    !     dtc3,  noz,  pl,  pl20, tl,  tg,  ql,  o3l,  cld,  clu
    !
    !     output variables
    !
    !     atl, atlclr,  rs,  rsclr, ulwtop, ulwclr, dlwbot, dlwclr
    !
    !     parameter list variables
    !
    !     nim......number of grid points around a latitude circle.
    !     nlm......number of model layers.
    !     nlmp1....nlm plus one.
    !     nlmp2....nlm plus two.
    !     nlmp3....nlm plus three.
    !     nls......number of layers in the stratosphere.
    !
    ! local variables
    !
    !     b250.....planck function table for water vapor bands; center and
    !              wing.
    !     ntm1.....number of rows in b250 - 1.
    !     temp1....lowest temperature for which b250 is tabulated.
    !     dtb......temperature increment in b250.
    !     nup1.....number of columns in gl and coeff.
    !     ubar.....scaled water vapor path length in window.
    !     vbar.....scaled water vapor path length in center.
    !     wbar.....scaled water vapor path length in wing.
    !     rawi.....water vapor amount in layer.
    !     ozai.....ozone amount in layer.
    !     shh......planck function at level temperature for water vapor
    !              bands.
    !     shi......g-function for a path from level to top of atmosphere.
    !     txuf.....1.used as matrix of g-functions for paths from each level
    !                to all other layers.
    !              2.used for transmission in co2 band.
    !              3.used for transmission in ozone band.
    !              4.in cldslw used for probability of clear line-of-sight
    !                from each level to all other layers for max overlap.
    !     wv,ww....interpolated value of gl for band center and wing
    !              respectively.
    !     yv,yw....linear term in temperature correction for band center
    !              and wing respectively.
    !     zv,zw....quadratic term in temperature correction for band center
    !              and wing respectively.
    !     blkco2...planck function table for co2 bands.
    !     blkwin...planck function table for ozone band.
    !     cc.......planck function at level temperature for co2 bands.
    !     vbarm....planck function at level temperature for ozone band.
    !     pp.......doppler broadening cut-off.
    !     pscalv...scaled co2 amount in band center.
    !     pscalw...scaled co2 amount in band wing.
    !     dx.......parameterized optical depth of water vapor line in co2
    !              band wing.
    !     dy.......parameterized optical depth of water vapor continuum in
    !              co2 band wing, also used for ozone band wing.
    !     sv,sw....minimum in table of log water vapor amount in band center
    !              and wing respectively.
    !     cs.......probability of clear line-of-sight from each level to
    !              all other layers.
    !     ch.......probability of clear line-of-sight from level to top of
    !              the atmosphere.
    !     cc.......probability of clear line-of-sight from level to surface.
    !     ct.......probability of clear line-of-sight from level to top of
    !              atmosphere for maximun overlap.
    !     cu.......probability of clear line-of-sight from level to surface
    !              for maximum overlap.
    !
    !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
    ! >>> icld=1     : old cloud emisivity setting                      c
    !       ccu = ccu*(1-exp(-0.05*dp))                                 c
    !       css = css*(1-exp(-0.01*dp))          for ice cloud t<253.0  c
    !       css = css*(1-exp(-0.05*dp))          for     cloud t>253.0  c
    ! >>> icld=2     : new cloud emisivity setting                      c
    !       ccu = 1.0-exp(-0.12*ccu*dp)                                 c
    !       css = 0.0                                for  t<-82.5c      c
    !       css = 1-exp(-1.5e-6*(t-tcrit)**2*css*dp) for -82.5<t<-10.0c c
    !       css = 1-exp(-5.2e-3*(t-273.)-0.06)*css*dp)for -10.0<t< 0.0c c
    !       css = 1-exp(-0.06*css*dp)                 for t> 0.0c       c
    ! >>> icld = 3   : ccm3 based cloud emisivity                       c
    !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
    !
    ! ncols......Number of grid points on a gaussian latitude circle
    ! kmax......Number of grid points at vertical
    ! nls.......number of layers in the stratosphere.
    ! nlcs......nlcs=30
    ! dtc3......constants dtc3=1.0e0
    ! noz.......constant logical noz = .FALSE.
    ! tg........Surface Temperature (K)
    ! pl20......pl20(i,k)=gps(i)*sigml(kflip) where
    !                         gps   =  surface pressure   (mb)
    !                         sigml =  sigma coordinate at bottom of layer
    ! pl........Pressure at Middle of Layer(mb)
    ! tl........Temperature at middle of Layer (K)
    ! ql........Specific Humidity at middle of layer (g/g)
    ! o3l.......Ozone Mixing ratio at middle of layer (g/g)
    ! cld.......Large scale cloud amount in layers
    ! clu.......Cumulus cloud amount in layers
    ! ulwclr....Upward flux at top in clear case (W/m2)
    ! ulwtop....Upward flux at top (W/m2)
    ! atlclr....Heating rate in clear case (K/s)
    ! atl.......Heating rate (K/s)
    ! rsclr.....Net surface flux in clear case (W/m2 )
    ! rs........Net surface flux
    ! dlwclr....Downward flux at surface in clear case (W/m2 )
    ! dlwbot....Downward flux at surface (W/m2 )
    ! clwp
    ! fice......controle of change of fase of water
    ! rei.......determine rei as function of normalized pressure
    ! emisd.....emis(i,kflip) = 1.- EXP(-1.66*rkabs(i,k)*clwp(i,k))
    ! co2val....co2val is wgne standard value in ppm "co2val = /345.0/
    !
    INTEGER, INTENT(in   ) :: ncols
    INTEGER, INTENT(in   ) :: kmax
    INTEGER, INTENT(in   ) :: nls
    INTEGER, INTENT(in   ) :: nlcs

    !
    !     needed for the ncar optical properties
    !
    REAL(KIND=r8),    INTENT(in   ) :: dtc3
    LOGICAL, INTENT(in   ) :: noz
    INTEGER, INTENT(in   ) :: icld
    REAL(KIND=r8),    INTENT(in   ) :: tg    (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: pl20  (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: pl    (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: tl    (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: ql    (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: o3l   (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: cld   (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: clu   (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: ulwclr(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: ulwtop(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: atlclr(ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: atl   (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: rsclr (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rs    (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dlwclr(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dlwbot(ncols)
    REAL(KIND=r8),    INTENT(in   ) :: clwp  (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: fice  (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: rei   (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: emisd (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: co2val


    REAL(KIND=r8)    :: txuf  (ncols,kmax+2,kmax+2)
    REAL(KIND=r8)    :: cs    (ncols,kmax+2,nlcs)
    REAL(KIND=r8)    :: tv1   (ncols,kmax+3)
    REAL(KIND=r8)    :: tv2   (ncols,kmax+3)
    REAL(KIND=r8)    :: tui   (ncols,kmax+3)
    REAL(KIND=r8)    :: x1    (ncols,kmax+3)
    REAL(KIND=r8)    :: x2    (ncols,kmax+3)
    REAL(KIND=r8)    :: cc    (ncols,kmax+3)
    REAL(KIND=r8)    :: rawi  (ncols,kmax+3)
    REAL(KIND=r8)    :: x3    (ncols,kmax+2)
    REAL(KIND=r8)    :: x4    (ncols,kmax+2)
    REAL(KIND=r8)    :: ch    (ncols,kmax+2)
    REAL(KIND=r8)    :: dp    (ncols,kmax+2)
    REAL(KIND=r8)    :: css   (ncols,kmax+2)
    REAL(KIND=r8)    :: ccu   (ncols,kmax+2)
    REAL(KIND=r8)    :: shi   (ncols,kmax+2)
    REAL(KIND=r8)    :: shh   (ncols,kmax+2)
    REAL(KIND=r8)    :: shu   (ncols,kmax+1)
    REAL(KIND=r8)    :: suma  (ncols)
    REAL(KIND=r8)    :: sumsav(ncols)
    LOGICAL :: bitx  (ncols*(kmax+3))


    REAL(KIND=r8) :: pai   (ncols,kmax+2)
    REAL(KIND=r8) :: tai   (ncols,kmax+2)
    REAL(KIND=r8) :: ozai  (ncols,kmax+2)
    REAL(KIND=r8) :: ubar  (ncols,kmax+2)
    REAL(KIND=r8) :: vbar  (ncols,kmax+2)
    REAL(KIND=r8) :: wbar  (ncols,kmax+2)
    REAL(KIND=r8) :: ubarm (ncols,kmax+2)
    REAL(KIND=r8) :: vbarm (ncols,kmax+2)
    REAL(KIND=r8) :: wbarm (ncols,kmax+2)
    REAL(KIND=r8) :: fluxu (ncols,kmax+2)
    REAL(KIND=r8) :: fluxd (ncols,kmax+2)


    REAL(KIND=r8)      :: h0p
    REAL(KIND=r8)      :: h1p
    REAL(KIND=r8)      :: h1p5
    REAL(KIND=r8)      :: hp5
    REAL(KIND=r8)      :: dtb
    REAL(KIND=r8)      :: dtbinv
    REAL(KIND=r8)      :: pr(2)
    INTEGER   :: ntm1
    INTEGER   :: imnpnp
    LOGICAL   :: ozone

    REAL(KIND=r8)      :: emis (ncols,kmax)
    REAL(KIND=r8)      :: emis1(ncols,kmax+2)
    REAL(KIND=r8)      :: rkabs(ncols,kmax)

    REAL(KIND=r8)      :: h1p02
    REAL(KIND=r8)      :: h6p08
    REAL(KIND=r8)      :: tice

    INTEGER  :: ls1
    INTEGER  :: ls2
    INTEGER  :: imls1
    INTEGER  :: imlsm1
    INTEGER  :: imlm1
    INTEGER  :: imt2
    INTEGER  :: npmls1
    INTEGER  :: npmls2
    INTEGER  :: i
    INTEGER  :: ip
    INTEGER  :: ipm1
    INTEGER  :: ix
    INTEGER  :: ipp1
    INTEGER  :: l
    INTEGER  :: k
    INTEGER  :: kflip
    REAL(KIND=r8)     :: fac
    REAL(KIND=r8)     :: h3ppm
    REAL(KIND=r8)     :: tcrit
    REAL(KIND=r8)     :: ecrit
    REAL(KIND=r8)     :: d642
    REAL(KIND=r8)     :: pre   (2)

    h1p02 =   1.02e0_r8
    h6p08 =   6.0811e0_r8
    tice  = 273.16_r8
    !
    !     copy parameters into local variables
    !
    ls1    = nls+1
    ls2    = nls+2
    imls1  = ncols*ls1
    imlsm1 = ncols*(nls-1)
    imnpnp = (ncols*(kmax+2))*(kmax+2)
    imlm1  = ncols*(kmax-1)
    imt2   = ncols*2
    npmls1 = ncols* ((kmax+2) - ls1)
    npmls2 = ncols* ((kmax+2) - ls2)
    !
    !     fac converts to degrees / time step
    !
    fac    = 9.8e-1_r8 * dtc3 / 1.0030e04_r8
    h1p    = 1.0e0_r8
    h0p    = 0.0e0_r8
    h1p5   = 1.5e0_r8
    hp5    = 0.5e0_r8
    h3ppm  = 3.0e-6_r8
    tcrit  = tice - 82.5_r8
    ecrit  = 0.007884375_r8
    ntm1   = 31
    dtb    = 5.0e0_r8
    dtbinv = h1p / dtb
    pre(1) = h1p / 2.75e02_r8
    pre(2) = h1p / 5.5e02_r8
    d642   = h1p / 6.426e02_r8
    pr(1)  = h1p / 3.0e01_r8
    pr(2)  = h1p / 3.0e02_r8
    emis1  = 0.0e0_r8
    !
    !     set ozone logical variable
    !
    ozone = (.NOT. noz)
    !
    !     ptop and dp at top don't change
    !
    DO i = 1, ncols
       dp (i,1)     = h0p
       x1 (i,1)     = h1p
       dp (i,2)     = h1p
       pai(i,1)     = hp5
    END DO

    DO k=1,((kmax+2) - (nls+1))
       DO i = 1, ncols
          rawi(i,nls+1+k) = ql(i,nls+k-1)
       END DO
    END DO

    IF (nls > 1) THEN
       DO k = 1,(nls-1)
          DO i = 1, ncols
             rawi(i,2+k) = h3ppm
          END DO
       END DO
    END IF

    DO k=1,kmax
       DO i = 1, ncols
          pai(i,k+1) = pl(i,k)
          tai(i,k+2) = tl(i,k)
          x1 (i,k+1) = pl20(i,k)
       END DO
    END DO

    DO i = 1, ncols
       pai(i,(kmax+2)) = pl20(i,kmax)
    END DO

    IF ( ozone ) THEN
       DO k = 1,kmax
          DO i = 1, (ncols)
             ozai(i,k+2) = o3l(i,k)
          END DO
       END DO
    END IF

    DO k = 1,kmax
       DO i = 1, ncols
          dp(i,k+2) = x1(i,k+1) - x1(i,k)
       END DO
    END DO
    !
    !     temperature and humidity interpolations
    !
    DO k = 1,kmax
       DO i = 1, ncols
          rawi(i,k+2)=MAX(0.1e-22_r8,rawi(i,k+2))
       END DO
    END DO

    IF ( ozone ) THEN

       DO k = 1,kmax
          DO i = 1, ncols
             ozai(i,k+2)=MAX(0.1e-9_r8,ozai(i,k+2))
          END DO
       END DO

       DO i = 1, ncols
          ozai(i,1) = h0p
          ozai(i,2) = ozai(i,3) * dp(i,2) * h1p02
       END DO

       DO k = 1,kmax
          DO  i = 1, ncols
             ozai(i,k+2) = ozai(i,k+2) * dp(i,k+2)  * h1p02
          END DO
       END DO

    END IF
    !
    !     do temperature interpolation
    !
    DO i = 1, ncols
       rawi(i,1) = h0p
       rawi(i,2) = h3ppm * dp(i,2) * h1p02
    END DO

    DO k=1,kmax
       DO i = 1, ncols
          rawi(i,k+2) = rawi(i,k+2) * dp(i,k+2) * h1p02
          x1(i,k)   = x1(i,k+1) / pai(i,k+1)
       END DO
    END DO

    x2(1:ncols,1:kmax)=LOG(x1(1:ncols,1:kmax))

    DO k = 1,kmax
       DO i = 1, ncols
          x1(i,k)   = pai(i,k+2) / pai(i,k+1)
       END DO
    END DO

    x4(1:ncols,1:kmax)=LOG(x1(1:ncols,1:kmax))

    DO k=1,(kmax-1)
       DO i = 1, ncols
          tui(i,k+2) = tai(i,k+2)  + x2(i,k) / x4(i,k) &
               * (tai(i,k+3) - tai(i,k+2))
       END DO
    END DO
    !
    !     set surface air temperature as mean of lowest layer t and tg
    !
    DO i = 1, ncols
       tui(i,(kmax+2)) = hp5 * ( tai(i,(kmax+2)) + tg(i) )
       tui(i,(kmax+3)) = tg(i)
       tai(i,1)        = tai(i,3)
       tai(i,2)        = tai(i,3)
    END DO

    DO k=1,2
       DO i = 1, ncols
          tui(i,k)     = tai(i,k)
       END DO
    END DO

    !
    !     compute scaled water vapor amounts
    !

    DO i = 1, ncols
       ubar(i,1) = h0p
       vbar(i,1) = h0p
       wbar(i,1) = h0p
    END DO

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          x3(i,k) = 0.5e-2_r8 * (tai(i,k+1) - 225.0e0_r8)
       END DO
    END DO

    x2(1:ncols,1:kmax+1)=EXP(x3(1:ncols,1:kmax+1))

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          vbar(i,k+1) = rawi(i,k+1) * x2(i,k) &
               * (pai(i,k) * pre(1))
          x3(i,k)     = 1.6e-2_r8 * (tai(i,k+1) - 256.0e0_r8)
       END DO
    END DO

    x2(1:ncols,1:kmax+1)=EXP(x3(1:ncols,1:kmax+1))

    DO k = 1,(kmax+1)
       DO i = 1, (ncols)
          wbar(i,k+1) = rawi(i,k+1) * x2(i,k) &
               * (pai(i,k) * pre(2))
          x1(i,k)     = 1.8e03_r8    / tai(i,k+1) - h6p08
       END DO
    END DO

    x2(1:ncols,1:kmax+1)=EXP(x1(1:ncols,1:kmax+1))

    DO k = 1, (kmax+1)
       DO i = 1, (ncols)
          x2(i,k) = x2(i,k) * pai(i,k)  * d642
          x2(i,k) = x2(i,k) * rawi(i,k+1) &
               * rawi(i,k+1) / dp(i,k+1)
       END DO
    END DO

    DO ip = 2, (kmax+2)
       DO i = 1, ncols
          ubar(i,ip) = ubar(i,ip-1) + x2(i,ip-1)
          vbar(i,ip) = vbar(i,ip-1) + vbar(i,ip)
          wbar(i,ip) = wbar(i,ip-1) + wbar(i,ip)
       END DO
    END DO

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          ubarm(i,k+1) = (ubar(i,k+1) + ubar(i,k)) * hp5
          vbarm(i,k+1) = (vbar(i,k+1) + vbar(i,k)) * hp5
          wbarm(i,k+1) = (wbar(i,k+1) + wbar(i,k)) * hp5
       END DO
    END DO

    CALL lwflux(pai   ,tai   ,ozai  ,ubar  ,vbar  ,wbar  ,ubarm ,vbarm , &
         wbarm ,fluxu ,fluxd ,txuf  ,tv1   ,tv2   ,tui   ,x1    , &
         x2    ,cc    ,rawi  ,x3    ,x4    ,ch    ,dp    ,css   , &
         ccu   ,shi   ,shh   ,shu   ,sumsav,h0p   ,h1p   ,h1p5  , &
         hp5   ,dtb   ,dtbinv,pr    ,ntm1  ,ozone ,co2val, &
         ncols ,kmax  )
    !
    !     compute clear sky fluxes only for cloud radiative forcing
    !     zero out downward flux accumulators at l=1
    !
    DO i = 1, ncols
       fluxd(i,1) = h0p
       !
       !     upward flux at the surface
       !
       fluxu(i,(kmax+2)) = sumsav(i)
    END DO
    !
    !     compute downward fluxes
    !
    DO ip = 2, (kmax+2)
       DO i = 1, ncols
          suma(i) = h0p
       END DO
       ipm1 = ip - 1
       DO ix = 1, ipm1
          DO i = 1, ncols
             suma(i) = suma(i) + txuf(i,ix,ip)
          END DO
       END DO
       DO i = 1, ncols
          fluxd(i,ip) = suma(i) - shi(i,ip) + shh(i,ip)
       END DO
    END DO
    !
    !     compute upward fluxes
    !
    DO ip = 1, (kmax+1)
       ipp1      = ip + 1
       DO i = 1, ncols
          suma(i) = h0p
       END DO
       DO ix = ipp1, (kmax+2)
          DO i = 1, ncols
             suma(i) = suma(i) + txuf(i,ix,ip)
          END DO
       END DO
       DO i = 1, ncols
          fluxu(i,ip) = suma(i)  + shu(i,ip) + shh(i,ip)
       END DO
    END DO

    DO k=1,(kmax+2)
       DO  i = 1, (ncols)
          x1(i,k) = fluxd(i,k) - fluxu(i,k)
       END DO
    END DO

    DO i = 1, ncols
       ulwclr(i)  = -x1(i,2)
       rsclr (i)  = -x1(i,(kmax+2))
       dlwclr(i)  = fluxd(i,(kmax+2))
    END DO

    DO k = 1,kmax
       DO i = 1, (ncols)
          atlclr(i,k) = (x1(i,k+1) - x1(i,k+2)) * fac / dp(i,k+2)
       END DO
    END DO

    !
    !     we don't allow clouds between gcm levels in the stratosphere
    !

    DO k=1,kmax
       DO i = 1, (ncols)
          css(i,k+1)   = cld(i,k)
          ccu(i,k+1)   = clu(i,k)
       END DO
    END DO

    DO k=1,(nls+1)
       DO i = 1, ncols
          css(i,k) = h0p
          ccu(i,k) = h0p
       END DO
    END DO
    !
    !     icld = 1     : old cloud emissivity setting
    !     icld = 2     : new cloud emissivity setting
    !
    IF (icld == 1) THEN

       DO k=1,((kmax+2) - (nls+2))
          DO i = 1, ncols
             tv1(i,nls+k+1) = -0.05e0_r8 *  dp(i,nls+k+2)
          END DO
       END DO

       DO k=1,((kmax+2) - (nls+2))
          DO i = 1,ncols
             tv2(i,nls+k+1)=EXP(tv1(i,nls+k+1))
             ccu(i,nls+k+1) = ccu(i,nls+k+1) * ( h1p - tv2(i,nls+k+1) )
          END DO
       END DO

       DO l = ls2, (kmax+1)
          DO i = 1, ncols
             !
             !     bash down cloud emissivities
             !
             IF (tl(i,l-1) < 253.0_r8) THEN
                tv1(i,l) = -0.01e0_r8 * dp(i,l+1)
             END IF
          END DO
       END DO

       DO k=1,((kmax+2) - (nls+2))
          DO i = 1,  ncols
             tv2(i,nls+k+1)=EXP(tv1(i,nls+k+1))
             css(i,nls+k+1) = css(i,nls+k+1) * ( h1p - tv2(i,nls+k+1) )
          END DO
       END DO

    ELSE IF (icld == 2) THEN

       DO k=1,((kmax+2) - (nls+2))
          DO i = 1,  ncols
             tv1(i,nls+k+1) = -0.12e0_r8 * ccu(i,nls+k+1) * dp(i,nls+k+2)
          END DO
       END DO

       DO k=1,((kmax+2) - (nls+2))
          DO i = 1,  ncols
             tv2(i,nls+k+1)=EXP(tv1(i,nls+k+1))
             ccu(i,nls+k+1) =  h1p - tv2(i,nls+k+1)
          END DO
       END DO

       DO l = ls2, (kmax+1)
          DO i = 1, ncols
             tv2(i,l) =  tl(i,l-1) - tcrit
          END DO
       END DO

       DO k=1,((kmax+2) - (nls+2))
          DO i = 1,  ncols
             tv2(i,nls+k+1) = MAX(tv2(i,nls+k+1),h0p)
             tv1(i,nls+k+1) = MIN(1.5e-6_r8 * tv2(i,nls+k+1) * tv2(i,nls+k+1),ecrit)
          END DO
       END DO

       DO l = ls2, (kmax+1)
          DO i = 1, ncols
             tv2(i,l) =  tl(i,l-1) - tice
          END DO
       END DO

       DO k=1,((kmax+2) - (nls+2))
          DO i = 1,  ncols
             tv2(i,nls+k+1) = MIN(MAX(5.2115625e-3_r8 * tv2(i,nls+k+1) + 0.06e0_r8 ,ecrit),0.06_r8)
             bitx(k) = (tv1(i,k).eq.ecrit)
             IF (bitx(k)) tv1(i,k)=tv2(i,k)
          END DO
       END DO

       DO l = ls2, (kmax+1)
          DO i = 1, ncols
             tv1(i,l) =  -tv1(i,l) * css(i,l) * dp(i,l+1)
          END DO
       END DO

       DO k=1,((kmax+2) - (nls+2))
          DO i = 1,  ncols
             tv2(i,nls+k+1)=EXP(tv1(i,nls+k+1))
             css(i,nls+k+1) =  h1p - tv2(i,nls+k+1)
          END DO
       END DO

    ELSE IF (icld == 3) THEN

       DO k = 1, kmax
          kflip=kmax+1-k
          DO i = 1, ncols
             rkabs(i,k) = 0.090361_r8*(1.0_r8-fice(i,k)) + &
                  (0.005_r8 + 1.0_r8/rei(i,k))*fice(i,k)
             emis(i,kflip) = 1.0_r8- EXP(-1.66_r8*rkabs(i,k)*clwp(i,k))
             emisd(i,k)=emis(i,kflip)
          END DO
       END DO

       DO k=1,kmax
          DO i = 1, (ncols)
             emis1(i,k+1) = emis(i,k)
          END DO
       END DO

       DO k=1,nls+1
          DO i = 1,  ncols
             emis1(i,k) = h0p
          END DO
       END DO

       DO k=1,((kmax+2) - (nls+2))
          DO i = 1, ncols
             css(i,nls+k+1) = css(i,nls+k+1) * emis1(i,nls+k+1)
             ccu(i,nls+k+1) = ccu(i,nls+k+1) * emis1(i,nls+k+1)
          END DO
       END DO

    END IF
    !
    !     get the contribution from cloudiness
    !
    CALL cldslw(ncols ,kmax  ,nlcs  ,h1p   ,cs    ,x1    ,x2    , &
         cc    ,x3    ,x4    ,ch    ,css   ,ccu   )

    DO k=1,(kmax+2)
       DO l=1,(kmax+2)
          DO i = 1, (ncols)
             txuf(i,l,k) = txuf(i,l,k) * cs(i,l,k)
          END DO
       END DO
    END DO

    DO k=1,(kmax+2)
       DO i = 1, (ncols)
          shi(i,k) = shi(i,k) * ch(i,k)
       END DO
    END DO

    DO k=1,(kmax+1)
       DO i = 1, (ncols)
          shu(i,k) = shu(i,k) * cc(i,k)
          shu(i,k) = shu(i,k) + shh(i,k)
       END DO
    END DO
    !
    !     zero out downward flux accumulators at l=1
    !
    DO i = 1, ncols
       fluxd(i,1) = h0p
    END DO
    !
    !     upward flux at the surface
    !
    DO i = 1, ncols
       fluxu(i,(kmax+2)) = sumsav(i)
    END DO
    !
    !     upward flux at the surface was computed before call to cldslw
    !     compute downward fluxes
    !
    DO ip = 2, (kmax+2)

       DO i = 1, ncols
          suma(i) = h0p
       END DO

       ipm1 = ip - 1

       DO ix = 1, ipm1
          DO i = 1, ncols
             suma(i) = suma(i) + txuf(i,ix,ip)
          END DO
       END DO

       DO i = 1, ncols
          fluxd(i,ip) = suma(i) - shi(i,ip) + shh(i,ip)
       END DO

    END DO
    !
    !     compute upward fluxes
    !
    DO ip = 1, (kmax+1)
       ipp1 = ip + 1

       DO i = 1, ncols
          suma(i) = h0p
       END DO

       DO ix = ipp1, (kmax+2)
          DO i = 1, ncols
             suma(i) = suma(i) + txuf(i,ix,ip)
          END DO
       END DO

       DO i = 1, ncols
          fluxu(i,ip) = suma(i) + shu(i,ip)
       END DO

    END DO

    DO k=1,(kmax+2)
       DO i = 1, (ncols)
          x1(i,k) = fluxd(i,k) - fluxu(i,k)
       END DO
    END DO

    DO i = 1, ncols
       ulwtop(i) = -x1(i,2)
       rs(i)     = -x1(i,(kmax+2))
       dlwbot(i) = fluxd(i,(kmax+2))
    END DO

    DO k=1,kmax
       DO i = 1, (ncols)
          atl(i,k) = (x1(i,k+1) - x1(i,k+2)) * fac / dp(i,k+2)
       END DO
    END DO

  END SUBROUTINE lwrad


  !----------------------------------------------------------------------C
  ! Subroutine: CLOUDY
  !
  ! CALCULATES:
  !    computes  ozone heating, downflux and ground absorption, water
  !    vapor heating and computes for cycles over five bands total
  !    optical depth, reflection and transmission for diffuse
  !    incidence,direct transmission, diffuse reflection and
  !    transmission for direct beam, upward and dwonward fluxes at
  !    layer boundaries, absorption in the column.
  !
  !----------------------------------------------------------------------C

  SUBROUTINE cloudy (ncols ,kmax  ,scosc ,cmuc  ,csmcld,dscld ,rvbc  ,rvdc  , &
       rnbc  ,rndc  ,agvcd ,agncd ,rsvcd ,rsncd ,sc    ,rco   , &
       rcg   ,taut  ,rc2   ,tr1   ,tr2   ,tr3   ,ta    ,wa    , &
       oa    ,e0    ,pu    ,ozcd  ,swale ,swil  ,css   ,acld  , &
       dpc   ,swilc ,ccu   ,tauc  ,litd  ,sqrt3 ,gg    ,ggp   , &
       ggsq  ,np    ,lmp1  ,nsol  ,ncld  ,nclmp1,ncldnp,dooz    )
    !
    !==========================================================================
    !     imax......Number of grid points on a gaussian latitude circle
    !     kmax......Number of grid points at vertical
    !     scosc.....scosz(i)   = s0     * cmu(i)
    !                         where s0  is constant solar
    !                               cmu is cosine of solar zenith angle
    !     cmuc......cmuc is cosine of solar zenith angle
    !     csmcld....csmcld = cosmag(i)  = 1224.0 * cmu(i) * cmu(i) + 1.0
    !     dscld.....Total absorption in atmosphere and ground
    !     rvbc......Visible beam cloudy flux
    !     rvdc......Visible diffuse cloudy flux
    !     rnbc......Nir beam cloudy flux
    !     rndc......Nir diffuse cloudy flux
    !     agvcd.....Ground Visible Diffuse Albedo
    !     agncd.....Ground near Infrared Diffuse albedo
    !     rsvcd.....Ground Viseible beam albedo
    !     rsncd.....Ground near infrared beam albedo
    !     sc........Ground absorption
    !     rco.......Cloudy an ground reflection for ozone absorption comp.
    !     rcg.......Cloudy and ground reflection for ground absoption
    !               computation in visible region of spectrum
    !     taut......Downward visible beam
    !     rc2.......cloudy and ground reflection for ground absoption
    !               computation in region of spectrum from 0.7 to 0.9 mcm
    !     tr1.......Extinction of beam radiation (clear)
    !     tr2.......Extinction of beam radiation (cloud)
    !     tr3.......Extinction of beam radiation (Cloud, Raley)
    !     ta........Layer Temperature in DLGP
    !     wa........Layer specific humidity in DLGP
    !     oa........Layer ozone mixing ratio in DLGP
    !     e0........cloud optical depth
    !     pu........pressure at botton of layer in DLGP
    !     ozcd......ozone amount in column in CDLGP
    !     swale.....water vapor amount in column in DLGP
    !     swil......water vapor amount in layer in DLGP
    !     css.......cloud amount
    !     acld......Heating rate (cloudy)
    !     dpc.......pressure defference
    !     swilc.....water vapor amount in layer in CDLGP
    !     ccu.......cumulus cloud amount in DLGP
    !     tauc......Cloud optical depth in cloudy DLGP
    !     litd......numbers de CDLGP in all layers
    !     sqrt3.....Magification factor for diffuse reflected radiation sqrt3  = SQRT(3.0)
    !     gg........Asymmetry Factor      = 0.85
    !     ggp.......ggp    = gg  / (1.0 + gg) * 0.75
    !     ggsq......ggsq   = gg  * gg
    !     np........np = (kmax+2)
    !     lmp1......lmp1   = (kmax+1)
    !     nsol......Number of solar latitude grid points (cosz>0.01)
    !     ncld......Number of cloudy DLGP
    !     nclmp1....NCLD*(KMAX+1), where NCLD is number of cloudy DLGP
    !     ncldnp....NCLD*(KMAX+2), where NCLD is number of cloudy DLGP
    !     dooz......dooz   = (.NOT. noz) where : noz = .FALSE.
    !               (do ozone computation )
    !==========================================================================
    !
    INTEGER, INTENT(in   ) :: ncols
    INTEGER, INTENT(in   ) :: kmax
    REAL(KIND=r8),    INTENT(in   ) :: scosc (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: cmuc  (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: csmcld(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dscld (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rvbc  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rvdc  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rnbc  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rndc  (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: agvcd (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: agncd (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rsvcd (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rsncd (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: sc    (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rco   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rcg   (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: taut  (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rc2   (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: tr1   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: tr2   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: tr3   (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: ta    (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(inout  ) :: wa    (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(inout  ) :: oa    (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(inout  ) :: e0    (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(inout  ) :: pu    (ncols*(kmax+2))
    REAL(KIND=r8),    INTENT(in   ) :: ozcd  (ncols*(kmax+2))
    REAL(KIND=r8),    INTENT(inout  ) :: swale (ncols*(kmax+2))
    REAL(KIND=r8),    INTENT(inout  ) :: swil  (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(inout  ) :: css   (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(inout  ) :: acld  (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(inout  ) :: dpc   (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(in   ) :: swilc (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(inout  ) :: ccu   (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(in   ) :: tauc  (ncols*(kmax+1))
    INTEGER, INTENT(in   ) :: litd  (ncols*(kmax+2))
    REAL(KIND=r8),    INTENT(in   ) :: sqrt3
    REAL(KIND=r8),    INTENT(in   ) :: gg
    REAL(KIND=r8),    INTENT(in   ) :: ggp
    REAL(KIND=r8),    INTENT(in   ) :: ggsq
    INTEGER, INTENT(in   ) :: np
    INTEGER, INTENT(in   ) :: lmp1
    INTEGER, INTENT(in   ) :: nsol
    INTEGER, INTENT(in   ) :: ncld
    INTEGER, INTENT(in   ) :: nclmp1
    INTEGER, INTENT(in   ) :: ncldnp
    LOGICAL, INTENT(in   ) :: dooz



    REAL(KIND=r8)                 :: w     (ncols*(kmax+2))
    REAL(KIND=r8)                 :: dn    (ncols*(kmax+2))
    REAL(KIND=r8)                 :: up    (ncols*(kmax+2))
    REAL(KIND=r8)                 :: vm    (ncols*(kmax+2))
    REAL(KIND=r8)                 :: vp    (ncols*(kmax+2))
    REAL(KIND=r8)                 :: cm    (ncols*(kmax+2))
    REAL(KIND=r8)                 :: dl    (ncols*(kmax+2))
    REAL(KIND=r8)                 :: den   (ncols*(kmax+1))

    REAL(KIND=r8)                 :: f2   (ncols*(kmax+1))
    REAL(KIND=r8)                 :: cr   (ncols*(kmax+2))
    REAL(KIND=r8)                 :: e2   (ncols*(kmax+1))
    REAL(KIND=r8)                 :: ul   (ncols*(kmax+2))
    REAL(KIND=r8)                 :: u1   (ncols*(kmax+1))
    REAL(KIND=r8)                 :: ak   (ncols*(kmax+1))
    REAL(KIND=r8)                 :: da   (ncols*(kmax+1))
    REAL(KIND=r8)                 :: db   (ncols*(kmax+1))
    REAL(KIND=r8)                 :: alf1 (ncols*(kmax+1))
    REAL(KIND=r8)                 :: alf2 (ncols*(kmax+1))
    REAL(KIND=r8)                 :: sol  (ncols*(kmax+2))



    !REAL(KIND=r8), PARAMETER :: fk(5) = (/0.107e0_r8, 0.104e0_r8, 0.073e0_r8, 0.044e0_r8,  0.025e0_r8/)
    !REAL(KIND=r8), PARAMETER :: xk(5) = (/0.005e0_r8, 0.041e0_r8, 0.416e0_r8, 4.752e0_r8, 72.459e0_r8/)

    ! Include global version 2.2 - Increase number of spectral radiation bands

    REAL(KIND=r8), PARAMETER :: fk(10) = (/0.0698e0_r8,0.1558e0_r8,0.0631e0_r8,0.0362e0_r8,0.0243e0_r8, &
         0.0158e0_r8,0.0087e0_r8,0.001467e0_r8,0.002342e0_r8,0.001075e0_r8/)
    REAL(KIND=r8), PARAMETER :: xk(10) = (/0.0002e1_r8,0.0035e1_r8,0.0377e1_r8,0.195e1_r8,0.940e1_r8, &
         4.46e1_r8,19.0e1_r8,98.9e1_r8,270.60e1_r8,3901.1e1_r8/)

    REAL(KIND=r8) :: avbc (ncols)
    REAL(KIND=r8) :: anbc (ncols)
    REAL(KIND=r8) :: rvnbc(ncols)

    REAL(KIND=r8) :: expcut
    REAL(KIND=r8) :: ggpp1
    REAL(KIND=r8) :: ggpm1
    REAL(KIND=r8) :: gsqm1

    INTEGER :: lp
    INTEGER :: i
    INTEGER :: l
    INTEGER, DIMENSION(lmp1) :: l0a
    INTEGER, DIMENSION(np)   :: l0b
    INTEGER, DIMENSION(lmp1) :: l0c
    INTEGER, DIMENSION(lmp1) :: l1a
    INTEGER, DIMENSION(np)   :: l1b
    INTEGER, DIMENSION(lmp1) :: l1c
    INTEGER :: ik
    INTEGER :: k


    !----------------------------------------------------------------------C
    !-----PARAMETERS USING ASYMMETRY FACTOR OF CLOUD PARTICLE--------------C
    !-----------------------------------PHASE FUNCTION g=0.85--------------C
    !----------------------------------------------------------------------C
    ggpp1 = 1.0_r8 + ggp         !  1 + (g/(1+g))*0.75_r8
    ggpm1 = ggp - 1.0_r8         ! -1 + (g/(1+g))*0.75_r8
    gsqm1 = 1.0_r8 - ggsq        !  1 - g*g
    expcut=- LOG(1.0e53_r8)
    lp = lmp1 * ncld
    DO i= 1, ncld
       dn(i)    = 0.0_r8
       tr1(i)   = 0.0_r8
       rvnbc(i) = 0.0_r8
    END DO
    !----------------------------------------------------------------------C
    !-------DO OZONE ABSORPTION COMPUTATIONS ON THE WAY DOWN---------------C
    !----------------------------------------------------------------------C
    IF (dooz) THEN

       DO l = 1, lmp1
          l0a(l) = (l-1) * ncld
          l1a(l) =  l    * ncld
       END DO
       DO l = 2, np
          l0b(l) = (l-2) * ncld
          l1b(l) = (l-1) * ncld
       END DO
       DO k = 1, lmp1
          l  = np-k
          l0c(k) = (l-1) * ncld
          l1c(k) =  l    * ncld
       END DO
       DO l = 2, np
          DO i = 1, ncld
             w(l0b(l)+i) = ozcd(l1b(l)+i) * csmcld(i)  !Ozone path on the way down
          END DO
       END DO
       !----------------------------------------------------------------------C
       !--COMPUTE OZONE  ABSORPTION (DN) TILL THE LAYER ON THE WAY DOWN-------C
       !--USING OZONE ABSORPTION FUNCTION DUE TO Lacis and Hansen (1974)------C
       !--OZONE AMOUNT BELOW TOP CLOUD LAYER IS EQUAL ZERO--------------------C
       !----------------------------------------------------------------------C
       DO i = 1, nclmp1
          e0(i) = 103.63_r8 * w(i)
          e0(i) = e0(i)  * e0(i) * e0(i)
          vp(i) = 1.0_r8 + 138.57_r8   * w(i)
          cm(i) = vp(i) ** 0.805_r8
          dn(ncld+i) = 0.02118_r8 * w(i) &
               / (1.0_r8 + 0.042_r8 * w(i) &
               + 0.000323_r8 * w(i) * w(i)) &
               + 1.08173_r8  * w(i) &
               / cm(i) + 0.0658_r8  * w(i) &
               / (1.0_r8   + e0(i))
       END DO
       !
       !     compute ozone heating on the way down
       !
       !----------------------------------------------------------------------C
       !--COMPUTE OZONE ABSORPTION (ACLD) ON THE WAY DOWN IN EACH LAYER-------C
       !--BELOW TOP CLOUD LAYER OZONE ABSORPTION IS EQUAL ZERO----------------C
       !----------------------------------------------------------------------C
       DO i = 1, nclmp1
          acld(i) = dn(ncld+i) - dn(i)
       END DO

       DO l = 1, lmp1
          DO i = 1, ncld
             acld(l0a(l)+i) = acld(l0a(l)+i) * scosc(i)
          END DO
       END DO
    ELSE
       DO i = 1, ncld
          dn(lp+i) = 0.0_r8
       END DO
    END IF
    !
    !     downflux and ground absorption for lambda under 0.7 microns
    !     as above but for lamda between 0.7 and 0.9 microns
    !
    !----------------------------------------------------------------------C
    !-----------DOWNWARD FLUXES AT GROUND AND GROUND ABSORPTION------------C
    !--FOR WAVELENGTH LESS THAN 0.7 MICRONS--------------------------------C
    !--AS ABOVE AND FOR WAVELENGTH BETWEEN 0.7 AND 0.9 MICRONS-------------C
    !--TAKING INTO ACCOUNT OZONE ABSORPTION, MOLECULAR SCATTERING AND------C
    !--GROUND REFLECTION.--------------------------------------------------C
    !--0.5 is the part of Solar Constant in visible region of spectrum-----C
    !--0.147 is the part of Solar Constant in spectral region--------------C
    !---------from 0.7 to 0.9 mcm------------------------------------------C
    !--TR2(I)=EXP(-(1-g*g)TAUcld*M), TAUcld is CLOUD OPTICAL DEPTH,--------C
    !-M IS MAGNIFICATION FACTOR, g IS ASYMMETRY FACTOR OF CLOUD PARTICLES--C
    !--TR3(I)=EXP(-(1-g*g)(TAUcld+TAURay)*M), TAURay=0.15746,--------------C
    !--RSVCD...GROUND VISIBLE BEAM ALBEDO----------------------------------C
    !--AGVCD...GROUND VISIBLE DIFFUSE ALBEDO-------------------------------C
    !--RSNCD...GROUND NEAR INFRARED BEAM ALBEDO----------------------------C
    !--AGNCD...GROUND NEAR INFRARED DIFFUSE ALBEDO-------------------------C
    !--RCG.....CLOUDY AND GROUND REFLECTION FOR GROUND ABSORPTION----------C
    !----------COMPUTATION IN VISIBLE REGION OF SPECTRUM-------------------C
    !--RC2.....CLOUDY AND GROUND REFLECTION FOR GROUND ABSORPTION----------C
    !----------COMPUTATION IN REGION OF SPECTRUM FROM 0.7 TO 0.9 mcm-------C
    !----------------------------------------------------------------------C
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    !----------------------------------------------------------------------C
    !-----------SPECTRAL REGION FROM 0.2 TO 0.7 mcm------------------------C
    !----------------------------------------------------------------------C
    DO i = 1, ncld
       sc(i)   = 0.5_r8     - dn(lp+i) ! (DN)..Total ozone absorption=0?
       taut(i) = sc(i)   * tr3(i) * scosc(i)  !Downward visible beam
       avbc(i) = taut(i) * (1.0_r8 - rsvcd(i))  !Net visible beam
       rvbc(litd(i)) = taut(i)
    END DO
    DO i = 1, ncld
       sc(i)   = sc(i)   * (1.0_r8 - rcg(i)) * scosc(i)
       taut(i) = (sc(i)  - avbc(i)) &
            / (1.0_r8    - agvcd(i))     !Net visible diffuse
       rvdc(litd(i)) = taut(i)
    END DO
    DO i = 1, ncld
       !rnbc(i) = 0.147_r8   * tr2(i)         * scosc(i)!Downward NearIR beam
       !anbc(i) = (1.0_r8    - rsncd(i))      * rnbc(i) !Net NearIR beam
       !rndc(i) = (0.147_r8  * (1.0_r8 - rc2(i)) * scosc(i) &!Downward NearIR dif.
       !     - anbc(i))/ (1.0_r8 - agncd(i))
       !sc(i)   = sc(i)   + (1.0_r8 - rc2(i)) * scosc(i) &!Ground absorption
       !     * 0.147_r8

       ! Include global version 2.2
       rnbc(i) = 0.1214_r8  * tr2(i)         * scosc(i)   !Downward NearIR beam
       anbc(i) = (1.0_r8    - rsncd(i))      * rnbc(i)    !Net NearIR beam
       rndc(i) = (0.1214_r8  * (1.0_r8 - rc2(i)) * scosc(i) &!Downward NearIR dif.
            - anbc(i))/ (1.0_r8 - agncd(i))
       sc(i)   = sc(i)   + (1.0_r8 - rc2(i)) * scosc(i) & !Ground absorption
            * 0.1214_r8
    END DO
    !----------------------------------------------------------------------C
    !------DO OZONE ABSORPTION COMPUTATIONS ON THE WAY DOWN AND UP---------C
    !----------------------------------------------------------------------C
    IF (dooz) THEN
       !----------------------------------------------------------------------C
       !---COMPUTE OZONE PATH (W) TILL THE LAYER  ON THE WAY DOWN AND UP------C
       !----------------------------------------------------------------------C
       DO i = 1, ncld
          up(lp+i) = dn(lp+i)
          w(lp+i)  = ozcd(lp+i) * (1.9_r8 + csmcld(i))
       END DO
       DO i = 1, nclmp1
          w(i) = 1.9_r8 * ozcd(i)
       END DO

       DO l = 1, lmp1
          !cdir nodep
          DO i = 1, ncld
             w(l0a(l)+i) = w(lp+i) - w(l0a(l)+i)
          END DO
       END DO
       !----------------------------------------------------------------------C
       !--OZONE  ABSORPTION (UP) TILL THE LAYER ON THE WAY DOWN AND UP--------C
       !--USING OZONE ABSORPTION FUNCTION DUE TO Lacis and Hansen (1974)------C
       !----------------------------------------------------------------------C
       DO i = 1, nclmp1
          e0(i) = 103.63_r8       * w(i)
          e0(i) = e0(i) * e0(i) * e0(i)
          vp(i) = 1.0_r8 + 138.57_r8 * w(i)
          cm(i) = vp(i) ** 0.805_r8
          up(i) = 0.02118_r8 * w(i) &
               / (1.0_r8 + 0.042_r8 * w(i) &
               + 0.000323_r8 * w(i) * w(i)) &
               + 1.08173_r8  * w(i) &
               / cm(i) + 0.0658_r8  * w(i) &
               / (1.0_r8 + e0(i))
       END DO
       !
       !     compute ozone heating on the way up
       !
       !----------------------------------------------------------------------C
       !-----OZONE ABSORPTION (W) IN EACH LAYER ON WAY DOWN AND UP,-----------C
       !-----TOTAL OZONE ABSORPTION (ACLD) IN EACH LAYER----------------------C
       !--RCO....CLOUDY AND GROUND REFLECTION FOR OZONE ABSORPTION COMP.------C
       !----------------------------------------------------------------------C
       DO i = 1, nclmp1
          w(i) = up(i) - up(ncld+i)
       END DO
       DO l = 1, lmp1
          DO i=1,ncld
             acld(l0a(l)+i) = acld(l0a(l)+i) + w(l0a(l)+i) * rco(i) &
                  * scosc(i)
          END DO
       END DO
       acld(1:nclmp1) = MAX(0.0_r8,acld(1:nclmp1))
    END IF
    DO l = 1, lmp1
       DO i=1,ncld
          oa(l0a(l)+i)  = cmuc(i)          !Cosine of solar zenith angle
       END DO
    END DO
    DO i = 1, nclmp1                     !NCLD*(KMAX+1)
       ta(i) = 0.5_r8  - ggp * oa(i)        !0.5_r8-gD*0.75_r8*mu0
       wa(i) = 1.0_r8  - ta(i)              !gD=g/(1+g)
    END DO
    !----------------------------------------------------------------------C
    !-------CYCLE OVER TEN WATER VAPOR ABSORPTION COEFFICIENTS (XK)--------C
    !-----------(TAKING FROM EXPONENTIAL EXPANSION OF WATER VAPOR----------C
    !---------- ABSORPTION FUNCTION WITH THE WEIGHTS (FK))-----------------C
    !----------------------------------------------------------------------C
    !DO ik = 1, 5

    ! Include global version 2.2
    DO ik=1,10

       !
       !     compute total optical depth and single scattering albedo
       !     pizero of clouds is 0.99
       !
       DO i = 1, nclmp1
          ccu(i) = tauc(i) + swilc(i) * xk(ik)
          cr(i)  = tauc(i) / ccu(i)   * 0.99_r8
          !
          !     compute reflection and transmission for diffuse incidence
          !-----IN TWO STREAM APPROACH DUE TO Sagan and Pollack (1967)-----------C
          !-----GG....g=0.85  ASYMMETRY FACTOR-----------------------------------C
          !
          vp(i)  = 1.0_r8 - cr(i) * gg
          vm(i)  = 1.0_r8 - cr(i)
       END DO
       DO i = 1, nclmp1
          vp(i)  = SQRT(vp(i))
          vm(i)  = SQRT(vm(i))
          u1(i)  = vp(i) / vm(i)
          w(i)   = u1(i)  + 1.0_r8
          w(i)   = w(i)   * w(i)
          cm(i)  = u1(i)  - 1.0_r8
          cm(i)  = cm(i)  * cm(i)
          dpc(i) = sqrt3 * vp(i) * vm(i) * ccu(i)
          e2(i)  = -dpc(i)
          IF (ik >= 4) e2(i) = MAX(e2(i),expcut)
          e2(i)  = EXP(e2(i))
          cm(i)  = w(i)   - cm(i) * e2(i) * e2(i)
          pu(i)  = (u1(i) * u1(i) - 1.0_r8) &           ! Reflection
               * (1.0_r8 - e2(i) * e2(i)) / cm(i)
          css(i) =  4.0_r8 * u1(i) * e2(i)  / cm(i)     ! Transmission
          !----------------------------------------------------------------------C
          !-----DELTA-SCALING OF OPTICAL DEPTH AND SINGLE SCATTERING ALBEDO------C
          !----------------------------------------------------------------------C
          vp(i)  = 1.0_r8 - ggsq    * cr(i)
          ccu(i) = ccu(i) * vp(i)                    ! Optical depth
          cr(i)  = cr(i)  * gsqm1 / vp(i)            ! Single scattering albedo
       END DO
       !----------------------------------------------------------------------C
       !----COMPUTE DIRECT TRANSMISSION (EO) FOR DELTA-SCALING OPTICAL DEPTH--C
       !----------------------------------------------------------------------C
       DO i = 1, ncld
          sol(i)  = scosc(i) * fk(ik)
       END DO
       DO l = 1, lmp1
          DO i=1,ncld
             dpc(l0a(l)+i) = ccu(l0a(l)+i) * csmcld(i) ! Delta Tau*Magnif. factor
          END DO
       END DO
       DO i = 1, nclmp1
          e0(i)  = -dpc(i)
          IF (ik >= 4) e0(i) = MAX(e0(i), expcut)
          e0(i)  = EXP(e0(i))
       END DO
       !
       !     compute diffuse reflection and transmission for direct beam
       !     set up delta-eddington parameters
       !
       DO l = 1, lmp1
          !cdir nodep
          DO i = 1, ncld
             sol(l1a(l)+i) = sol(l0a(l)+i)  * e0(l0a(l)+i) ! Beam rad. at all levels
          END DO
       END DO
       DO i = 1, ncld
          rvnbc(i) = rvnbc(i) + sol(lp+i)  ! Beam rad. at the ground
       END DO

       DO i = 1, nclmp1
          swil(i)  =  1.75_r8 - cr(i) * ggpp1  ! 1.75-omegaD*(1+gD*0.75)
          swale(i) = -0.25_r8 - cr(i) * ggpm1  ! -0.25- omegaD*(gD*0.75-1)
          ak(i)    =  swil(i)  * swil(i) &
               -  swale(i) * swale(i)
       END DO
       DO i = 1, nclmp1
          ak(i) = SQRT(ak(i))
          alf1(i)  = swil(i)  * wa(i) &
               + swale(i) * ta(i)
          alf2(i)  = swil(i)  * ta(i) &
               + swale(i) * wa(i)
          vp(i) = 1.0_r8 - ak(i) * oa(i)
          vm(i) = 1.0_r8 + ak(i) * oa(i)
          ul(i) = ta(i)   - alf2(i) * oa(i)
          u1(i) = wa(i)   + alf1(i) * oa(i)
          cm(i) = alf2(i) + ak(i)   * ta(i)
          dl(i) = alf2(i) - ak(i)   * ta(i)
          e2(i) = alf1(i) - ak(i)   * wa(i)
          f2(i) = alf1(i) + ak(i)   * wa(i)
          den(i)  = 1.0_r8 - ak(i)  * ak(i) &
               *       oa(i)  * oa(i)
       END DO
       DO i = 1, nclmp1
          den(i) = MAX(den(i),.000001e0_r8)
          dpc(i) = ak(i) * ccu(i)
          da(i)  = -dpc(i)
          IF (ik >= 4) da(i) = MAX(da(i), expcut)
          da(i) = EXP(da(i))
          dpc(i) = 2.0_r8 * dpc(i)
          db(i)  = -dpc(i)
          IF (ik >= 4) db(i) = MAX(db(i), expcut)
          db(i) = EXP(db(i))
          den(i) = den(i) * (ak(i)   + swil(i) &
               + (ak(i) - swil(i)) * db(i))
          !
          !     compute upward and downward fluxes at layer boundaries
          !
          up(i) = cr(i)  * (vp(i) * cm(i) &
               - vm(i)  * dl(i)  * db(i) &
               - 2.0_r8           * ak(i)  * ul(i) &
               * e0(i)  * da(i)) / den(i)
          up(i) = up(i)  * sol(i)
          dn(ncld+i) = -cr(i)  * (vm(i) * f2(i) &
               * e0(i)   - vp(i)  * e2(i) &
               * e0(i)   * db(i)  - 2.0_r8 &
               * ak(i)   * u1(i)  * da(i)) &
               / den(i)
          dn(ncld+i) = sol(i)  * dn(ncld+i)
       END DO
       !
       !     fill up boundary terms
       !
       DO i = 1, ncld
          up(lp+i) = rsncd(i) * sol(lp+i)  !RSNCD...ground NIR beam albedo
          pu(lp+i) = agncd(i)              !AGNCD...ground vis. beam albedo
          dn(i) = 0.0_r8
          cr(i) = 0.0_r8
          cm(i) = 1.0_r8
          vp(i) = 0.0_r8
          vm(i) = up(i)
       END DO
       !
       !     safety net
       !
       DO i = 1, ncldnp
          up (i) = MAX(up (i), 0.0_r8)
          dn (i) = MAX(dn (i), 0.0_r8)
          sol(i) = MAX(sol(i), 0.0_r8)
       END DO
       DO i = 1, nclmp1
          pu (i) = MAX(pu (i), 0.0_r8)
          css(i) = MAX(css(i), 0.0_r8)
       END DO
       !----------------------------------------------------------------------C
       !-------COMPUTE FLUXES AT THE BOUNDARIES OF ADDING LAYERS--------------C
       !----------------------------------------------------------------------C
       !---------COMPUTE MAGNIFICATION FACTORS....CM=1/(1-R1*R2)--------------C
       !----------------------------------------------------------------------C
       DO i = 1, nclmp1
          e0(i) = css(i) * css(i)
       END DO
       DO l = 1, lmp1
          !cdir nodep
          DO i = 1, ncld
             cr(l1a(l)+i) = pu(l0a(l)+i) + e0(l0a(l)+i) * cr(l0a(l)+i) &
                  * cm(l0a(l)+i)
             cm(l1a(l)+i) = 1.0_r8      - cr(l1a(l)+i) * pu(l1a(l)+i)
             cm(l1a(l)+i) = 1.0_r8      / cm(l1a(l)+i)
          END DO
       END DO
       !
       !     compute fluxes on the way down
       !
       DO i = 1, nclmp1
          db(i) = cr(i)  * up(i)
          e0(i) = css(i) * cm(i)
       END DO
       DO l = 1, lmp1
          !cdir nodep
          DO i = 1, ncld
             vp(l1a(l)+i) = e0(l0a(l)+i) * (vp(l0a(l)+i) + db(l0a(l)+i)) &
                  + dn(l1a(l)+i)
          END DO
       END DO
       DO i = 1, nclmp1
          vm(ncld+i) = cm(ncld+i) *  &
               (vp(ncld+i) * pu(ncld+i) + up(ncld+i))
       END DO
       !----------------------------------------------------------------------C
       !-------COMPUTATION OF THE FLUXES AT THE GROUND------------------------C
       !----------------------------------------------------------------------C
       DO i = 1, ncld
          ul(lp+i) = vm(lp+i)
          dl(lp+i) = vp(lp+i)  + ul(lp+i) * cr(lp+i) + sol(lp+i)
          tr1(i)   = tr1(i)    + dl(lp+i) - ul(lp+i)
       END DO
       !
       !     compute fluxes on the way up
       !
       DO i = 1, nclmp1
          e0(i) = css(i) * cm(i)
       END DO

       DO k = 1, lmp1
          !cdir nodep
          DO i = 1, ncld
             ul(l0c(k)+i) = vm(l0c(k)+i) + ul(l1c(k)+i) * e0(l0c(k)+i)
          END DO
       END DO
       DO i = 1, nclmp1
          dl(i)   = vp(i)   + ul(i) * cr(i) + sol(i)
       END DO
       DO i = 1, nclmp1
          acld(i) = acld(i) + dl(i) - ul(i) &
               - (dl(ncld+i)     -   ul(ncld+i))
       END DO
    END DO
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    !CC-END OF CYCLE OVER FIVE WATER VAPOR ABSORPTION COEFFICIENTS (XK)-CCCC
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    DO i = 1, ncld
       taut(i) = rnbc(i) + rvnbc(i)
    END DO
    !----------------------------------------------------------------------C
    !----RNBC...DOWNWARD NIR BEAM CLOUDY GROUND FLUX-----------------------C
    !----------------------------------------------------------------------C
    DO i = 1, ncld
       rnbc(litd(i)) = taut(i)
    END DO
    DO i = 1, ncld
       taut(i) = rndc(i) + (tr1(i) - rvnbc(i) &
            * (1.0_r8 - rsncd(i))) / (1.0_r8 - agncd(i))
    END DO
    !----------------------------------------------------------------------C
    !----RNDC...DOWNWARD NIR DIFFUSE CLOUDY GROUND FLUX--------------------C
    !----------------------------------------------------------------------C
    DO i = 1, ncld
       rndc(litd(i)) = taut(i)
    END DO
    DO i = 1, ncld
       taut(i) = sc(i) + tr1(i)
    END DO
    !----------------------------------------------------------------------C
    !-----SC...GROUND ABSORPTION-------------------------------------------C
    !----------------------------------------------------------------------C
    DO i = 1, ncld
       sc(litd(i)) = taut(i)
    END DO
    !
    !     add up absorption in column
    !
    DO i = 1, nclmp1
       e0(i) = acld(i)
    END DO
    DO i = 1, nclmp1
       acld(litd(i)) = e0(i)
    END DO
    !----------------------------------------------------------------------C
    !-----DSCLD...TOTAL ABSORPTION IN ATMOSPHERE AND GROUND----------------C
    !----------------------------------------------------------------------C
    DO i = 1, nsol
       dscld(i) = sc(i)
    END DO
    DO l = 1, lmp1
       DO i = 1, nsol
          dscld(i) = dscld(i) + acld(l0a(l)+i)
       END DO
    END DO
  END SUBROUTINE cloudy

  !-----------------------------------------------------------------------
  ! Subroutine: CLEAR
  !
  ! CALCULATES:
  !     OZONE PATH TILL THE LAYER ILLUMINATED FROM ABOVE AND FROM BELOW
  !     OZONE ABSORPTION IN EACH LAYER AND THE GROUND
  !     WATER VAPOR  PATH TILL THE LAYER ILLUMINATED FROM ABOVE AND FROM BELOW
  !     WATER VAPOR ABSORPTION IN EACH LAYER AND THE GROUND
  !     DOWNWARD AND UPWARD FLUXES AT THE GROUND (VISIBLE AND NEAR INFRARED)
  !
  ! MAIN OUTPUT:
  !    DOWNWARD GROUND FLUXES AND ABSORPTIONS, IN CLEAR CASE AND
  !    IN ALL DAYTIME LATITUDE GRID POINTS (NSOL)
  !
  ! COMPUTATION IS DONE 10 BANDS
  !---------------------------------------------------------------------C
  SUBROUTINE clear(ncols ,kmax  ,sqrt3 ,np    ,lmp1  ,nsol  ,nslmp1,nsolnp, &
       dooz  ,scosz ,cosmag,dsclr ,rvbl  ,rvdl  ,rnbl  ,rndl  , &
       agv   ,rsurfv,rsurfn,sl    ,rlo   ,rlg   ,tr1   ,e0    , &
       ozale ,swale ,aclr                                       )
    !==========================================================================
    !    imax......Number of grid points on a gaussian latitude circle
    !    kmax......Number of grid points at vertical
    !    sqrt3.....Magification factor for diffuse reflected radiation
    !              sqrt3  = SQRT(3.0)
    !    np........np = (kmax+2)
    !    lmp1......lmp1   = (kmax+1)
    !    nsol......Number of solar latitude grid points (cosz>0.01)
    !    nslmp1....nsol*(kmax +1 ), where nsol is number of solar
    !              latitude grid points (cosz>0.01)
    !    nsolnp....nsol*(kmax +2 ), where nsol is number of solar
    !              latitude grid points (cosz>0.01)
    !    dooz......dooz   = (.NOT. noz) where : noz = .FALSE.
    !               (do ozone computation )
    !    scosz.....scosz(i)   = s0     * cmu(i)
    !                         where s0  is constant solar
    !                               cmu is cosine of solar zenith angle
    !    cosmag....Magnification factor in DLGP
    !              csmcld = cosmag(i)  = 1224.0 * cmu(i) * cmu(i) + 1.0
    !    dsclr.....Absorption of clear atmosphere and ground clear
    !    rvbl......Visible beam clear  "Downward ground fluxes in DLGP"
    !    rvdl......Visible diffuse clear "Downward ground fluxes in DLGP"
    !    rnbl......NearIR beam clear "Downward ground fluxes in DLGP"
    !    rndl......NearIR diffuse clear  "Downward ground fluxes in DLGP"
    !    agv.......Ground visible diffuse albedo in DLGP
    !    rsurfv....Ground visible beam albedo in DLGP
    !    rsurfn....Ground near IR beam albedo in DLGP
    !    sl........Net ground clear flux
    !    rlo.......Clear sky and ground reflection in DLGP for
    !              ozone computation
    !    rlg.......Clear sky and ground reflection in DLGP for
    !              ground absorption computation
    !    tr1.......Extinction of beam radiation (clear)
    !    e0........Cloud optical depth in DLGP
    !    ozale.....Ozone amount in column in DLGP
    !    swale.....water vapor amount in column in DLGP
    !    aclr......Absorption in clear ATM
    !==========================================================================
    INTEGER, INTENT(in   ) :: ncols
    INTEGER, INTENT(in   ) :: kmax
    REAL(KIND=r8),    INTENT(in   ) :: sqrt3
    INTEGER, INTENT(in   ) :: np
    INTEGER, INTENT(in   ) :: lmp1
    INTEGER, INTENT(in   ) :: nsol
    INTEGER, INTENT(in   ) :: nslmp1
    INTEGER, INTENT(in   ) :: nsolnp
    LOGICAL, INTENT(in   ) :: dooz
    REAL(KIND=r8),    INTENT(in   ) :: scosz (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: cosmag(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dsclr (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rvbl  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rvdl  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rnbl  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rndl  (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: agv   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rsurfv(ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rsurfn(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: sl    (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rlo   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rlg   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: tr1   (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: e0    (ncols*(kmax+1))
    REAL(KIND=r8),    INTENT(in   ) :: ozale (ncols*(kmax+2))
    REAL(KIND=r8),    INTENT(in   ) :: swale (ncols*(kmax+2))
    REAL(KIND=r8),    INTENT(inout  ) :: aclr  (ncols*(kmax+1))

    REAL(KIND=r8)                  :: den   (ncols*(kmax+1))
    REAL(KIND=r8)                  :: w     (ncols*(kmax+2))
    REAL(KIND=r8)                  :: dn    (ncols*(kmax+2))
    REAL(KIND=r8)                  :: up    (ncols*(kmax+2))
    REAL(KIND=r8)                  :: vp    (ncols*(kmax+2))
    REAL(KIND=r8)                  :: cm    (ncols*(kmax+2))

    !REAL(KIND=r8), PARAMETER :: fk(5) = (/0.107e0_r8, 0.104e0_r8, 0.073e0_r8, 0.044e0_r8,  0.025e0_r8/)
    !REAL(KIND=r8), PARAMETER :: xk(5) = (/0.005e0_r8, 0.041e0_r8, 0.416e0_r8, 4.752e0_r8, 72.459e0_r8/)

    ! Include global version 2.2 - Increase number of spectral radiation bands
    REAL(KIND=r8), PARAMETER :: fk(10) = (/0.0698e0_r8,0.1558e0_r8,0.0631e0_r8,0.0362e0_r8,0.0243e0_r8, &
         0.0158e0_r8,0.0087e0_r8,0.001467e0_r8,0.002342e0_r8,0.001075e0_r8/)
    REAL(KIND=r8), PARAMETER :: xk(10) = (/0.0002e1_r8,0.0035e1_r8,0.0377e1_r8,0.195e1_r8,0.940e1_r8, &
         4.46e1_r8,19.0e1_r8,98.9e1_r8,270.60e1_r8,3901.1e1_r8/)


    REAL(KIND=r8) :: avbl(ncols)
    REAL(KIND=r8) :: dum(1)
    REAL(KIND=r8) :: expcut

    INTEGER :: i
    INTEGER :: l
    INTEGER :: l0
    INTEGER :: l1
    INTEGER :: lp
    INTEGER :: ik

    expcut=- LOG(1.0e53_r8)
    lp = lmp1 * nsol           ! (KMAX+1)*NSOL
    DO i = 1, nsol
       sl(i) = 0.0_r8
       dn(i) = 0.0_r8
    END DO
    DO i = 1, nslmp1           ! NSOL*(KMAX+1)
       aclr(i) = 0.0_r8
    END DO
    DO l = 1, lmp1             ! (KMAX+1)
       l0 = (l-1) * nsol
       DO i = 1, nsol
          !----------------------------------------------------------------------C
          !---SOLAR DOWNWARD FLUX (DEN) WITHOUT ANY EXTINCTION AT ALL LEVELS-----C
          !----------------------------------------------------------------------C
          den(l0+i) = scosz(i)
       END DO
    END DO
    !----------------------------------------------------------------------C
    !-------DO OZONE ABSORPTION COMPUTATIONS ON THE WAY DOWN---------------C
    !----------------------------------------------------------------------C
    IF (dooz) THEN
       DO l = 2, np            ! (KMAX+2)
          l0 = (l-2) * nsol
          l1 = (l-1) * nsol
          DO i = 1, nsol
             !----------------------------------------------------------------------C
             !---COMPUTE OZONE PATH (W) TILL THE LAYER ON THE WAY DOWN--------------C
             !----------------------------------------------------------------------C
             w(l0+i) = ozale(l1+i) * cosmag(i)   !Magnification factor
          END DO
       END DO
       !----------------------------------------------------------------------C
       !--COMPUTE OZONE  ABSORPTION (DN) TILL THE LAYER ON THE WAY DOWN-------C
       !--USING OZONE ABSORPTION FUNCTION DUE TO Lacis and Hansen (1974)------C
       !----------------------------------------------------------------------C
       DO i = 1, nslmp1        ! NSOL*(KMAX+1)
          e0(i) = 103.63_r8       * w(i)
          e0(i) = e0(i) * e0(i) * e0(i)
          vp(i) = 1.0_r8 + 138.57_r8 * w(i)
          cm(i) = EXP(LOG(vp(i) + 1.0e-100_r8)* 0.805_r8)
       END DO
       DO i = 1, nslmp1        ! NSOL*(KMAX+1)
          dn(nsol+i) = 0.02118_r8 * w(i) &
               / (1.0_r8 + 0.042_r8 * w(i) &
               + 0.000323_r8 * w(i) * w(i)) &
               + 1.08173_r8  * w(i) &
               / cm(i) + 0.0658_r8  * w(i) &
               / (1.0_r8   + e0(i))
       END DO
       !----------------------------------------------------------------------C
       !--COMPUTE OZONE ABSORPTION (ACLR) ON THE WAY DOWN IN EACH LAYER-------C
       !----------------------------------------------------------------------C
       DO i = 1, nslmp1                  !NSOL*(KMAX+1)
          aclr(i) = (dn(nsol+i) - dn(i)) * den(i)
       END DO
    ELSE
       DO i = 1, nsol
          dn(lp+i) = 0.0_r8
       END DO
    END IF
    !
    !     downflux and ground absorption for lamda less than 0.7 microns
    !     as above but for lambda between 0.7 and 0.9 microns
    !
    !----------------------------------------------------------------------C
    !-----DOWNWARD AND UPWARD FLUXES AT GROUND AND GROUND ABSORPTION-------C
    !--FOR WAVELENGTH LESS THAN 0.7 MICRONS--------------------------------C
    !--AS ABOVE AND FOR WAVELENGTH BETWEEN 0.7 AND 0.9 MICRONS-------------C
    !--TAKING INTO ACCOUNT OZONE ABSORPTION, MOLECULAR SCATTERING AND------C
    !--GROUND REFLECTION.--------------------------------------------------C
    !--0.5 is the part of Solar Constant in visible region of spectrum-----C
    !--0.147 is the part of Solar Constant in spectral region--------------C
    !---------from 0.7 to 0.9 mcm------------------------------------------C
    !--TR1(I)=EXP(-TAURAY*M), TAURAY=0.15746, M is Magnification Factor----C
    !--RSURFV..GROUND VISIBLE BEAM ALBEDO----------------------------------C
    !--RLG.....CLEAR SKY AND GROUND REFLECTION FOR GROUND ABSORPTION COMP.-C
    !--AGV.....GROUND VISIBLE DIFFUSE ALBEDO-------------------------------C
    !--RSURFN..GROUND NEAR INFRARED BEAM ALBEDO----------------------------C
    !----------------------------------------------------------------------C
    DO i = 1, nsol
       sl(i)   = 0.5_r8        - dn(lp+i)          !LP=NSOL*(KMAX+1)
       rvbl(i) = sl(i) * tr1(i) * scosz(i)      !Downward visible beam
       avbl(i) = (1.0_r8 - rsurfv(i)) * rvbl(i)    !Net visible beam
       sl(i)   = (1.0_r8 - rlg(i))    * scosz(i) * sl(i)
       rvdl(i) = (sl(i) - avbl(i)) / (1.0_r8 - agv(i))   !Downward visible dif.
       !rnbl(i) = 0.147_r8 * scosz(i)                    !Downward NearIR beam
       !rndl(i) = 0.0_r8*sl(i)                           !Downward NearIR diffuse
       ! Include global version 2.2
       rnbl(i) = 0.1214_r8 * scosz(i)
       rndl(i) = 0.0_r8
       sl(i)   = sl(i) + rnbl(i)  * (1.0_r8 - rsurfn(i)) !Ground absorption
    END DO
    !----------------------------------------------------------------------C
    !------DO OZONE ABSORPTION COMPUTATIONS ON THE WAY DOWN AND UP---------C
    !----------------------------------------------------------------------C
    IF (dooz) THEN
       DO i = 1, nsol
          up(lp+i) = dn(lp+i)
          w(lp+i)  = ozale(lp+i) * (1.90_r8 + cosmag(i))
       END DO
       DO i = 1, nslmp1                !NSOL*(KMAX+1)
          w(i) = 1.9_r8 * ozale(i)
       END DO
       DO l = 1, lmp1                  !(KMAX+1)
          l0 = (l-1) * nsol
          !cdir nodep
          DO i = 1, nsol
             w(l0+i) = w(lp+i) - w(l0+i)
          END DO
       END DO
       DO i = 1, nslmp1                !NSOL*(KMAX+1)
          e0(i) = 103.63_r8 * w(i)
          e0(i) = e0(i)  * e0(i) * e0(i)
          vp(i) = 1.0_r8 + 138.57_r8   * w(i)
          cm(i) = EXP(LOG(vp(i) + 1.0e-100_r8)* 0.805_r8)
       END DO
       DO i = 1, nslmp1                !NSOL*(KMAX+1)
          up(i) = 0.02118_r8 * w(i) &
               / (1.0_r8 + 0.042_r8 * w(i) &
               + 0.000323_r8 * w(i) * w(i)) &
               + 1.08173_r8  * w(i) &
               / cm(i) + 0.0658_r8  * w(i) &
               / (1.0_r8   + e0(i))
       END DO
       !----------------------------------------------------------------------C
       !-----OZONE ABSORPTION (W) IN EACH LAYER ON WAY UP---------------------C
       !----------------------------------------------------------------------C
       DO i = 1, nslmp1
          w(i) = up(i) - up(nsol+i)
       END DO
       !----------------------------------------------------------------------C
       !-------COMPUTE TOTAL OZONE ABSORPTION (ACLR) IN EACH LAYER------------C
       !--RLO....CLEAR SKY AND GROUND REFLECTION FOR OZONE ABSORPTION COMP.---C
       !----------------------------------------------------------------------C
       DO l = 1, lmp1
          l0 = (l-1) * nsol
          DO i = 1, nsol
             aclr(l0+i) = aclr(l0+i) + w(l0+i) * rlo(i) &
                  * scosz(i)
          END DO
       END DO
       !-----------------------SET ACLR>0-------------------------------------C
       dum(1)=0.0e0_r8
       aclr(1:nslmp1) = MAX(aclr(1:nslmp1), 0.0_r8)
    END IF
    !----------------------------------------------------------------------C
    !-------CYCLE OVER TEN WATER VAPOR ABSORPTION COEFFICIENTS (XK)--------C
    !-----------(TAKING FROM EXPONENTIAL EXPANSION OF WATER VAPOR----------C
    !---------- ABSORPTION FUNCTION WITH THE WEIGHTS (FK))-----------------C
    !----------------------------------------------------------------------C
    !DO ik = 1, 5
    ! Include global version 2.2
    DO ik=1,10
       DO l = 1, np                        !KMAX+2
          l0 = (l-1) * nsol
          DO i = 1, nsol
             !----------------------------------------------------------------------C
             !--COMPUTE WATER VAPOR PATH TILL THE LAYER (W) ON THE WAY DOWN---------C
             !----------------------------------------------------------------------C
             w(l0+i) = swale(l0+i) * cosmag(i)
          END DO
       END DO
       IF (ik >= 4) THEN
          DO i = 1, nsolnp                 !NSOL*(KMAX+2)
             dn(i) = -w(i) * xk(ik)
             dn(i) = MAX(dn(i), expcut)
             dn(i) = EXP(dn(i))
          END DO
       ELSE
          DO i = 1, nsolnp                 !NSOL*(KMAX+2)
             !----------------------------------------------------------------------C
             !---WATER VAPOR ABSORPTION TILL THE LAYER (DN) ON THE WAY DOWN---------C
             !----------------------------------------------------------------------C
             dn(i) = EXP(-w(i) * xk(ik))
          END DO
       END IF
       !----------------------------------------------------------------------C
       !--WATER VAPOR ABSOPTION (W) ON THE WAY DOWN IN EACH LAYER-------------C
       !---ACLR..TOTAL OZONE AND WATER VAPOR  ABSORPTIONON THE WAY DOWN IN EACH LAYER
       !---DEN...DOWNWARD FLUX AT THE TOP AT ALL LEVELS
       !----------------------------------------------------------------------C
       DO i = 1, nslmp1             !NSOL*(KMAX+1)
          w(i)    = (dn(i)  - dn(nsol+i)) * fk(ik)
          w(i)    = w(i)    * den(i)
          aclr(i) = aclr(i) + w(i)
       END DO
       !----------------------------------------------------------------------C
       !-----GROUND ABSORPTION (SL) FOR WAVELENGTHS OVER 0.9 MICRONS.---------C
       !------RNBL.....DOWNWARD GROUND NEAR INFRARED DIRECT BEAM FLUX---------C
       !----------------------------------------------------------------------C
       DO i = 1, nsol
          sl(i)   = sl(i)   + dn(lp+i) * (1.0_r8 - rsurfn(i)) &
               * scosz(i) * fk(ik)
          rnbl(i) = rnbl(i) + dn(lp+i) * scosz(i) * fk(ik)
          !----------------------------------------------------------------------C
          !----COMPUTE WATER VAPOR ABSORPTION  ON THE WAY DOWN AND UP,-----------C
          !---UP....WATER VAPOR ABSOPTION ON THE WAY DOWN AND UP TILL THE LAYER--C
          !----------------------------------------------------------------------C
          up(lp+i) = dn(lp+i)
          !----------------------------------------------------------------------C
          !-----W.....WATER VAPOR PATH ON THE WAY DOWN AND UP--------------------C
          !-----MULTIPLIED BY  WATER VAPOR ABSOPTION COEFFICIENT,----------------C
          !-----SQRT3....MAGNIFICATION FACTOR FOR DIFFUSE REFLECTED RADIATION----C
          !----------------------------------------------------------------------C
          w(lp+i)  = swale(lp+i) * (sqrt3 + cosmag(i)) * xk(ik)
       END DO
       DO i = 1, nslmp1
          w(i) = sqrt3 * swale(i) * xk(ik)
       END DO
       DO l = 1, lmp1
          l0 = (l-1) * nsol
          !cdir nodep
          DO i = 1, nsol
             w(l0+i) = w(l0+i) - w(lp+i)
          END DO
       END DO
       up(1:nslmp1) = EXP(w(1:nslmp1))
       !----------------------------------------------------------------------C
       !--WATER VAPOR ABSOPTION (W) ON THE WAY UP IN EACH LAYER---------------C
       !----------------------------------------------------------------------C
       DO i = 1, nslmp1
          w(i) = (up(nsol+i) - up(i)) * fk(ik)
       END DO
       DO l = 1, lmp1
          l0 = (l-1) * nsol
          !cdir nodep
          DO i = 1, nsol
             !----------------------------------------------------------------------C
             !---ACLR......OZONE AND WATER VAPOR ABSORPTION IN EACH LAYER,----------C
             !---RSURFN....GROUND NEAR INFRARED DIRECT BEAM ALBEDO.-----------------C
             !----------------------------------------------------------------------C
             aclr(l0+i) = aclr(l0+i) + w(l0+i) * rsurfn(i) * scosz(i)
          END DO
       END DO
    END DO
    !----------------------------------------------------------------------C
    !----COMPUTE TOTAL GROUND AND CLEAR SKY ABSORPTION (DSCLR)-------------C
    !----------------------------------------------------------------------C
    DO i = 1, nsol
       dsclr(i) = sl(i)
    END DO
    DO l = 1, lmp1
       l0 = (l-1) * nsol
       DO i = 1, nsol
          dsclr(i) = dsclr(i) + aclr(l0+i)
       END DO
    END DO
  END SUBROUTINE clear




  !-----------------------------------------------------------------------
  ! Subroutine: SETSW
  !
  ! CALL TWO MAIN SUBROUTINES: CLEAR AND CLOUDY
  !   Calculates
  !     ozone and water vapor amounts, clear sky
  !     reflectivities, clear sky ozone reflection, clear sky ground
  !     reflection; finds cloud top; computes cloud optical depth,
  !     cloudy sky reflectivities, cloudy sky ozone reflection, cloudy
  !     sky ground reflection.
  !     NUMBER OF CLOUDY DLGP,
  !     NUMBER OF TOP CLOUD LAYER IN EACH DLGP,
  !     COMPRESS OUT CLOUDY DAYTIME LATITUDE GRID POINT (DLGP) VALUES
  !         reflectivities, clear sky ozone reflection, clear sky ground
  !         reflection; finds cloud top; computes cloud optical depth,
  !         cloudy sky reflectivities, cloudy sky ozone reflection, cloudy
  !         sky ground reflection.
  !---------------------------------------------------------------------C
  ! ACRONYMS:
  !   CDLGP...CLOUDY DAYTIME LATITUDE GRID POINTS
  !   DLGP....DAYTIME LATITUDE GRID POINTS
  !   LGP.....LATITUDE GRID POINTS
  !   NSOL....NUMBER OF DAYTIME LATITUDE GRID POINTS
  !   NCLD....NUMBER OF CLOUDY DLGP
  !-----------------------------------------------------------------------

  SUBROUTINE setsw(ncols ,kmax  ,tice  ,icld  ,clwp  ,fice  ,rei   ,taud  , &
       tsea  ,scosz ,cmu   ,cosmag,dsclr ,rvbl  ,scosc ,cmuc  , &
       csmcld,dscld ,rvbc  ,rvdl  ,rnbl  ,rndl  ,agv   ,agn   , &
       rvdc  ,rnbc  ,rndc  ,agncd ,rsurfv,rsurfn,sl    ,sc    , &
       ta    ,wa    ,oa    ,pu    ,aclr  ,dp    ,css   ,acld  , &
       dpc   ,ccu   ,litx  ,listim,bitd  ,sqrt3 ,gg    ,ggp   , &
       ggsq  ,athrd ,tthrd ,rcn1  ,rcn2  ,tcrit ,ecrit ,np    , &
       lmp1  ,nsol  ,nslmp1,nsolnp,ncld  ,ncldp1,nclmp1, &
       ncldnp,dooz  ,rel )  !hmjb

    !==========================================================================
    ! INPUT AND OUTPUT VARIABLES
    !
    !    ncols.....Number of grid points on a gaussian latitude circle
    !    kmax......Number of grid points at vertical
    !    tice......tice=273.16 zero grau absoluto
    !    icld......>>> icld=1     : old cloud emisivity setting
    !                               ccu = ccu*(1-exp(-0.05*dp))
    !                               css = css*(1-exp(-0.01*dp))
    !                                     for ice cloud t<253.0
    !                               css = css*(1-exp(-0.05*dp))
    !                                     for     cloud t>253.0
    !              >>> icld=2     : new cloud emisivity setting
    !                               ccu = 1.0-exp(-0.12*ccu*dp)
    !                               css = 0.0 for      t<-82.5c
    !                               css = 1-exp(-1.5e-6*(t-tcrit)**2*css*dp)
    !                                     for -82.5<t<-10.0
    !                               css = 1-exp(-5.2e-3*(t-273.)-0.06)*css*dp)!
    !                                     for -10.0<t< 0.0
    !                               css = 1-exp(-0.06*css*dp)
    !                                     for t> 0.0c
    !             >>> icld = 3   : ccm3 based cloud emisivity
    !    clwp
    !    fice......controle of change of fase of water
    !    rei.......Ice particle Effective Radius
    !    rel.......Liquid particle Effective Radius
    !    taud......Shortwave cloud optical depth
    !              only works if usind icld=3 or 4 (i.e. arakawa or clirad with ccm3)
    !    tsea
    !    scosz.....scosz(i)   = s0     * cmu(i)
    !                         where s0  is constant solar
    !                               cmu is cosine of solar zenith angle
    !    cmu.......is cosine of solar zenith angle
    !    cosmag....Magnification factor in DLGP
    !    dsclr.....Absorption of clear atmosphere and ground clear
    !    rvbl......Visible beam clear  "Downward ground fluxes in DLGP"
    !    scosc.....scosz(i)   = s0     * cmu(i)
    !                         where s0  is constant solar
    !                               cmu is cosine of solar zenith angle
    !    cmuc......cmuc is cosine of solar zenith angle
    !    csmcld....csmcld = cosmag(i)  = 1224.0 * cmu(i) * cmu(i) + 1.0
    !    dscld.....Total absorption in atmosphere and ground
    !    rvbc......Visible beam cloudy flux
    !    rvdl......Visible diffuse clear
    !    rnbl......NearIR beam clear
    !    rndl......NearIR diffuse clear
    !    agv.......Ground visible diffuse albedo in DLGP
    !    agn.......Ground near IR diffuse albedo in DLGP
    !    rvdc......Visible diffuse cloudy
    !    rnbc......NearIR beam cloudy
    !    rndc......NearIR diffuse cloudy
    !    agncd.....Ground near IR diffuse albedo in CDLGP
    !    rsurfv....Ground visible beam albedo in DLGP
    !    rsurfn....Ground near IR beam albedo in DLGP
    !    sl........Net ground clear flux
    !    sc........Ground absorption
    !    ta........Layer Temperature in DLGP
    !    wa........Layer specific humidity in DLGP
    !    oa........Layer ozone mixing ratio in DLGP
    !    pu........pressure at botton of layer in DLGP
    !    aclr......Absorption in clear ATM
    !    dp........Pressure difference in DLGP
    !    css.......Large scale cloud anount in DLGP
    !    acld......heatinf rate (cloudy)
    !    dpc.......Pressure difference in DLGP
    !    ccu.......cumulus cloud amount in DLGP
    !    litx......Numbers of DLGP in all layers
    !    listim....1,2,3...imax*(kmax+1)
    !    bitd......(.true.) in CDLGP
    !    sqrt3.....Magification factor for diffuse reflected radiation
    !              sqrt3  = SQRT(3.0)
    !    gg........Asymmetry Factor      = 0.85
    !    ggp.......ggp    = gg  / (1.0 + gg) * 0.75
    !    ggsq......ggsq   = gg  * gg
    !    athrd.....constant athrd  = 1.0 / 3.0
    !    tthrd.....constant tthrd  = 2.0 / 3.0
    !    rcn1......constant  rcn1   = 1.0 / 6.55
    !    rcn2......constant  rcn2   = 1.0 / 4.47238
    !    tcrit.....constant tcrit  = tice - 82.5
    !    ecrit.....ecrit  = 0.0105125
    !    np........np     = (kmax+2)
    !    lmp1......lmp1   = (kmax+1)
    !    nsol......Number of solar latitude grid points (cosz>0.01)
    !    nsolp1....nsolp1=nsol+1
    !    nslmp1....nslmp1=nsol*(kmax +1 ), where nsol is number of solar
    !              latitude grid points (cosz>0.01)
    !    nsolnp....nsolnp=nsol*(kmax +2 ), where nsol is number of solar
    !              latitude grid points (cosz>0.01)
    !    ncld......Number of cloudy DLGP
    !    ncldp1....ncldp1=NCLD+1
    !    nclmp1....nclmp1=NCLD*(kmax+1)
    !    ncldnp....ncldnp=NCLD*(kmax+2)
    !    dooz......dooz   = (.NOT. noz) where : noz = .FALSE.
    !               (do ozone computation )
    !-----------------------------------------------------------------------

    INTEGER, INTENT(in   ) :: ncols
    INTEGER, INTENT(in   ) :: kmax
    REAL(KIND=r8),    INTENT(in   ) :: tice
    REAL(KIND=r8),    INTENT(in   ) :: clwp(ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: fice(ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: rei (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: rel (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: taud(ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: tsea(ncols)
    INTEGER, INTENT(in   ) :: icld


    REAL(KIND=r8),    INTENT(in   ) :: sqrt3
    REAL(KIND=r8),    INTENT(in   ) :: gg
    REAL(KIND=r8),    INTENT(in   ) :: ggp
    REAL(KIND=r8),    INTENT(in   ) :: ggsq
    REAL(KIND=r8),    INTENT(in   ) :: athrd
    REAL(KIND=r8),    INTENT(in   ) :: tthrd
    REAL(KIND=r8),    INTENT(in   ) :: rcn1
    REAL(KIND=r8),    INTENT(in   ) :: rcn2
    REAL(KIND=r8),    INTENT(in   ) :: tcrit
    REAL(KIND=r8),    INTENT(in   ) :: ecrit
    INTEGER, INTENT(in   ) :: np
    INTEGER, INTENT(in   ) :: lmp1
    INTEGER, INTENT(in   ) :: nsol
    INTEGER, INTENT(in   ) :: nslmp1
    INTEGER, INTENT(in   ) :: nsolnp
    INTEGER, INTENT(inout  ) :: ncld
    INTEGER, INTENT(inout  ) :: ncldp1
    INTEGER, INTENT(inout  ) :: nclmp1
    INTEGER, INTENT(inout  ) :: ncldnp
    LOGICAL, INTENT(in   ) :: dooz


    REAL(KIND=r8),    INTENT(in   ) :: scosz (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: cmu   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: cosmag(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dsclr (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rvbl  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: scosc (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: cmuc  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: csmcld(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dscld (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rvbc  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rvdl  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rnbl  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rndl  (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: agv   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: agn   (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rvdc  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rnbc  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rndc  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: agncd (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rsurfv(ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rsurfn(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: sl    (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: sc    (ncols)
    REAL(KIND=r8),    INTENT(inout) :: ta    ((ncols*(kmax+1)))
    REAL(KIND=r8),    INTENT(inout) :: wa    ((ncols*(kmax+1)))
    REAL(KIND=r8),    INTENT(inout  ) :: oa    ((ncols*(kmax+1)))
    REAL(KIND=r8),    INTENT(inout) :: pu    ((ncols*(kmax+2)))
    REAL(KIND=r8),    INTENT(inout  ) :: aclr  ((ncols*(kmax+1)))
    REAL(KIND=r8),    INTENT(in   ) :: dp    ((ncols*(kmax+1)))
    REAL(KIND=r8),    INTENT(inout  ) :: css   ((ncols*(kmax+1)))
    REAL(KIND=r8),    INTENT(inout  ) :: acld  ((ncols*(kmax+1)))
    REAL(KIND=r8),    INTENT(inout) :: dpc   ((ncols*(kmax+1)))
    REAL(KIND=r8),    INTENT(inout) :: ccu   ((ncols*(kmax+1)))
    INTEGER, INTENT(in   ) :: litx  ((ncols*(kmax+1)))
    INTEGER, INTENT(in   ) :: listim((ncols*(kmax+2)))
    LOGICAL, INTENT(inout  ) :: bitd  ((ncols*(kmax+2)))

    !---- LOCAL VARIABLES --------------------------------------------------

    REAL(KIND=r8)    :: agvcd (ncols) ! AGVCD (NCLD)...GROUND VISIBLE DIFFUSE
    ! ALBEDO IN CDLGP (SETSW)
    REAL(KIND=r8)    :: rlo   (ncols) ! Clear sky and ground reflection in
    ! DLGP for ozone computation
    REAL(KIND=r8)    :: rlg   (ncols) ! Clear sky and ground reflection in
    ! DLGP for ground absorption computation
    REAL(KIND=r8)    :: rsvcd (ncols) ! Ground Viseible beam albedo
    REAL(KIND=r8)    :: rsncd (ncols) ! Ground near infrared beam albedo
    REAL(KIND=r8)    :: rco   (ncols) ! Cloudy an ground reflection for ozone
    ! absorption comp.
    REAL(KIND=r8)    :: rcg   (ncols) ! Cloudy and ground reflection for ground
    ! absoption computation in visible region of spectrum
    REAL(KIND=r8)    :: taut  (ncols) ! Downward visible beam
    REAL(KIND=r8)    :: rc2   (ncols) ! Cloudy and ground reflection for ground absoption
    ! computation in region of spectrum from 0.7 to 0.9 mcm
    REAL(KIND=r8)    :: tr1   (ncols) ! Extinction of beam radiation (clear)
    REAL(KIND=r8)    :: tr2   (ncols) ! Extinction of beam radiation (cloud)
    REAL(KIND=r8)    :: tr3   (ncols) ! Extinction of beam radiation (Cloud, Raley)
    REAL(KIND=r8)    :: e0    ((ncols*(kmax+1))) ! cloud optical depth
    REAL(KIND=r8)    :: ozale ((ncols*(kmax+2))) ! Ozone amount in column in DLGP
    REAL(KIND=r8)    :: ozcd  ((ncols*(kmax+2))) ! ozone amount in column in CDLGP
    REAL(KIND=r8)    :: swale ((ncols*(kmax+2))) ! water vapor amount in column in DLGP
    REAL(KIND=r8)    :: swil  ((ncols*(kmax+1))) ! water vapor amount in layer in DLGP
    REAL(KIND=r8)    :: swilc ((ncols*(kmax+1))) ! water vapor amount in layer in CDLGP
    REAL(KIND=r8)    :: tauc  ((ncols*(kmax+1))) ! Cloud optical depth in cloudy DLGP
    INTEGER :: litd  ((ncols*(kmax+2))) ! numbers de CDLGP in all layers
    LOGICAL :: bitc  ((ncols*(kmax+2))) ! Working logical dimension


    REAL(KIND=r8)    :: clwp1 (ncols,kmax)
    REAL(KIND=r8)    :: clwp1a((ncols*(kmax+1)))
    REAL(KIND=r8)    :: tauxcl(ncols,kmax)
    REAL(KIND=r8)    :: tauxci(ncols,kmax)

    INTEGER :: icl (ncols)
    INTEGER :: icc (ncols)
    REAL(KIND=r8)    :: dum (1)
    REAL(KIND=r8)    :: arg1(ncols)
    REAL(KIND=r8)    :: a1  (ncols)
    REAL(KIND=r8)    :: e1  (ncols)
    REAL(KIND=r8)    :: upim(ncols)
    REAL(KIND=r8)    :: dnim(ncols)
    REAL(KIND=r8)    :: rc1 (ncols)
    REAL(KIND=r8)    :: tlim(ncols)
    REAL(KIND=r8)    :: g   (ncols)
    REAL(KIND=r8)    :: taui(ncols)
    REAL(KIND=r8)    :: b1  (ncols)
    REAL(KIND=r8)    :: c1  (ncols)

    REAL(KIND=r8)                   :: expcut
    REAL(KIND=r8),    PARAMETER     :: abarl=2.261e-2_r8
    REAL(KIND=r8),    PARAMETER     :: bbarl=1.4365_r8
    REAL(KIND=r8),    PARAMETER     :: abari=3.448e-3_r8
    REAL(KIND=r8),    PARAMETER     :: bbari=2.431_r8
    INTEGER                :: i
    INTEGER                :: l
    INTEGER                :: l0
    INTEGER                :: l1
    INTEGER                :: k
    INTEGER                :: kflip
    INTEGER                :: lm
    INTEGER                :: nsollm
    REAL(KIND=r8)                   :: tmp1l
    REAL(KIND=r8)                   :: tmp1i

    !---- SUBROUTINE STARTS HERE -------------------------------------------

    clwp1a=0.0_r8
    expcut=- LOG(1.0e53_r8)

    !-----------------------------------------------------------------------
    !   ZERO OUT OZONE BELOW 500 MB
    !-----------------------------------------------------------------------
    IF (dooz) THEN
       !---------------------------------------------------------------------C
       !------SET BITC=.TRUE. IF LAYER PRESSURE PU>500 mb--------------------C
       !---------------------------------------------------------------------C
       DO i = 1, nslmp1
          bitc(i) = pu(nsol+i).gt.500.0e0_r8
       END DO
       !---------------------------------------------------------------------C
       !------SET OZONE MIXING RATIO OA=0 IF LAYER PRESSURE PU>500 mb--------C
       !---------------------------------------------------------------------C
       WHERE(bitc(1:nslmp1)) oa(1:nslmp1)=0.0e0_r8
       !-----------------------------------------------------------------------
       !      compute ozone and water vapor amounts
       !-----------------------------------------------------------------------
       DO i=1,nsol
          ozale(i) = 0.0_r8
       END DO
       DO i=1,nslmp1                     ! NSOL*(KMAX+1)
          oa(i) = 476.0_r8 * oa(i) * dp(i)  ! Ozone amount in layer
       END DO                            ! DP...Pressure difference
       DO l=2,np
          l0 = (l-2) * nsol
          l1 = (l-1) * nsol
          !cdir nodep
          DO i=1,nsol
             ozale(l1+i) = ozale(l0+i) + oa(l0+i)
          END DO
       END DO
    END IF
    !---------------------------------------------------------------------C
    !--COMPUTE WATER VAPOR AMOUNT IN cm FROM SPECIFIC HUMIDITY IN g/g-----C
    !--SWALE (NSOL(KMAX+2)------------------------------------------------C
    !------WATER VAPOR AMOUNT IN ATMOSPHERE COLUMN ABOVE THE LAYER--------C
    !---------------------------------------------------------------------C
    DO i=1,nsol
       swale(i) = 0.0_r8
    END DO
    DO i=1,nsolnp     ! NSOL*(KMAX+2)
       pu(i) = pu(i) * pu(i)
    END DO
    swil(1:nslmp1)=sqrt(ta(1:nslmp1))
    DO i=1,nslmp1
       swil(i) = 120.1612_r8    * swil(i)
       swil(i) = (pu(nsol+i) - pu(i)) &
            * wa(i)       / swil(i) ! WA is specific humidity
    END DO
    DO l=2,np  !KMAX+2
       l0 = (l-2) * nsol
       l1 = (l-1) * nsol
       !cdir nodep
       DO i=1,nsol
          swale(l1+i) = swale(l0+i) + swil(l0+i)
       END DO
    END DO
    !-------------------------------------------------------------------------------C
    !     compute clear sky reflectivities
    !     clear sky ozone reflection, tauray=0.85
    !-------------------------------------------------------------------------------C
    !  RLO (NSOL)..CLEAR SKY AND GROUND REFLECTION FOR OZONE ABSORPTION COMPUTATION
    !  TAURAY=0.85 OPTICAL THICKNESS OF MOLECULAR SCATTERING IN UV SPECTRUM REGION
    !-------------------------------------------------------------------------------C
    DO i=1,nsol
       e1(i) = -0.85_r8 * cosmag(i)  !Magnification factor
       e1(i) = EXP(e1(i))
    END DO
    DO i=1,nsol
       b1(i)   = 3.0_r8 * cmu(i)    !Cosine solar zenith angle
       c1(i)   = 2.0_r8 - b1(i)
       b1(i)   = 2.0_r8 + b1(i)
       ! Eq. (3.6) - Rad. Doc. by J.Chagas & T.Tarasova
       a1(i)   = (b1(i) + c1(i) * e1(i)) * rcn1  ! 1.0_r8/6.55_r8
       upim(i) = 1.0_r8 - a1(i)
       ! Eq. (3.7) - Rad. Doc. by J.Chagas & T.Tarasova
       dnim(i) = a1(i) - e1(i)
       ! Eq. (3.5) - Rad. Doc. by J.Chagas & T.Tarasova
       rlo(i)  = upim(i) + (e1(i) * rsurfv(i) & !Ground,visible,beam alb.
            + dnim(i) * agv(i)) &               !Ground,visible,diffuse albedo
            * 0.576004_r8 / (1.0_r8 - 0.423996_r8 * agv(i))
       ! Eq. (3.4) - Rad. Doc. by J.Chagas & T.Tarasova
       rlo(i)  = tthrd * rsurfv(i) + athrd  * rlo(i)   !ATHRD=1.0/3.0
       !TTHRD=2.0/3.0
       !-------------------------------------------------------------------------------C
       !     clear sky ground reflection, tauray=0.15746
       !-------------------------------------------------------------------------------C
       !  RLG(NSOL)..CLEAR SKY AND GROUND REFLECTION FOR GROUND ABSORPTION COMPUTATION
       !  TAURAY=0.15746..OPTICAL THICKNESS OF MOLECULAR SCATTERING IN VISIBLE SPECTRUM REGION
       !-------------------------------------------------------------------------------C
       e1(i)   = -0.15746_r8 * cosmag(i)
       e1(i)   = EXP(e1(i))
    END DO
    DO i=1,nsol
       tr1(i)  = e1(i)
       a1(i)   = (b1(i) + c1(i) * e1(i)) * rcn2  ! 1.0/4.47238
       upim(i) = 1.0_r8 - a1(i)
       dnim(i) = a1(i) - e1(i)
       rlg(i)  = upim(i) + (e1(i)  * rsurfv(i) &
            + dnim(i) * agv(i)) * 0.88_r8 &
            / (1.0_r8 - 0.12_r8  * agv(i))
    END DO
    !-----------------------------------------------------------------------
    ! CALL SUBROUTINE CLEAR TO CALCULATE CLEAR SKY FLUXES
    !   computes for cycles over five bands ozone heating, radiational
    !   downflux and ground absorption, and water vapor heating.
    !-----------------------------------------------------------------------
    CALL clear (ncols ,kmax  ,sqrt3 ,np    ,lmp1  ,nsol  ,nslmp1,nsolnp, &
         dooz  ,scosz ,cosmag,dsclr ,rvbl  ,rvdl  ,rnbl  ,rndl  , &
         agv   ,rsurfv,rsurfn,sl    ,rlo   ,rlg   ,tr1   ,e0    , &
         ozale ,swale ,aclr                                       )

    !-----------------------------------------------------------------------
    ! FIND CLOUD TOP
    !-----------------------------------------------------------------------
    ! SET CLOUD AMOUNT as Maximum cloudiness
    DO i = 1, nslmp1
       css(i)=MAX(ccu(i),css(i))
    END DO

    !-----------------------------------------------------------------------
    ! FIND NUMBER OF TOP CLOUD LAYER ICC(NSOL) IN EACH LGP
    ! After this, icc stores, for each DLGP the layer id of the
    ! highest layer with clouds. If no clouds, icc stores np=kmax+2
    !-----------------------------------------------------------------------
    DO i=1,nsol
       icc(i) = np     !KMAX+2
    END DO
    DO k=1,lmp1              ! loop over all layers
       l=np-k                ! layer id goes from bottom (kmax+1) to TOA (1)
       l0 = (l-1) * nsol + 1 ! first position (I=1) of this layer in css matrix
       !-----------------------------------------------------------------------
       ! SET LOGICAL BITC(NSOL*(KMAX+2)=.TRUE. IF CLOUD AMOUNT CSS>0
       ! in the l-th layer, i.e., for all DLGP in this layer
       !-----------------------------------------------------------------------
       dum(1)=0.0e0_r8
       DO i = 1, nsol
          bitc(i) = css(l0+i-1).gt.0.0e0_r8
       END DO

       ! if there is a cloudy in this layer, over some of the DLGP,
       ! then we save the layer id in vector icc
       WHERE (bitc(1:nsol)) icc(1:nsol) = l
    END DO

    !-----------------------------------------------------------------------
    ! SET BITD(NSOL)=.TRUE. IF CLOUDS ARE AT ANY LAYER IN LGP
    !   NCLD........NUMBER OF CLOUDY LGP
    !   ICC(NSOL)...NUMBER OF TOP CLOUD LAYER IN EACH LGP
    ! Since icc has the index of the top cloud layer for each DLGP, it
    ! is only necessary to check which of the indexes are different
    ! from kmax+2=np to know if there is any cloud at all over this DLGP
    !-----------------------------------------------------------------------
    bitd(1:nsol) = icc(1:nsol) /= np
    ncld=COUNT(bitd(1:nsol))

    ! If there are no clouds, then copy clear fluxes over cloudy ones
    ! and exit from subroutine
    IF (ncld == 0) THEN    ! Cloudy fluxes are equal clear sky fluxes
       DO i=1,nslmp1       ! NSOL*(KMAX+1)
          acld(i) = aclr(i)
       END DO
       DO i=1,nsol
          sc(i)    = sl(i)
          dscld(i) = dsclr(i)
          rndc(i)  = rndl(i)
          rvdc(i)  = rvdl(i)
          rnbc(i)  = rnbl(i)
          rvbc(i)  = rvbl(i)
       END DO
       RETURN
    END IF
    !-----------------------------------------------------------------------
    ! SET NEW PARAMETERS FROM NCLD
    !-----------------------------------------------------------------------
    ncldp1 = ncld + 1
    nclmp1 = ncld * lmp1   !NCLD *(KMAX+1)
    ncldnp = ncld * np     !NCLD *(KMAX+2)
    !-----------------------------------------------------------------------
    ! COMPLETE BITD(NSOL(KMAX+1))
    ! Repeat the values we assigned for the first row (1:nsol) over
    ! all the other rows (2:kmax+2)
    !-----------------------------------------------------------------------
    DO l=1,lmp1       ! KMAX+1
       l1 = l * nsol + 1
       bitd(l1:l1+nsol-1) = icc(1:nsol) /= np
    END DO
    !-----------------------------------------------------------------------
    ! compress out cloudy grid point values for ozone amt., water amt.scosz, etc.
    !   NCLDNP....NCLD(KMAX+2)
    !   NSOLNP....NSOL(KMAX+2)
    !   LITD(NCLD*(KMAX+2))....NUMBERS OF CLOUDY DLGP
    !-----------------------------------------------------------------------
    litd(1:COUNT(bitd(1:nsolnp))) = PACK(listim(1:nsolnp), bitd(1:nsolnp))
    DO i = 1, ncld
       IF (litd(i)<=nsol) THEN
          icl(i)=icc(litd(i))
          cmuc(i)=cmu(litd(i))
          agvcd(i)=agv(litd(i))
          agncd(i)=agn(litd(i))
          rsvcd(i)=rsurfv(litd(i))
          rsncd(i)=rsurfn(litd(i))
          scosc(i)=scosz(litd(i))
          csmcld(i)=cosmag(litd(i))
       END IF
    END DO
    DO i = 1, nclmp1
       IF (litd(i)<=nslmp1) &
            swilc(i)=swil(litd(i))
    END DO
    IF (dooz) THEN
       DO i = 1, ncldnp
          IF(litd(i).le.nsolnp) ozcd(i)=ozale(litd(i))
       END DO
       !-----------------------------------------------------------------------
       !      make ozone amount constant below cloud top
       !-----------------------------------------------------------------------
       DO l=1,lmp1
          bitc(1:ncld) = icl(1:ncld) <= l
          l0 = (l-1) * ncld
          l1 =  l    * ncld
          DO i = 1, ncld
             IF(bitc(i)) ozcd(l1+i)=ozcd(l0+i)
          END DO
       END DO
    END IF
    !-----------------------------------------------------------------------
    ! VALUES IN CLOUDY DAYTIME LATITUDE GRID POINTS (DLGP)
    !-----------------------------------------------------------------------
    ! ICL......NUMBER OF TOP CLOUD LAYER
    ! CMUC.....COSINE SOLAR ZENITH ANGLE
    ! AGVCD....GROUND VISIBLE DIFFUSE ALBEDO
    ! AGNCD....GROUND NEAR IR DIFFUSE ALBEDO
    ! RSVCD....GROUND VISIBLE BEAM ALBEDO
    ! RSNCD....GROUND NEAR IR BEAM ALBEDO
    ! SCOSC....SOLAR FLUX AT ATMOSPHERE TOP
    !-----------------------------------------------------------------------

    !-----------------------------------------------------------------------
    !     compute cloud optical depth
    !     icld = 1   : old cloud emisivity setting
    !     icld = 2   : new cloud emisivity setting
    !-----------------------------------------------------------------------
    IF (icld == 1) THEN
       DO i=1,nslmp1
          e0(i)   = 0.05_r8
          bitc(i) = (ta(i)  .LT. 253.0_r8) &
               .AND. (ccu(i) .EQ. 0.0_r8)
       END DO
       WHERE (bitc(1:nslmp1)) e0(1:nslmp1)=0.025_r8

    ELSE IF (icld == 2) THEN
       DO i=1,nslmp1
          e0(i) = (ta(i) - tcrit)
       END DO
       DO i = 1, nslmp1
          e0(i)=MAX(1.0e0_r8,e0(i))
       END DO

       DO i=1,nslmp1
          tauc(i) = 2.0e-6_r8 * e0(i) * e0(i)
       END DO
       DO i = 1, nslmp1
          tauc(i)=MIN(ecrit,tauc(i))
       END DO

       DO i=1,nslmp1
          e0(i) = 6.94875e-3_r8 * (ta(i) - tice) + 0.08_r8
       END DO

       DO i = 1, nslmp1
          e0(i)=min(0.08_r8,max(ecrit,e0(i)))
          bitc(i)=e0(i).eq.ecrit
       END DO

       WHERE (bitc(1:nslmp1)) e0(1:nslmp1)=tauc(1:nslmp1)
       bitc(1:nslmp1)=ccu(1:nslmp1)>0.0e0_r8
       WHERE(bitc(1:nslmp1)) e0(1:nslmp1)=0.16e0_r8

    ELSE IF (icld == 3) THEN
       DO k=1,kmax
          kflip=kmax+1-k
          DO i=1,ncols
             tmp1l = abarl + bbarl/rel(i,k)
             tmp1i = abari + bbari/rei(i,k)
             tauxcl(i,k) = clwp(i,k)*tmp1l*(1.0_r8-fice(i,k))
             tauxci(i,k) = clwp(i,k)*tmp1i*fice(i,k)
             IF (tsea(i) > 0.0_r8) THEN
                clwp1(i,kflip)=0.70_r8*(tauxcl(i,k)+tauxci(i,k))
             ELSE
                clwp1(i,kflip)=1.0_r8*(tauxcl(i,k)+tauxci(i,k))
             END IF
             taud(i,k)=clwp1(i,kflip)
          END DO
       END DO
       lm=(kmax)
       nsollm=nsol*lm

       DO i = 1, nsollm
          IF (litx(i).LE.ncols*kmax) clwp1a(nsol+i)=clwp1(litx(i),1)
       END DO

       DO i=1,nslmp1
          ! the extra cloud fraction idea from ncar
          e0(i) = SQRT(css(i))*css(i)*clwp1a(i)
       END DO
    END IF
    !-----------------------------------------------------------------------
    ! DPC...PRESSURE DIFFERENSE
    ! CSS...CLOUD AMOUNT
    ! E0....CLOUD OPTICAL DEPTH
    !-----------------------------------------------------------------------
    IF (icld /= 3) THEN
       DO i=1,nslmp1
          e0(i) = e0(i) * dpc(i) * css(i)
       END DO
    END IF
    !-----------------------------------------------------------------------
    ! TRANSFORM E0 TO TAUC IN CLOUDY DLGP
    !-----------------------------------------------------------------------

    DO i = 1, nclmp1
       IF (litd(i).le.nslmp1) tauc(i)=e0(litd(i))
    END DO

    DO i=1,ncld
       taut(i) = 0.0_r8
    END DO
    DO l=1,lmp1
       l0 = (l-1) * ncld
       DO i=1,ncld
          taut(i) = taut(i) + tauc(l0+i)
       END DO
    END DO
    !
    !     compute cloudy sky reflectivities
    !     cloudy sky ozone reflection, tauray=0.0_r8, gcld=0.85_r8
    !
    !-----CLOUDY SKY AND GROUND REFLECTION FOR GROUND ABSORPTION ---------C
    !-----------COMPUTATION IN SPECTRUM REGION FROM 0.7 TO 0.9 mcm--------C
    !-------------------------RC2(NCLD)-----------------------------------C
    !-----TAURAY=0.0....MOLECULAR OPTICAL DEPTH IN NEAR INFRARED REGION---C
    !-----GCLD=0.85...ASYMMETRY FACTOR OF CLOUD PARTICLES PHASE FUNCTION--C
    DO i=1,ncld
       tlim(i) = 1.0_r8 / (1.0_r8 + 0.1299_r8 * taut(i))
       arg1(i) = -0.2775_r8 * taut(i) * csmcld(i)  ! Magnification factor in CDLGP
       e1(i)   = EXP(arg1(i))
    END DO
    DO i=1,ncld
       tr2(i)  = e1(i)
       b1(i)   = 3.0_r8 * cmuc(i)
       c1(i)   = 2.0_r8 - b1(i)
       b1(i)   = 2.0_r8 + b1(i)
       a1(i)   = b1(i)   + c1(i)  * e1(i)
       a1(i)   = a1(i)   / (4.0_r8 + 0.45_r8 * taut(i))
       upim(i) = 1.0_r8          - a1(i)
       dnim(i) = a1(i)   - e1(i)
       rc1(i)  = upim(i) + (e1(i)    * rsvcd(i) &
            + dnim(i) * agvcd(i)) * tlim(i) &
            / (1.0_r8 - (1.0_r8  - tlim(i))  * agvcd(i))
       rc2(i)  = upim(i) + (e1(i)    * rsncd(i) &
            + dnim(i) * agncd(i)) * tlim(i) &
            / (1.0_r8 - (1.0_r8  - tlim(i))  * agncd(i))
       !
       !     cloudy sky ozone reflection, tauray=0.85, gcld=0.85
       !
       !--CLOUDY SKY AND GROUND REFLECTION FOR OZONE ABSORPTION COMPUTATION--C
       !-------------------RCO(NCLD)-----------------------------------------C
       !-----TAURAY=0.85..MOLECULAR OPTICAL DEPTH IN UV REGION OF SPECTRUM---C
       !-----GCLD=0.85....ASYMMETRY FACTOR OF CLOUD PARTICLE PHASE FUNCTION--C
       taui(i) = taut(i) + 0.85_r8
       g(i)    = 0.85_r8 * taut(i) / taui(i)
       tlim(i) = 1.0_r8  / (1.0_r8 + 0.866_r8 * (1.0_r8 - g(i)) &
            * taui(i))
       arg1(i) = - (1.0_r8 - g(i) * g(i)) &
            * taui(i)     * csmcld(i)
       e1(i)   = EXP(arg1(i))
    END DO
    DO i=1,ncld
       a1(i)   = b1(i) + c1(i) * e1(i)
       a1(i)   = a1(i) / (4.0_r8 + 3.0_r8 * (1.0_r8 - g(i)) &
            * taui(i))
       upim(i) = 1.0_r8          - a1(i)
       dnim(i) = a1(i)   - e1(i)
       rco(i)  = upim(i) + (e1(i)    * rsvcd(i) &
            + dnim(i) * agvcd(i)) * tlim(i) &
            / (1.0_r8 - (1.0_r8  - tlim(i))  * agvcd(i))
       rco(i)  = tthrd * rc1(i) + athrd * rco(i)
       !
       !     cloudy sky ground reflection, tauray=0.15746, gcld=0.85
       !
       !-----------CLOUDY SKY AND GROUND REFLECTION--------------------------C
       !-----------FOR GROUND ABSORPTION COMPUTATION IN VISIBLE SPECTRUM-----C
       !------------------------RCG(NCLD)------------------------------------C
       !--TAURAY=0.15746..MOLECULAR OPTICAL DEPTH IN VISIBLE SPECTRUM--------C
       !--GCLD=0.85..ASYMMETRY FACTOR OF CLOUD PARTICLE PHASE FUNCTION-------C
       taui(i) = taut(i)        + 0.15746_r8
       g(i)    = 0.85_r8 * taut(i) / taui(i)
       tlim(i) = 1.0_r8  / (1.0_r8 + 0.866_r8 * (1.0_r8 - g(i)) &
            * taui(i))
       arg1(i) = -(1.0_r8 - g(i) * g(i)) &
            * taui(i)     * csmcld(i)
       e1(i)   = EXP(arg1(i))
    END DO
    DO i=1,ncld
       tr3(i)  = e1(i)
       a1(i)   = b1(i) + c1(i) * e1(i)
       a1(i)   = a1(i) / (4.0_r8 + 3.0_r8 * (1.0_r8 - g(i)) &
            * taui(i))
       upim(i) = 1.0_r8 - a1(i)
       dnim(i) = a1(i)   - e1(i)
       rcg(i)  = upim(i) + (e1(i)    * rsvcd(i) &
            + dnim(i) * agvcd(i)) * tlim(i) &
            / (1.0_r8 - (1.0_r8  - tlim(i))  * agvcd(i))
    END DO

    !-----------------------------------------------------------------------
    ! CALL SUBROUTINE CLOUDY TO CALCULATE CLOUDY SKY FLUXES
    !   computes  ozone heating, downflux and ground absorption, water
    !   vapor heating and computes for cycles over five bands total
    !   optical depth, reflection and transmission for diffuse
    !   incidence,direct transmission, diffuse reflection and
    !   transmission for direct beam, upward and dwonward fluxes at
    !   layer boundaries, absorption in the column.
    !-----------------------------------------------------------------------

    CALL cloudy (ncols ,kmax  ,scosc ,cmuc  ,csmcld,dscld ,rvbc  ,rvdc  , &
         rnbc  ,rndc  ,agvcd ,agncd ,rsvcd ,rsncd ,sc    ,rco   , &
         rcg   ,taut  ,rc2   ,tr1   ,tr2   ,tr3   ,ta    ,wa    , &
         oa    ,e0    ,pu    ,ozcd  ,swale ,swil  ,css   ,acld  , &
         dpc   ,swilc ,ccu   ,tauc  ,litd  ,sqrt3 ,gg    ,ggp   , &
         ggsq  ,np    ,lmp1  ,nsol  ,ncld  ,nclmp1,ncldnp,dooz    )

  END SUBROUTINE setsw


  !-----------------------------------------------------------------------
  ! Subroutine: SWRAD
  !
  ! MAIN SUBROUTINE FOR SOLAR RADIATION COMPUTATIONS
  ! CALL ONE MAIN SUBROUTINE:  SETSW
  !   COMPRESSES TWO-SIZE INPUT ARRAYES
  !   TO ONE-SIZE ARRAYES IN DAYTIME LATITUDE GRID POINTS (DLGP)
  !   CALCULATE DIRECT SURFACE ALBEDO FROM DIFFUSE ONES,
  !   CALCULATE DIFFUSE MAGNIFICATION FACTOR (Rodgers, 1967)
  !   SET OUTPUT SHORTWAVE RADIATIVE FLUXES IN ALL LGP.
  !---------------------------------------------------------------------C
  ! ACRONYMS:
  !   CDLGP...CLOUDY DAYTIME LATITUDE GRID POINTS
  !   DLGP....DAYTIME LATITUDE GRID POINTS
  !   LGP.....LATITUDE GRID POINTS
  !   NSOL....NUMBER OF DAYTIME LATITUDE GRID POINTS
  !   NCLD....NUMBER OF CLOUDY DLGP
  !-----------------------------------------------------------------------
  SUBROUTINE swrad(ncols ,kmax  ,nls   ,dtc3  ,noz   ,icld  ,s0    ,inalb , &
       alvdf ,alndf ,alvdr ,alndr ,cosz  ,pl20  ,dpl   ,tl    , &
       ql    ,o3l   ,cld   ,clu   ,swinc ,dswclr,dswtop,ssclr , &
       ss    ,aslclr,asl   ,radvbl,radvdl,radnbl,radndl,radvbc, &
       radvdc,radnbc,radndc,clwp  ,fice  ,rei   ,taud  ,tsea  , rel  )
    !
    ! >>> inalb= 1    : input two  types surfc albedo (2 diffused)
    !                   direct beam albedos are calculated by the subr.
    ! >>> inalb= 2    : input four types surfc albedo (2 diff,2 direct)
    ! >>> icld = 1    : old cloud emisivity (optical depth) setting
    !             ccu :     0.05 *dp
    !             css :     0.025*dp             for ice cloud t<253.0
    !                       0.05 *dp             for ice cloud t>253.0
    ! >>> icld = 2    : new cloud emisivity (optical depth) setting
    !             ccu :     (0.16)*dp
    !             css :      0.0                         t<-82.5c
    !                       (2.0e-6*(t-tcrit)**2)*dp    -82.5<t<-10.0c
    !                       (6.949e-3*(t-273)+.08)*dp   -10.0<t< 0.0c
    !                       (0.08)*dp                   -10.0<t< 0.0c
    ! >>> icld = 3    : ccm3 based cloud emisivity
    !
    !==========================================================================
    !   imax......Number of grid points on a gaussian latitude circle
    !   kmax......Number of grid points at vertical
    !   nls.......number of layers in the stratosphere.
    !   dtc3......Coefficient for heating rate claculation dtc3 = 1.0e0
    !   noz.......Logical (true when no ozone computation)
    !   icld......Input two types of cloud emissivity
    !             =1 : old cloud emissivity setting
    !             =2 : new cloud emissivity setting
    !   s0........Solar constant  at proper sun-earth distance
    !   inalb.....Input two types of surface albedo
    !             =1 : two diffuse (beam albedos are calculated)
    !             =2 : two diffuse , and two beam albedos
    !                  avisd,anird, avisb,anirb
    !   alvdf.....visible diffuse surface albedo
    !   alndf.....near-ir diffuse surface albedo
    !   alvdr.....visible beam surface albedo
    !   alndr.....near-ir beam surface albedo
    !   cosz......Cosine of zenith angle
    !   pl20......Flip array of pressure at bottom of layers (mb)
    !             flip arrays (k=1 means top of atmosphere)
    !             pl20(i,k)=gps(i)*sigml(kflip) where
    !                         gps   =  surface pressure   (mb)
    !                         sigml =  sigma coordinate at bottom of layer
    !   dpl.......Flip array  of pressure difference bettween levels
    !             flip arrays (k=1 means top of atmosphere)
    !   tl........Flip array of temperature in kelvin
    !   ql........Flip array of specific humidity in g/g
    !   o3l.......Ozone mixing ratio (g/g) in 18 layers and in all latitude grids
    !   cld.......Large scale cloud amount
    !   clu.......cumulus cloud amount
    !   swinc.....Solar flux at top of atmosphere
    !   dswclr....Absorption in the clear atmosphere and at the ground
    !   dswtop....Absorption in the cloudy atmosphere and at the ground
    !   ssclr.....Absorption  at the ground in clear case
    !   ss........Absorption at the ground in cloudy case
    !   aslclr....Heating rate (clear case) (K/s)
    !   asl.......Heating rate (cloudy case) (K/s)
    !   radvbl....Downward Surface shortwave fluxe visible beam (clear)
    !   radvdl....Downward Surface shortwave fluxe visible diffuse (clear)
    !   radnbl....Downward Surface shortwave fluxe Near-IR beam (clear)
    !   radndl....Downward Surface shortwave fluxe Near-IR diffuse (clear)
    !   radvbc....Downward Surface shortwave fluxe visible beam (cloudy)
    !   radvdc....Downward Surface shortwave fluxe visible diffuse (cloudy)
    !   radnbc....Downward Surface shortwave fluxe Near-IR beam (cloudy)
    !   radndc....Downward Surface shortwave fluxe Near-IR diffuse (cloudy)
    !   clwp......Cloud liquid water path
    !   fice......Controle of change of fase of water
    !   rei.......Ice particle Effective Radius
    !   rel.......Liquid particle Effective Radius
    !   taud......Shortwave cloud optical depth
    !             only works if usind icld=3 or 4 (i.e. arakawa or clirad with ccm3)
    !   tsea......effective surface radiative temperature ( tgeff )
    !==========================================================================

    INTEGER, INTENT(in   ) :: ncols
    INTEGER, INTENT(in   ) :: kmax
    INTEGER, INTENT(in   ) :: nls
    REAL(KIND=r8),    INTENT(in   ) :: dtc3
    LOGICAL, INTENT(in   ) :: noz
    INTEGER, INTENT(in   ) :: icld
    REAL(KIND=r8),    INTENT(in   ) :: s0
    INTEGER, INTENT(in   ) :: inalb
    REAL(KIND=r8),    INTENT(in   ) :: alvdf  (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: alndf  (ncols)
    REAL(KIND=r8),    INTENT(inout) :: alvdr  (ncols)
    REAL(KIND=r8),    INTENT(inout) :: alndr  (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: cosz   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: pl20   (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: dpl    (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: tl     (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: ql     (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: o3l    (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: cld    (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: clu    (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: swinc  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dswclr (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dswtop (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: ssclr  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: ss     (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: aslclr (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: asl    (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: radvbl (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: radvdl (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: radnbl (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: radndl (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: radvbc (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: radvdc (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: radnbc (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: radndc (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: clwp   (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: fice   (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: rei    (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: taud   (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: tsea   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: rel    (ncols,kmax) !hmjb

    !---- LOCAL VARIABLES --------------------------------------------------

    REAL(KIND=r8)    :: sqrt3   ! =SQRT(3.0_r8)
    REAL(KIND=r8)    :: gg      ! =0.85_r8
    REAL(KIND=r8)    :: ggp     ! =GG/(1.0_r8+GG)*0.75_r8
    REAL(KIND=r8)    :: ggsq    ! =GG*GG
    REAL(KIND=r8)    :: athrd   ! =1.0_r8/3.0_r8
    REAL(KIND=r8)    :: tthrd   ! =2.0_r8/3.0_r8
    REAL(KIND=r8)    :: rcn1    ! =1.0_r8/6.55_r8
    REAL(KIND=r8)    :: rcn2    ! =1.0_r8/4.47238_r8
    REAL(KIND=r8)    :: tcrit   ! =TICE-82.5_r8=273.16_r8-82.5_r8
    REAL(KIND=r8)    :: ecrit   ! =0.0105125_r8
    INTEGER :: im      ! =IMAX
    INTEGER :: np      ! =KMAX+2
    INTEGER :: npp1    ! =KMAX+3
    INTEGER :: lmp1    ! =KMAX+1
    INTEGER :: ls1
    INTEGER :: ls
    INTEGER :: nsol    ! NUMBER OF SOLAR LATITUDE GRID POINTS (COSZ>0.01)
    INTEGER :: nsolp1  ! NSOL+1
    INTEGER :: nslmp1  ! NSOL*(KMAX+1)
    INTEGER :: nsolnp  ! NSOL*(KMAX+2)
    INTEGER :: ncld    ! NUMBER OF CLOUDY DLGP
    INTEGER :: ncldp1  ! NCLD+1
    INTEGER :: nclmp1  ! NCLD*(KMAX+1)
    INTEGER :: ncldnp  ! NCLD*(KMAX+2)
    LOGICAL :: dooz    ! DO OZONE CALCULATION (.NOT.NOZ)

    REAL(KIND=r8)    :: scosz (ncols) ! DOWNWARD FLUX AT TOP IN DLGP
    REAL(KIND=r8)    :: cmu   (ncols) ! COSINE OF SOLAR ZENITH ANGLE IN DLGP
    REAL(KIND=r8)    :: cosmag(ncols) ! MAGNIFICATION FACTOR IN DLGP
    REAL(KIND=r8)    :: dsclr (ncols) ! ABSORPTION OF CLEAR ATMOSPHERE AND GROUND-CLEAR
    REAL(KIND=r8)    :: scosc (ncols) ! DOWNWARD FLUX AT TOP IN CLOUDY DLGP
    REAL(KIND=r8)    :: cmuc  (ncols) ! COSINE OF SOLAR ZENITH ANGLE IN CDLGP
    REAL(KIND=r8)    :: csmcld(ncols) ! MAGNIFICATION FACTOR IN CDLGP
    REAL(KIND=r8)    :: dscld (ncols)
    REAL(KIND=r8)    :: rvbl  (ncols) ! VISIBLE, BEAM, CLEAR                      (CLEAR )
    REAL(KIND=r8)    :: rvbc  (ncols) ! VISIBLE, BEAM, CLOUDY                     (CLOUDY)
    REAL(KIND=r8)    :: rvdl  (ncols) ! VISIBLE, DIFFUSE, CLEAR                   (CLEAR )
    REAL(KIND=r8)    :: rnbl  (ncols) ! NearIR, BEAM, CLEAR                       (CLEAR )
    REAL(KIND=r8)    :: rndl  (ncols) ! NearIR, DIFFUSE, CLEAR                    (CLEAR )
    REAL(KIND=r8)    :: agv   (ncols) ! GROUND VISIBLE DIFFUSE ALBEDO IN DLGP     (SWRAD )
    REAL(KIND=r8)    :: agn   (ncols) ! GROUND NEAR IR DIFFUSE ALBEDO IN DLGP     (SWRAD )
    REAL(KIND=r8)    :: rvdc  (ncols) ! VISIBLE, DIFFUSE, CLOUDY                  (CLOUDY)
    REAL(KIND=r8)    :: rnbc  (ncols) ! NearIR, BEAM, CLOUDY                      (CLOUDY)
    REAL(KIND=r8)    :: rndc  (ncols) ! NearIR, DIFFUSE, CLOUDY                   (CLOUDY)
    REAL(KIND=r8)    :: agncd (ncols) ! GROUND NEAR IR DIFFUSE ALBEDO IN CDLGP    (SETSW )
    REAL(KIND=r8)    :: rsurfv(ncols) ! GROUND VISIBLE BEAM ALBEDO IN DLGP        (SWRAD )
    REAL(KIND=r8)    :: rsurfn(ncols) ! GROUND NEAR IR BEAM ALBEDO IN DLGP        (SWRAD )
    REAL(KIND=r8)    :: sl    (ncols) ! NET GROUND CLEAR FLUX                     (CLEAR )
    REAL(KIND=r8)    :: sc    (ncols)
    REAL(KIND=r8)    :: ta    ((ncols*(kmax+1))) ! LAYER TEMPERATURE IN DLGP           (SWRAD)
    REAL(KIND=r8)    :: wa    ((ncols*(kmax+1))) ! LAYER SPECIFIC HUMIDITY IN DLGP     (SWRAD)
    REAL(KIND=r8)    :: oa    ((ncols*(kmax+1))) ! LAYER OZONE MIXING RATIO IN DLGP    (SWRAD)
    REAL(KIND=r8)    :: pu    ((ncols*(kmax+2))) ! PRESSURE AT BOTTOM OF LAYER IN DLGP (SWRAD)

    REAL(KIND=r8)    :: aclr  ((ncols*(kmax+1)))! ABSORPTION IN CLEAR ATM.             (CLEAR)
    REAL(KIND=r8)    :: dp    ((ncols*(kmax+1)))! PRESSURE DIFFERENCE IN DLGP          (SWRAD)
    REAL(KIND=r8)    :: css   ((ncols*(kmax+1)))! LARGE SCALE CLOUD AMOUNT IN DLGP     (SWRAD)
    REAL(KIND=r8)    :: acld  ((ncols*(kmax+1)))! HEATING RATE                         (CLOUDY)
    REAL(KIND=r8)    :: dpc   ((ncols*(kmax+1)))! PRESSURE DIFFERENCE IN DLGP          (SWRAD)
    REAL(KIND=r8)    :: ccu   ((ncols*(kmax+1)))! CUMULUS CLOUD AMOUNT IN DLGP         (SWRAD)
    INTEGER :: litx  ((ncols*(kmax+1)))! NUMBERS OF DLGP IN ALL LAYERS        (SWRAD)
    INTEGER :: listim((ncols*(kmax+2)))! =1,2,3...IMAX*(KMAX+1)               (SWRAD)
    LOGICAL :: bitx  ((ncols*(kmax+1)))! (.TRUE.) IN SOLAR LATITUDE GRID POINTS
    LOGICAL :: bitd  ((ncols*(kmax+2)))! (.TRUE.) IN CLOUDY DLGP
    LOGICAL :: bitn((ncols*(kmax+2)))

    !-------------------------------------------------------------------C
    !-----FAC1...COEFFICIENT FOR COMPUTING HEATING RATE-----------------C
    !-----DAY....NUMBER OF SECONDS IN DAY-------------------------------C
    !-------------------------------------------------------------------C
    REAL(KIND=r8), PARAMETER        :: fac1=8.441874377_r8
    REAL(KIND=r8), PARAMETER        :: day =86400.0_r8
    REAL(KIND=r8), PARAMETER        :: pai =3.141592653589793_r8
    REAL(KIND=r8), PARAMETER        :: tice=273.16_r8
    INTEGER                :: lm
    REAL(KIND=r8)                   :: fac
    REAL(KIND=r8)                   :: p1em9
    REAL(KIND=r8)                   :: p1em22
    REAL(KIND=r8)                   :: expcut
    INTEGER                :: i
    INTEGER                :: k
    INTEGER                :: il
    INTEGER                :: nsol2
    INTEGER                :: nsl2p1
    INTEGER                :: nsollm
    INTEGER                :: nzercd
    INTEGER                :: nlimwa
    INTEGER                :: nrstwa
    INTEGER                :: nwa1
    INTEGER                :: l
    INTEGER                :: l1


    !---- SUBROUTINE STARTS HERE -------------------------------------------
    dooz   = (.NOT. noz)
    lm     = kmax
    im     = ncols
    np     = (kmax+2)
    npp1   = np+1
    lmp1   = (kmax+1)
    ls1    = nls+1
    ls     = nls
    !-----------------------------------------------------------------------
    ! FAC...Coefficient for heating rate calculation in K/s
    ! DTC3 can be changed as input parameter
    !-----------------------------------------------------------------------
    fac    = fac1  * dtc3 / day        !  8.441874*(1/86400)
    sqrt3  = SQRT(3.0_r8)
    gg     = 0.85_r8
    ggsq   = gg  * gg                  !  0.85**2
    ggp    = gg  / (1.0_r8 + gg) * 0.75_r8   !  0.85/(1+0.85)*0.75
    rcn1   = 1.0_r8 / 6.55_r8
    rcn2   = 1.0_r8 / 4.47238_r8
    athrd  = 1.0_r8 / 3.0_r8
    tthrd  = 2.0_r8 / 3.0_r8
    tcrit  = tice - 82.5_r8               !  273.16-82.5
    ecrit  = 0.0105125_r8
    p1em9 = .1e-9_r8
    p1em22= .1e-22_r8
    acld = 0.0_r8
    sc   = 0.0_r8
    expcut=- LOG(1.0e53_r8)
    !-----------------------------------------------------------------------
    ! SET ARRAY LISTIM = I, WHEN I=1,ncols*(kmax+2)
    !-----------------------------------------------------------------------
    DO i = 1, ncols*(kmax+2)
       listim(i)=i
    END DO

    !-----------------------------------------------------------------------
    ! set bits for daytime grid points
    !-----------------------------------------------------------------------
    bitx(1:ncols)=cosz(1:ncols).ge.0.01e0_r8
    !-----------------------------------------------------------------------
    ! CALCULATE NSOL = NUMBER OF DAYTIME LATITUDE GRID POINTS
    !-----------------------------------------------------------------------
    nsol=COUNT(bitx(1:ncols))
    !-----------------------------------------------------------------------
    ! SET ZERO TO ALL LATITUDE GRIDS SURFACE FLUXES
    !-----------------------------------------------------------------------
    DO i = 1, im
       swinc(i)  = 0.0_r8
       ss(i)     = 0.0_r8
       ssclr(i)  = 0.0_r8
       dswtop(i) = 0.0_r8
       dswclr(i) = 0.0_r8
       radvbl(i) = 0.0_r8
       radvdl(i) = 0.0_r8
       radnbl(i) = 0.0_r8
       radndl(i) = 0.0_r8
       radvbc(i) = 0.0_r8
       radvdc(i) = 0.0_r8
       radnbc(i) = 0.0_r8
       radndc(i) = 0.0_r8
    END DO
    DO k=1,kmax
       DO il = 1,ncols
          asl(il,k)    = 0.0_r8
          aslclr(il,k) = 0.0_r8
       END DO
    END DO

    !-----------------------------------------------------------------------
    ! IF THERE ARE NO DAYTIME POINTS THEN RETURN
    !-----------------------------------------------------------------------
    IF (nsol == 0) RETURN

    nsolp1     = nsol   + 1
    nsol2      = nsol   + nsol
    nsl2p1     = nsol2  + 1
    nslmp1     = nsol   * lmp1
    nsollm     = nsol   * lm
    nsolnp     = nsol   * np
    nzercd     = nsol   * ls1
    nlimwa     = nsol   * ls
    nrstwa     = nslmp1 - nlimwa
    nwa1       = nlimwa + 1
    !-----------------------------------------------------------------------
    ! SET BITX IN ALL GRID POINTS AT ALL LEVELS AS AT FIRST LEVEL
    !   BITX IS (.TRUE.) IN DAYTIME GRID POINTS
    !   SIZE OF BITX IS IMLMP1=NCOLS*(KMAX+1)
    !-----------------------------------------------------------------------
    DO l = 1, lm
       l1 = l * im
       DO i = 1, im
          bitx(l1+i)=bitx(i)
       END DO
    END DO
    !-----------------------------------------------------------------------
    ! SET PRESSURE AT FIRST AND SECOND LEVELS FOR RADIATION ONLY
    !-----------------------------------------------------------------------
    DO i = 1, nsol
       pu(i) = 0.0_r8
    END DO
    DO i = nsolp1, nsol2    !NSOL+1....2*NSOL
       pu(i) = 0.5_r8
    END DO
    !-----------------------------------------------------------------------
    ! SET INTEGER ARRAY LITX (NSOL*(KMAX+1))
    ! NUMBERS OF LATITUDE DAYTIME GRID POINTS AT ALL LEVELS, USING
    ! INTEGER ARRAY LISTIM (NCOLS*(KMAX+1)) = 1,2,....NCOLS*(KMAX+1)
    !-----------------------------------------------------------------------
    litx(1:COUNT(bitx(1:(ncols*(kmax+1))))) = &
         PACK(listim(1:(ncols*(kmax+1))), bitx(1:(ncols*(kmax+1))))
    !-----------------------------------------------------------------------
    !  TRANSFORM  TWO-SIZE  INPUT ARRAYS:
    !        PL20(NCOLS,KMAX),DPL,TL,QL,CLD,CLU
    !  IN ONE-SIZE ARRAYS:
    !        PU(NSOL*(KMAX+2)),DP(NSOL*(KMAX+1)),TA,WA,CSS,CCU
    !  IN DAYTIME LATITUDE GRID POINTS AT ALL LEVELS -> LITX(NSOL*KMAX)
    !-----------------------------------------------------------------------
    DO i = 1, nsollm
       IF (litx(i).le.(ncols*kmax)) THEN
          pu(nsol2+i)=pl20(litx(i),1)
          dp(nsol+i)=dpl(litx(i),1)
          ta(nsol+i)=tl(litx(i),1)
          wa(nsol+i)=ql(litx(i),1)
          css(nsol+i)=cld(litx(i),1)
          ccu(nsol+i)=clu(litx(i),1)
       END IF
    END DO
    !-----------------------------------------------------------------------
    ! IF OZONE IS INCLUDED
    ! TRANSFORM  TWO-SIZE  INPUT ARRAY O3L(NCOLS,KMAX)
    ! IN ONE-SIZE ARRAY OA(NSOL*KMAX) IN DAYTIME LATITUDE GRID POINTS
    !-----------------------------------------------------------------------
    IF (dooz) THEN
       DO i = 1, nsollm
          IF (litx(i).le.(ncols*kmax)) oa(nsol+i)=o3l(litx(i),1)
       END DO
       DO i = 1, nsol
          oa(i) = oa(nsol+i)
       END DO
       DO i = 1, nslmp1
          oa(i)=MAX(p1em9,oa(i))
       END DO
    END IF
    !-----------------------------------------------------------------------
    ! THE SAME TRANSFORMATION AS MENTIONED ABOVE FOR:
    !   VISIBLE SURFACE ALBEDO....ALVDF to AGV
    !   NearIR SURFACE ALBEDO.....ALNDF to AGN
    !   COSINE OF SOLAR ZENITH ANGLE..COSZ to CMU
    !-----------------------------------------------------------------------
    DO i = 1, nsol
       IF (litx(i).le.im) THEN
          agv(i)=alvdf(litx(i))
          agn(i)=alndf(litx(i))
          cmu(i)=cosz(litx(i))
       END IF
    END DO
    !-----------------------------------------------------------------------
    ! IF DIRECT BEAM ALBEDOS ARE GIVEN THEN
    ! ALVDR TRANSFORM TO RSURFV(NSOL) AND ALNDR TO RSURFN(NSOL)
    ! IN DAYTIME GRID POINTS
    !-----------------------------------------------------------------------
    IF (inalb == 2) THEN
       DO i = 1, nsol
          IF (litx(i).le.im) THEN
             rsurfv(i)=alvdr(litx(i))
             rsurfn(i)=alndr(litx(i))
          END IF
       END DO
    ELSE
       !-----------------------------------------------------------------------
       ! IF DIRECT BEAM ALBEDOS ARE NOT GIVEN THEN DO THE REVERSE
       ! CALCULATE DIRECT BEAM SURFACE ALBEDO
       !-----------------------------------------------------------------------
       rvbl(1:nsol)=acos(cmu(1:nsol)) ! RVBL... solar zenith angle
       DO i = 1, nsol
          rvdc(i)  =  -18.0_r8 * (0.5_r8 * pai - rvbl(i)) / pai
          rvbc(i)  =  EXP(rvdc(i))
       END DO
       DO i = 1, nsol
          rvdc(i)  = (agv(i) - 0.054313_r8) / 0.945687_r8
          rndc(i)  = (agn(i) - 0.054313_r8) / 0.945687_r8
          rsurfv(i) = rvdc(i)+(1.0_r8-rvdc(i))*rvbc(i)
          rsurfn(i) = rndc(i)+(1.0_r8-rndc(i))*rvbc(i)
       END DO
       DO i = 1, im
          alvdr(i) = 0.0_r8
          alndr(i) = 0.0_r8
       END DO
       DO i = 1, nsol
          alvdr(litx(i))=rsurfv(i)
          alndr(litx(i))=rsurfn(i)
       END DO
    END IF
    !-----------------------------------------------------------------------
    ! SET SOME PARAMETERS AT FIRST, SECOND AND THIRD LEVELS
    !-----------------------------------------------------------------------
    DO i = 1, nsol
       dp(i) = pu(nsol+i)    ! pressure differense
       ta(i) = ta(nsol+i)    ! temperature
       wa(i) = wa(nsol+i)    ! specific humidity
    END DO
    DO i = 1, nslmp1         ! NSOL*(KMAX+1)
       dpc(i) = dp(i)        ! DPC...pressure differense
    END DO
    DO i = 1, nzercd         ! NSOL*3
       css(i) = 0.0_r8
       ccu(i) = 0.0_r8
    END DO
    DO i = 1, nlimwa         ! NSOL*2
       wa(i) = 3.0e-6_r8
    END DO
    DO i = nwa1,(nwa1+nrstwa-1)
       wa(i)=MAX(p1em22,wa(i)) ! nrstwa=nsol*(kmax+1)-nsol*2
    END DO

    !-----------------------------------------------------------------------
    ! CALCULATION OF MAGNIFICATION FACTOR (Rodgers, 1967)
    ! CMU.......COSINE OF SOLAR ZENITH ANGLE AT DLGP
    !-----------------------------------------------------------------------
    DO i = 1, nsol
       cosmag(i)  = 1224.0_r8 * cmu(i) * cmu(i) + 1.0_r8
    END DO
    cosmag(1:nsol) = sqrt(cosmag(1:nsol))
    DO i = 1, nsol
       cosmag(i)  = 35.0_r8   / cosmag(i)
       scosz(i)   = s0     * cmu(i)  ! DOWNWARD SOLAR FLUX AT TOP
    END DO
    !-----------------------------------------------------------------------
    ! TRANSFORM SCOSZ(NSOL) TO SWINC(NCOLS) AT ALL LGP
    !-----------------------------------------------------------------------
    DO i = 1,nsol
       swinc(litx(i))=scosz(i)
    END DO
    !-----------------------------------------------------------------------
    ! CALL SUBROUTINE SETSW TO CALCULATE SOLAR FLUXES
    ! SETSW CALLS CLEAR AND CLOUDY TO CALCULATE:
    !   CLEAR:  dsclr,sl,aclr,rvbl,rvdl,rnbl,rndl
    !   CLOUDY: dscld,sc,acld,rvbc,rvdc,rnbc,rndc
    ! The values are packed at the begining of the arrays.
    ! Instead of occupying 1..ncols, they cover only the range 1..nsol
    !-----------------------------------------------------------------------
    CALL setsw(ncols ,kmax  ,tice  ,icld  ,clwp  ,fice  ,rei   ,taud  , &
         tsea  ,scosz , cmu  ,cosmag,dsclr ,rvbl  ,scosc ,cmuc  , &
         csmcld,dscld ,rvbc  ,rvdl  ,rnbl  ,rndl  ,agv   ,agn   , &
         rvdc  ,rnbc  ,rndc  ,agncd ,rsurfv,rsurfn,sl    ,sc    , &
         ta    ,wa    ,oa    ,pu    ,aclr  ,dp    ,css   ,acld  , &
         dpc   ,ccu   ,litx  ,listim,bitd  ,sqrt3 ,gg    ,ggp   , &
         ggsq  ,athrd ,tthrd ,rcn1  ,rcn2  ,tcrit ,ecrit ,np    , &
         lmp1  ,nsol  ,nslmp1,nsolnp,ncld  ,ncldp1,nclmp1, &
         ncldnp,dooz  , rel   )

    !-----------------------------------------------------------------------
    ! SET SOLAR FLUXES AT ALL LATITUDE GRID POINTS
    ! For CLEAR it is already set.
    ! If there are any clouds, then copy the clear values over the
    ! zero's in the cloudy vectors, to complete the cloudy fields.
    !   BITD(nslmp1)=.TRUE. IF CLOUD IN LAYER OVER A DLGP
    !   BITN(nslmp1)=.TRUE. IF CLEAR SKY IN LAYER OVER A DLGP
    !-----------------------------------------------------------------------

    !hmjb??? What happen if ncld=0? I think that cloudy-arrays will
    ! have null values. Maybe clear->cloudy should be done always.

    IF (ncld /= 0) THEN
       bitn(1:nslmp1)=.not.bitd(1:nslmp1)
       DO i = 1,nslmp1
          IF (bitn(i)) acld(i)=aclr(i)
       END DO
       DO i = 1,nsol
          IF (bitn(i)) THEN
             rvbc(i)=rvbl(i)
             rvdc(i)=rvdl(i)
             rnbc(i)=rnbl(i)
             rndc(i)=rndl(i)
             sc(i)=sl(i)
             dscld(i)=dsclr(i)
          END IF
       END DO
    END IF
    !-----------------------------------------------------------------------
    ! SET SOLAR FLUXES IN ALL GRID POINTS
    ! All values are nsol-packed and need to be unpacked
    ! This is done by copying values from positions (1:nsol) to
    ! positions litx(1:nsol).
    !-----------------------------------------------------------------------
    DO i = 1,nsol
       ! clear
       ssclr(litx(i))=sl(i)
       dswclr(litx(i))=dsclr(i)
       radvbl(litx(i))=rvbl(i)
       radvdl(litx(i))=rvdl(i)
       radnbl(litx(i))=rnbl(i)
       radndl(litx(i))=rndl(i)

       ! cloudy
       ss(litx(i))=sc(i)
       dswtop(litx(i))=dscld(i)
       radvbc(litx(i))=rvbc(i)
       radvdc(litx(i))=rvdc(i)
       radnbc(litx(i))=rnbc(i)
       radndc(litx(i))=rndc(i)
    END DO

    DO i = 1,nsollm
       aslclr(litx(i),1)=aclr(nsol+i)
       asl(litx(i),1)=acld(nsol+i)
    END DO


    !-----------------------------------------------------------------------
    ! CALCULATION OF SOLAR HEATING RATE IN K/s
    !-----------------------------------------------------------------------
    DO k=1,kmax
       DO i = 1, ncols
          IF (aslclr(i,k) < 1.e-22_r8) aslclr(i,k)=0.0_r8
          aslclr(i,k) = aslclr(i,k) * fac / dpl(i,k)
          IF (asl(i,k) < 1.e-22_r8) asl(i,k) = 0.0_r8
          asl(i,k)    = asl(i,k)    * fac / dpl(i,k)
       END DO
    END DO

  END SUBROUTINE swrad





  SUBROUTINE cldgn2 ( &
       covlp ,gps   ,sig   ,grh   ,omg   ,gtmp  ,css   ,ccu   , &
       cdin  ,cstc  ,ccon  ,cson  ,mxrdcc,lcnvl ,convc ,convt ,convb , &
       convts,convcs,convbs,ncols ,kmax  ,nls                  )

    ! parameters and input variables:                                     c
    !        covlp = 'maxi'         maximum overlap of convective cloud   c
    !                               or thick low cloud used in ir subr.   c
    !              = 'rand'         random  overlap of convective cloud   c
    !                               or thick low cloud used in ir subr.   c
    !        date  =  julian day of model forecast date                   c
    !        grh   =  relative humidity  (g/g)                            c
    !        omg   =  vertical velocity  (cb/sec)                         c
    !        gps   =  surface pressure   (mb)                             c
    !        sig   =  sigma coordinate at middle of layer                 c
    !        gtmp  =  layer temperature (k)                               c
    ! output variables:                                                   c
    !        css   =  ncols*kmax supersatuation cloud cover fraction      c
    !        ccu   =  ncols*kmax convective cloud cover fraction          c
    !
    ! values from subr-gwater:                                            c
    !       convc  =  ncols convective cloud cover in 3 hr. avrage   c
    !       convt  =  ncols convective cloud top  (sigma layer)      c
    !       convb  =  ncols convective cloud base (sigma layer)      c
    !==========================================================================
    !
    !
    !   ncols.....Number of grid points on a gaussian latitude circle
    !   kmax......Number of grid points at vertical
    !   nls..... .Number of layers in the stratosphere.
    !   cdin
    !   cstc......cstc=clow change necessary in order to properly mark inv
    !             cloud height
    !   ccon......convc  =  ncols convective cloud cover in 3 hr. avrage
    !   cson
    !   cp........Specific heat of air (j/kg/k)
    !   gasr......Constant of dry air      (j/kg/k)
    !   mxrdcc....use maximum random converage for radiative conv. clouds
    !             constant logical mxrdcc = .true.
    !   lcnvl.....the lowest layer index where non-convective clouds can
    !             occur (ben says this should be 2 or more)
    !             constant lcnvl = 2
    !   convts
    !   convcs
    !   convbs
    !
    !
    INTEGER,          INTENT(in ) :: ncols
    INTEGER,          INTENT(in ) :: kmax
    INTEGER,          INTENT(in ) :: nls
    CHARACTER(len=4), INTENT(in ) :: covlp
    REAL(KIND=r8),             INTENT(in ) :: gps (ncols)
    REAL(KIND=r8),             INTENT(in ) :: sig (kmax)
    REAL(KIND=r8),             INTENT(in ) :: grh (ncols,kmax)
    REAL(KIND=r8),             INTENT(in ) :: omg (ncols,kmax)
    REAL(KIND=r8),             INTENT(in ) :: gtmp(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout) :: css (ncols,kmax)
    REAL(KIND=r8),             INTENT(inout) :: ccu (ncols,kmax)
    REAL(KIND=r8),             INTENT(inout) :: cdin(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout) :: cstc(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout) :: ccon(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout) :: cson(ncols,kmax)

    LOGICAL,          INTENT(in ) :: mxrdcc
    INTEGER,          INTENT(in ) :: lcnvl
    REAL(KIND=r8),             INTENT(in ) :: convc (ncols)
    REAL(KIND=r8),             INTENT(in ) :: convt (ncols)
    REAL(KIND=r8),             INTENT(in ) :: convb (ncols)

    REAL(KIND=r8),             INTENT(in ) :: convts(ncols)
    REAL(KIND=r8),             INTENT(in ) :: convcs(ncols)
    REAL(KIND=r8),             INTENT(in ) :: convbs(ncols)


    REAL(KIND=r8)                          :: pll   (ncols,kmax)
    REAL(KIND=r8)                          :: conv  (ncols)
    REAL(KIND=r8)                          :: clow  (ncols)
    REAL(KIND=r8)                          :: cmid  (ncols)
    REAL(KIND=r8)                          :: chigh (ncols)
    INTEGER                       :: ktop  (ncols)
    INTEGER                       :: kbot  (ncols)
    INTEGER                       :: klow  (ncols)
    INTEGER                       :: kmid  (ncols)
    INTEGER                       :: khigh (ncols)
    REAL(KIND=r8)                          :: pt    (ncols)
    REAL(KIND=r8)                          :: cinv  (ncols)
    REAL(KIND=r8)                          :: delomg(ncols)
    REAL(KIND=r8)                          :: csat  (ncols,kmax)
    INTEGER                       :: ktops (ncols)
    INTEGER                       :: kbots (ncols)
    REAL(KIND=r8)                          :: convs (ncols)
    REAL(KIND=r8)                          :: convh (ncols)
    INTEGER                       :: invb  (ncols)
    REAL(KIND=r8)                          :: dthdpm(ncols)
    INTEGER                       :: i
    INTEGER                       :: k
    INTEGER                       :: kl
    INTEGER                       :: lon
    REAL(KIND=r8)                          :: zrth
    REAL(KIND=r8)                          :: zrths
    REAL(KIND=r8)                          :: arcp
    REAL(KIND=r8)                          :: dthdp
    !
    !     dthdpm-----min (d(theta)/d(p))
    !     invb ------the base of inversion layer
    !     dthdpc-----criterion of (d(theta)/d(p))
    !
    REAL(KIND=r8), PARAMETER               :: dthdpc = -0.4e-1_r8

    REAL(KIND=r8), PARAMETER               :: f6p67= 6.67e0_r8
    REAL(KIND=r8), PARAMETER               :: f400p= 4.0e2_r8
    REAL(KIND=r8), PARAMETER               :: f700p= 7.0e2_r8
    REAL(KIND=r8), PARAMETER               :: f0p6 = 0.6e0_r8
    REAL(KIND=r8), PARAMETER               :: f0p2 = 0.2e0_r8
    REAL(KIND=r8), PARAMETER               :: f0p8 = 0.8e0_r8
    REAL(KIND=r8), PARAMETER               :: f5m5 = 5.0e-5_r8
    REAL(KIND=r8), PARAMETER               :: f1e4 = 1.0e+4_r8


    DO k = 1, kmax
       DO i = 1, ncols
          css (i,k) = 0.0e0_r8
          ccu (i,k) = 0.0e0_r8
          csat(i,k) = 0.0e0_r8
          cdin(i,k) = 0.0e0_r8
          cstc(i,k) = 0.0e0_r8
          ccon(i,k) = 0.0e0_r8
          cson(i,k) = 0.0e0_r8
       END DO
    END DO
    !
    !     the clouds generation scheme is based on j. slingo              c
    !     (1984 ecmwf workshop).  the scheme generates 4 type of clouds   c
    !     of convective, high, middle and low clouds.                     c
    !
    DO kl = 1, kmax
       DO lon = 1,ncols
          pll(lon,kl) = gps(lon) * sig(kl)
       END DO
    END DO
    !
    !     initialization
    !
    DO lon = 1,ncols
       conv(lon)  = convc(lon)
       convh(lon) = convc(lon)
       clow(lon)  = 0.0_r8
       cinv(lon)  = 0.0_r8
       cmid(lon)  = 0.0_r8
       chigh(lon) = 0.0_r8
       ktop(lon)  = convt(lon)+0.5_r8
       IF (ktop(lon).LT.1.OR.ktop(lon).GT.kmax) ktop(lon)=1
       kbot(lon)  = convb(lon)+0.5_r8
       IF (kbot(lon).LT.1.OR.kbot(lon).GT.kmax) kbot(lon)=1
       klow(lon)  = 1
       kmid(lon)  = 1
       khigh(lon) = 1
       convs(lon) = convcs(lon)
       ktops(lon) = convts(lon)+0.5_r8
       IF (ktops(lon).LT.1.OR.ktops(lon).GT.kmax) ktops(lon)=1
       kbots(lon) = convbs(lon)+0.5_r8
       IF (kbots(lon).LT.1.OR.kbots(lon).GT.kmax) kbots(lon)=1
       !
       !     1. define convective cloud ***   done in subr-gwater
       !     cloud top and base are defined by kuo scheme: convt, convb
       !     cloud amount is calculated from precipitation rate : convc
       !     single layer clouds conputations start here, from bottom up
       !
       !     define high clouds due to strong convection
       !
       pt(lon) = gps(lon) * sig(ktop(lon))
       IF ((pt(lon) <= f400p).AND. (conv(lon) > 0.0_r8)) THEN
          chigh(lon) = 2.0_r8*convh(lon)
          chigh(lon) = MIN(chigh(lon),1.0_r8)
          khigh(lon) = ktop(lon) + 1
       END IF
       IF (ktop(lon)-kbot(lon) >= 1) THEN
          zrth=1.0_r8/REAL(ktop(lon)-kbot(lon),r8)
          conv(lon)=1.0_r8-(1.0_r8-conv(lon))**zrth
       END IF
       IF (ktops(lon)-kbots(lon) >= 1) THEN
          zrths=1.0_r8/REAL(ktops(lon)-kbots(lon),r8)
          convs(lon)=1.0_r8-(1.0_r8-convs(lon))**zrths
       END IF
    END DO
    !
    !     compute low stratus associated with inversions, based on ecwmf's
    !     scheme, with lower criterion of d(theta)/d(p)
    !
    arcp = gasr / cp

    DO lon = 1, ncols
       invb(lon) = MIN(kmax,kmax-nls)
       dthdpm(lon) = 0.0_r8
    END DO

    DO kl = 2, kmax
       DO lon = 1, ncols
          IF (pll(lon,kl) > f700p) THEN
             dthdp = (gtmp(lon,kl-1)*(1000.0_r8/pll(lon,kl-1))**arcp &
                  -gtmp(lon,kl)*(1000.0_r8/pll(lon,kl))**arcp)/ &
                  (pll(lon,kl-1) - pll(lon,kl))
             IF (dthdp < 0.0_r8) THEN
                invb(lon) = MIN(kl-1,invb(lon))
                IF(dthdp.LT.dthdpc) THEN
                   IF(dthdp.LT.dthdpm(lon)) THEN
                      dthdpm(lon)=dthdp
                      klow(lon)=kl
                   END IF
                END IF
             END IF
          END IF
       END DO
    END DO
    !
    !     klow change above necessary to mark inversion cloud height
    !
    DO lon = 1, ncols
       IF (dthdpm(lon) < dthdpc .AND. grh(lon,invb(lon)) > f0p6) THEN
          cinv(lon) = - f6p67 * (dthdpm(lon)-dthdpc)
          cinv(lon) = MAX(cinv(lon),0.0_r8)
          cinv(lon) = MIN(cinv(lon),1.0_r8)
          IF (grh(lon,invb(lon)) < f0p8) &
               cinv(lon) = cinv(lon)* &
               (1.0_r8-(f0p8 - grh(lon,invb(lon)))/f0p2)
       END IF
       clow(lon)=cinv(lon)
       IF (conv(lon) <= 0.0_r8) THEN
          cdin(lon,klow(lon))=cinv(lon)
       END IF
    END DO
    !
    !     clow change necessary in order to properly mark inv cloud height
    !
    !     main loop for cloud amount determination
    !
    DO kl = lcnvl+1, MIN(kmax,kmax-nls)
       DO lon = 1, ncols
          !
          !     general define cloud due to saturation
          !
          csat(lon,kl)=(grh(lon,kl) - 0.9_r8) / .1
          csat(lon,kl)=(MAX(csat(lon,kl), 0.0_r8)) ** 2
          IF (pll(lon,kl) < 700.0_r8) THEN
             IF (omg(lon,kl) >= f5m5) THEN
                csat(lon,kl)=0.0_r8
             ELSE IF (omg(lon,kl) >= -f5m5) THEN
                delomg(lon) = (omg(lon,kl)+f5m5)*f1e4
                csat(lon,kl)=csat(lon,kl)*  &
                     (1.0_r8 - delomg(lon) * delomg(lon))
             END IF
          END IF
          csat(lon,kl)=MIN(csat(lon,kl), 1.0_r8)
          cstc(lon,kl)=csat(lon,kl)
       END DO
    END DO
    DO lon = 1, ncols
       DO kl = 1, kmax
          IF (cdin(lon,kl) > 0.0_r8) THEN
             css(lon,kmax+1-kl) = cdin(lon,kl)
          ELSE
             css(lon,kmax+1-kl) = csat(lon,kl)
          END IF
       END DO
    END DO
    !
    !     convective cloud is maximum overlaping in ir subr.
    !
    IF (covlp == 'MAXI') THEN
       DO lon = 1, ncols
          DO kl = kbot(lon), ktop(lon)
             ccu(lon,kmax-kl+1) = conv(lon)
          END DO
       END DO
       !
       !     convective cloud is random overlaping in ir subr.
       !
    ELSE IF (covlp == 'RAND') THEN

       DO lon = 1, ncols
          DO kl = kbots(lon), ktops(lon)
             IF ((conv(lon) <= 0.0_r8) .AND. (cdin(lon,kl) >= 0.0_r8)) THEN
                ccon(lon,kl)=convs(lon)
                cson(lon,kl)=convs(lon)
             END IF
          END DO
       END DO

       DO lon = 1, ncols
          DO kl = 1, kmax
             IF ((kl >= kbot(lon)) .AND. (kl <= ktop(lon))) THEN
                ccon(lon,kl)=ccon(lon,kl)+conv(lon)
             ELSE
                ccon(lon,kl)=ccon(lon,kl)
             END IF
             ccon(lon,kl)=MIN(ccon(lon,kl),1.0_r8)
             css(lon,kmax-kl+1) = MIN(1.0_r8,css(lon,kmax-kl+1))
          END DO
       END DO

       DO lon = 1, ncols
          ccon(lon,khigh(lon))=ccon(lon,khigh(lon))+chigh(lon)
       END DO

       DO kl = 1, kmax
          DO lon = 1, ncols
             IF(mxrdcc)THEN
                css(lon,kmax-kl+1) =  &
                     (1.0_r8-ccon(lon,kl))*css(lon,kmax-kl+1) + &
                     ccon(lon,kl)
                css(lon,kmax-kl+1) = MIN(1.0_r8,css(lon,kmax-kl+1))
             END IF
          END DO
       END DO

    END IF
  END SUBROUTINE cldgn2






  SUBROUTINE cldgen (covlp ,gps   ,sig   ,grh   ,omg   ,gtmp  ,css   , &
       ccu   ,cdin  ,cstc  ,ccon  ,cson  ,mxrdcc,lcnvl ,lthncl, &
       convc ,convt ,convb ,ncols ,kmax  ,nls            )

    !==========================================================================
    ! cldgen :perform clouds generation scheme based on j. slingo
    !         (1984 ecmwf workshop); the scheme generates 4 type of clouds
    !         of convective, high, middle and low clouds.
    !==========================================================================
    ! parameters and input variables:
    !        covlp = 'maxi'         maximum overlap of convective cloud
    !                               or thick low cloud used in ir subr.
    !              = 'rand'         random  overlap of convective cloud
    !                               or thick low cloud used in ir subr.
    !        date  =  julian day of model forecast date
    !        jlat  =  current latitude number in process
    !        grh   =  relative humidity  (g/g)
    !        omg   =  vertical velocity  (cb/sec)
    !        gps   =  surface pressure   (mb)
    !        sig   =  sigma coordinate at middle of layer
    !        gtmp  =  layer temperature (k)
    !     output variables:
    !        css   =  ncols*kmax supersatuation cloud cover fraction
    !        ccu   =  ncols*kmax convective cloud cover fraction
    !---------------------------------------------------------------------
    ! values from subr-gwater
    !       convc  =  ncols*jmax convective cloud cover in 3 hr. avrage
    !       convt  =  ncols*jmax convective cloud top  (sigma layer)
    !       convb  =  ncols*jmax convective cloud base (sigma layer)
    !       prcp1,prcp2,prcp3,prcpt,toplv,botlv: are used in subr "gwater"
    !==========================================================================
    !
    !   ncols......Number of grid points on a gaussian latitude circle
    !   kmax......Number of grid points at vertical
    !   nls..... .Number of layers in the stratosphere.
    !   cdin
    !   cstc......cstc=clow change necessary in order to properly mark inv
    !             cloud height
    !   ccon......convc  =  ncols*jmax convective cloud cover in 3 hr. avrage
    !   cson
    !   cp........Specific heat of air (j/kg/k)
    !   gasr......Constant of dry air      (j/kg/k)
    !   mxrdcc....use maximum random converage for radiative conv. clouds
    !             constant logical mxrdcc = .true.
    !   lcnvl.....the lowest layer index where non-convective clouds can
    !             occur (ben says this should be 2 or more)
    !             constant lcnvl = 2
    !   lthncl....Minimum depth in mb of non-zero low level cloud
    !             consta lthncl=80
    !==========================================================================
    INTEGER,          INTENT(IN   ) :: ncols
    INTEGER,          INTENT(in ) :: kmax
    INTEGER,          INTENT(in ) :: nls

    CHARACTER(len=4), INTENT(in   ) :: covlp
    REAL(KIND=r8),             INTENT(in   ) :: gps (ncols)
    REAL(KIND=r8),             INTENT(in   ) :: sig (kmax)
    REAL(KIND=r8),             INTENT(in   ) :: grh (ncols,kmax)
    REAL(KIND=r8),             INTENT(in   ) :: omg (ncols,kmax)
    REAL(KIND=r8),             INTENT(in   ) :: gtmp(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: css (ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: ccu (ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: cdin(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: cstc(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: ccon(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: cson(ncols,kmax)

    LOGICAL,          INTENT(in ) :: mxrdcc
    INTEGER,          INTENT(in ) :: lcnvl
    INTEGER,          INTENT(in ) :: lthncl
    REAL(KIND=r8),             INTENT(in ) :: convc(ncols)
    REAL(KIND=r8),             INTENT(in ) :: convt(ncols)
    REAL(KIND=r8),             INTENT(in ) :: convb(ncols)


    !
    !     dthdpm-----min (d(theta)/d(p))
    !     invb ------the base of inversion layer
    !     dthdpc-----criterion of (d(theta)/d(p))
    !
    REAL(KIND=r8),    PARAMETER :: dthdpc = -0.4e-1_r8
    REAL(KIND=r8)    :: pll   (ncols,kmax)
    REAL(KIND=r8)    :: conv  (ncols)
    REAL(KIND=r8)    :: clow  (ncols)
    REAL(KIND=r8)    :: cmid  (ncols)
    REAL(KIND=r8)    :: chigh (ncols)
    INTEGER :: ktop  (ncols)
    INTEGER :: kbot  (ncols)
    INTEGER :: klow  (ncols)
    INTEGER :: kmid  (ncols)
    INTEGER :: khigh (ncols)
    REAL(KIND=r8)    :: pt    (ncols)
    REAL(KIND=r8)    :: cx    (ncols)
    REAL(KIND=r8)    :: cinv  (ncols)
    REAL(KIND=r8)    :: delomg(ncols)
    REAL(KIND=r8)    :: csat  (ncols,kmax)
    REAL(KIND=r8)    :: dthdpm(ncols)
    INTEGER :: invb  (ncols)

    REAL(KIND=r8), PARAMETER :: f700p= 7.0e2_r8
    REAL(KIND=r8), PARAMETER :: f400p= 4.0e2_r8
    REAL(KIND=r8), PARAMETER :: f6p67= 6.67e0_r8
    REAL(KIND=r8), PARAMETER :: f0p9 = 0.9e0_r8
    REAL(KIND=r8), PARAMETER :: f0p8 = 0.8e0_r8
    REAL(KIND=r8), PARAMETER :: f0p4 = 0.4e0_r8
    REAL(KIND=r8), PARAMETER :: f0p3 = 0.3e0_r8
    REAL(KIND=r8), PARAMETER :: f0p2 = 0.2e0_r8
    REAL(KIND=r8), PARAMETER :: f0p6 = 0.6e0_r8
    REAL(KIND=r8), PARAMETER :: f1e4 = 1.0e+4_r8
    REAL(KIND=r8), PARAMETER :: f5m5 = 5.0e-5_r8

    INTEGER :: i
    INTEGER :: k
    INTEGER :: kl
    INTEGER :: lon
    REAL(KIND=r8)    :: arcp
    REAL(KIND=r8)    :: dthdp
    REAL(KIND=r8)    :: thklow


    DO k = 1, kmax
       DO i = 1, ncols
          css(i,k) = 0.0_r8
          ccu(i,k) = 0.0_r8
          csat(i,k) = 0.0_r8
          cdin(i,k) = 0.0_r8
          cstc(i,k) = 0.0_r8
          ccon(i,k) = 0.0_r8
          cson(i,k) = 0.0_r8
       END DO
    END DO
    !
    !     the clouds generation scheme is based on j. slingo
    !     (1984 ecmwf workshop).  the scheme generates 4 type of clouds
    !     of convective, high, middle and low clouds.
    !
    DO kl = 1, kmax
       DO lon = 1,ncols
          pll(lon,kl) = gps(lon) * sig(kl)
       END DO
    END DO
    !
    !     initialization
    !
    DO  lon = 1,ncols
       conv(lon)  = convc(lon)
       clow(lon)  = 0.0_r8
       cinv(lon)  = 0.0_r8
       cmid(lon)  = 0.0_r8
       chigh(lon) = 0.0_r8
       ktop(lon)  = convt(lon)+0.5_r8
       IF (ktop(lon).LT.1.OR.ktop(lon).GT.kmax) ktop(lon)=1
       kbot(lon)  = convb(lon)+0.5_r8
       IF (kbot(lon).LT.1.OR.kbot(lon).GT.kmax) kbot(lon)=1
       klow(lon)  = 1
       kmid(lon)  = 1
       khigh(lon) = 1
       !
       !     1. define convective cloud
       !     done in subr-gwater
       !     cloud top and base are defined by kuo scheme: convt, convb
       !     cloud amount is calculated from precipitation rate : convc
       !     *** single layer clouds conputations start here, from bottom up
       !
       !     define high clouds due to strong convection
       !
       pt(lon) = gps(lon) * sig(ktop(lon))
       IF ((pt(lon).LE.f400p).AND.&
            (conv(lon).GE.f0p4)) THEN
          chigh(lon) = 2.0_r8 * (conv(lon) - f0p3)
          chigh(lon) = MIN(chigh(lon),1.0_r8)
          khigh(lon) = ktop(lon) + 1
          ccon(lon,khigh(lon))=chigh(lon)
       END IF
    END DO
    !
    !     compute low stratus associated with inversions, based on ecwmf's
    !     scheme, with lower criterion of d(theta)/d(p)
    !
    arcp = gasr / cp

    DO lon=1,ncols
       invb(lon) =  MIN(kmax, kmax-nls)
       dthdpm(lon) = 0.0_r8
    END DO

    DO kl=2,kmax
       DO lon=1,ncols
          IF (pll(lon,kl) .GT. f700p) THEN
             dthdp = (gtmp(lon,kl-1)*(1000.0_r8/pll(lon,kl-1))**arcp&
                  -gtmp(lon,kl)*(1000.0_r8/pll(lon,kl))**arcp)/&
                  (pll(lon,kl-1) - pll(lon,kl))
             IF(dthdp.LT.0.0_r8) THEN
                invb(lon) = MIN(kl-1,invb(lon))
                IF(dthdp.LT.dthdpc) THEN
                   IF(dthdp.LT.dthdpm(lon)) THEN
                      dthdpm(lon)=dthdp
                      klow(lon)=kl
                   ENDIF
                ENDIF
             ENDIF
          ENDIF
       END DO
    END DO
    !
    !     klow change above necessary to mark inversion cloud height
    !
    DO lon=1,ncols
       IF(dthdpm(lon).LT.dthdpc.AND.grh(lon,invb(lon)).GT.f0p6)THEN
          cinv(lon) = - f6p67 * (dthdpm(lon)-dthdpc)
          cinv(lon) = MAX(cinv(lon),0.0_r8)
          cinv(lon) = MIN(cinv(lon),1.0_r8)
          IF (grh(lon,invb(lon)) .LT. f0p8)&
               cinv(lon) = cinv(lon)*&
               (1.0_r8-(f0p8 - grh(lon,invb(lon)))/f0p2)
       ENDIF
       clow(lon)=cinv(lon)
       cdin(lon,klow(lon))=cinv(lon)
    END DO
    !
    !     clow change necessary in order to properly mark inv cloud height
    !
    !     main loop for cloud amount determination
    !
    DO kl = lcnvl+1, MIN(kmax, kmax-nls)
       DO lon = 1,ncols
          !
          !     general define cloud due to saturation
          !
          IF (pll(lon,kl) .GT. f400p) THEN
             cx(lon) = (grh(lon,kl) - f0p8) / f0p2
          ELSE
             cx(lon) = (grh(lon,kl) - f0p9) / 0.1_r8
          END IF
          cx(lon) = (MAX(cx(lon), 0.0_r8)) ** 2
          cx(lon) =  MIN(cx(lon), 1.0_r8)
          !
          !     start vertical process from bottom to top
          !
          IF (pll(lon,kl) .GT. f700p) THEN
             !
             !     2. define low cloud ***
             !     low cloud is defined one layer thick ranging from layer 3 to 700mb
             !     there are two type possible generating mechanisms. due boundary
             !     t inversion type and associated with vertical motion.
             !
             !     define low super satuated clouds but adjusted by vertical motion
             !
             IF (omg(lon,kl) .GE. f5m5) THEN
                cx(lon) = 0.0_r8
             ELSE IF (omg(lon,kl) .GE. -f5m5) THEN
                delomg(lon) = (omg(lon,kl)+f5m5)*f1e4
                cx(lon) = cx(lon) * (1.0_r8 - delomg(lon) * delomg(lon))
             END IF
             IF (cx(lon) .GT. clow(lon)) THEN
                klow(lon) = kl
                clow(lon) = cx(lon)
             END IF
          ELSE IF (pll(lon,kl) .GT. f400p) THEN
             !
             !     3. define middle cloud ***
             !     middle cloud is defined one layer thick between 700 and 400 mb.
             !
             !     define middle clouds only in supersaturate type
             !
             IF (cx(lon) .GT. cmid(lon)) THEN
                kmid(lon) = kl
                cmid(lon) = cx(lon)
             END IF
          ELSE
             !
             !     4. define high cloud
             !     high cloud is defined only one layer thick from 400 mb and up.
             !
             !     define high clouds due to satuation
             !
             IF (cx(lon) .GT. chigh(lon)) THEN
                khigh(lon) = kl
                chigh(lon) = cx(lon)
             END IF
             !
             !     end of vertical computation
             !
          END IF
       END DO
    END DO
    DO lon = 1,ncols
       css(lon,kmax-khigh(lon)+1) = chigh(lon)
       cstc(lon,khigh(lon))=chigh(lon)
       css(lon,kmax-kmid(lon)+1) = cmid(lon)
       cstc(lon,kmid(lon))=cmid(lon)
       !
       !     for very thin low cloud adding its thickness
       !     pressure thickness of low cloud layer
       !
       IF(klow(lon).GE.lcnvl) THEN
          thklow=0.5_r8*(pll(lon,klow(lon)-1)-pll(lon,klow(lon)+1))
          IF(thklow.LE.REAL(lthncl,r8)) THEN
             css(lon,kmax-klow(lon)) = clow(lon)
             cstc(lon,klow(lon)+1)=clow(lon)
          ENDIF
          css(lon,kmax-klow(lon)+1) = clow(lon)
          cstc(lon,klow(lon))=clow(lon)
       ENDIF
    END DO
    !
    !     convective cloud is maximum overlaping in ir subr.
    !
    IF (covlp .EQ. 'MAXI') THEN
       DO lon = 1,ncols
          DO kl = kbot(lon), ktop(lon)
             ccu(lon,kmax-kl+1) = conv(lon)
          END DO
       END DO
       !
       !     convective cloud is random overlaping in ir subr.
       !
    ELSE IF (covlp .EQ. 'RAND') THEN
       DO lon = 1,ncols
          DO kl = kbot(lon), ktop(lon)
             css(lon,kmax-kl+1) = MIN(1.0_r8,css(lon,kmax-kl+1))
             IF(mxrdcc)THEN
                css(lon,kmax-kl+1) = MAX(conv(lon),css(lon,kmax-kl+1))
                ccon(lon,kl)=conv(lon)
             END IF
          END DO
       END DO
    END IF
  END SUBROUTINE cldgen


  !hmjb This is the same as cldgen(), but with some bugs corrected.
  !The main change is that now both convective and layer clouds
  !are outputed separately. A new subroutine was necessary
  !to keep the original results with kuo. However,  I think
  !kuo should be used with this correction as well... but for
  !that futher studies about this impact must be done.
  !   This version is intended for, and was tested with, the new
  !shortwave radiation codes: clirad and ukmet
  !
  SUBROUTINE cldgn3 (gps   ,sig   ,grh   ,omg   ,gtmp  ,css   , ccu   , &
       cdin  ,cstc  ,ccon  ,cson  ,lcnvl ,lthncl, convc ,convt ,convb ,&
       ncols ,kmax  ,nls      )

    !==========================================================================
    ! cldgen :perform clouds generation scheme based on j. slingo
    !         (1984 ecmwf workshop); the scheme generates 4 type of clouds
    !         of convective, high, middle and low clouds.
    !==========================================================================
    ! parameters and input variables:
    !        covlp = 'maxi'         maximum overlap of convective cloud
    !                               or thick low cloud used in ir subr.
    !              = 'rand'         random  overlap of convective cloud
    !                               or thick low cloud used in ir subr.
    !        date  =  julian day of model forecast date
    !        grh   =  relative humidity  (g/g)
    !        omg   =  vertical velocity  (cb/sec)
    !        gps   =  surface pressure   (mb)
    !        sig   =  sigma coordinate at middle of layer
    !        gtmp  =  layer temperature (k)
    !     output variables:
    !        css   =  ncols*kmax supersatuation cloud cover fraction
    !        ccu   =  ncols*kmax convective cloud cover fraction
    !---------------------------------------------------------------------
    ! values from subr-gwater
    !       convc  =  ncols convective cloud cover in 3 hr. avrage
    !       convt  =  ncols convective cloud top  (sigma layer)
    !       convb  =  ncols convective cloud base (sigma layer)
    !==========================================================================
    !
    !   ncols......Number of grid points on a gaussian latitude circle
    !   kmax......Number of grid points at vertical
    !   nls..... .Number of layers in the stratosphere.
    !   cdin
    !   cstc......cstc=clow change necessary in order to properly mark inv
    !             cloud height
    !   ccon......convc  =  ncols convective cloud cover in 3 hr. avrage
    !   cson
    !   cp........Specific heat of air (j/kg/k)
    !   gasr......Constant of dry air      (j/kg/k)
    !   mxrdcc....use maximum random converage for radiative conv. clouds
    !             constant logical mxrdcc = .true.
    !   lcnvl.....the lowest layer index where non-convective clouds can
    !             occur (ben says this should be 2 or more)
    !             constant lcnvl = 2
    !   lthncl....Minimum depth in mb of non-zero low level cloud
    !             consta lthncl=80
    !==========================================================================
    INTEGER,          INTENT(IN   ) :: ncols
    INTEGER,          INTENT(in ) :: kmax
    INTEGER,          INTENT(in ) :: nls

    REAL(KIND=r8),             INTENT(in   ) :: gps (ncols)
    REAL(KIND=r8),             INTENT(in   ) :: sig (kmax)
    REAL(KIND=r8),             INTENT(in   ) :: grh (ncols,kmax)
    REAL(KIND=r8),             INTENT(in   ) :: omg (ncols,kmax)
    REAL(KIND=r8),             INTENT(in   ) :: gtmp(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: css (ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: ccu (ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: cdin(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: cstc(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: ccon(ncols,kmax)
    REAL(KIND=r8),             INTENT(inout  ) :: cson(ncols,kmax)

    INTEGER,          INTENT(in ) :: lcnvl
    INTEGER,          INTENT(in ) :: lthncl
    REAL(KIND=r8),             INTENT(in ) :: convc(ncols)
    REAL(KIND=r8),             INTENT(in ) :: convt(ncols)
    REAL(KIND=r8),             INTENT(in ) :: convb(ncols)

    !
    !     dthdpm-----min (d(theta)/d(p))
    !     invb ------the base of inversion layer
    !     dthdpc-----criterion of (d(theta)/d(p))
    !
    REAL(KIND=r8),    PARAMETER :: dthdpc = -0.4e-1_r8
    REAL(KIND=r8)    :: pll   (ncols,kmax)
    REAL(KIND=r8)    :: conv  (ncols)
    REAL(KIND=r8)    :: clow  (ncols)
    REAL(KIND=r8)    :: cmid  (ncols)
    REAL(KIND=r8)    :: chigh (ncols)
    INTEGER :: ktop  (ncols)
    INTEGER :: kbot  (ncols)
    INTEGER :: klow  (ncols)
    INTEGER :: kmid  (ncols)
    INTEGER :: khigh (ncols)
    REAL(KIND=r8)    :: pt    (ncols)
    REAL(KIND=r8)    :: cx    (ncols)
    REAL(KIND=r8)    :: cinv  (ncols)
    REAL(KIND=r8)    :: delomg(ncols)
    REAL(KIND=r8)    :: csat  (ncols,kmax)
    REAL(KIND=r8)    :: dthdpm(ncols)
    INTEGER :: invb  (ncols)

    REAL(KIND=r8), PARAMETER :: f700p= 7.0e2_r8
    REAL(KIND=r8), PARAMETER :: f400p= 4.0e2_r8
    REAL(KIND=r8), PARAMETER :: f6p67= 6.67e0_r8
    REAL(KIND=r8), PARAMETER :: f0p9 = 0.9e0_r8
    REAL(KIND=r8), PARAMETER :: f0p8 = 0.8e0_r8
    REAL(KIND=r8), PARAMETER :: f0p4 = 0.4e0_r8
    REAL(KIND=r8), PARAMETER :: f0p3 = 0.3e0_r8
    REAL(KIND=r8), PARAMETER :: f0p2 = 0.2e0_r8
    REAL(KIND=r8), PARAMETER :: f0p6 = 0.6e0_r8
    REAL(KIND=r8), PARAMETER :: f1e4 = 1.0e+4_r8
    REAL(KIND=r8), PARAMETER :: f5m5 = 5.0e-5_r8

    INTEGER :: i
    INTEGER :: k
    INTEGER :: kl
    INTEGER :: lon
    REAL(KIND=r8)    :: arcp
    REAL(KIND=r8)    :: dthdp
    REAL(KIND=r8)    :: thklow


    DO k = 1, kmax
       DO i = 1, ncols
          css(i,k) = 0.0_r8
          ccu(i,k) = 0.0_r8
          csat(i,k) = 0.0_r8
          cdin(i,k) = 0.0_r8
          cstc(i,k) = 0.0_r8
          ccon(i,k) = 0.0_r8
          cson(i,k) = 0.0_r8
       END DO
    END DO
    !
    !     the clouds generation scheme is based on j. slingo
    !     (1984 ecmwf workshop).  the scheme generates 4 type of clouds
    !     of convective, high, middle and low clouds.
    !
    DO kl = 1, kmax
       DO lon = 1,ncols
          pll(lon,kl) = gps(lon) * sig(kl)
       END DO
    END DO
    !
    !     initialization
    !
    DO  lon = 1,ncols
       conv(lon)  = convc(lon)
       clow(lon)  = 0.0_r8
       cinv(lon)  = 0.0_r8
       cmid(lon)  = 0.0_r8
       chigh(lon) = 0.0_r8
       ktop(lon)  = convt(lon)+0.5_r8
       IF (ktop(lon).LT.1.OR.ktop(lon).GT.kmax) ktop(lon)=1
       kbot(lon)  = convb(lon)+0.5_r8
       IF (kbot(lon).LT.1.OR.kbot(lon).GT.kmax) kbot(lon)=1
       klow(lon)  = 1
       kmid(lon)  = 1
       khigh(lon) = 1
       !
       !     1. define convective cloud
       !     done in subr-gwater
       !     cloud top and base are defined by kuo scheme: convt, convb
       !     cloud amount is calculated from precipitation rate : convc
       !     *** single layer clouds conputations start here, from bottom up
       !
       !     define high clouds due to strong convection
       !
       pt(lon) = gps(lon) * sig(ktop(lon))
       IF ((pt(lon).LE.f400p).AND.&
            (conv(lon).GE.f0p4)) THEN
          chigh(lon) = 2.0_r8 * (conv(lon) - f0p3)
          chigh(lon) = MIN(chigh(lon),1.0_r8)
          khigh(lon) = ktop(lon) + 1
          ccon(lon,khigh(lon))=chigh(lon)
       END IF
    END DO
    !
    !     compute low stratus associated with inversions, based on ecwmf's
    !     scheme, with lower criterion of d(theta)/d(p)
    !
    arcp = gasr / cp

    DO lon=1,ncols
       invb(lon) =  MIN(kmax, kmax-nls)
       dthdpm(lon) = 0.0_r8
    END DO

    DO kl=2,kmax
       DO lon=1,ncols
          IF (pll(lon,kl) .GT. f700p) THEN
             dthdp = (gtmp(lon,kl-1)*(1000.0_r8/pll(lon,kl-1))**arcp&
                  -gtmp(lon,kl)*(1000.0_r8/pll(lon,kl))**arcp)/&
                  (pll(lon,kl-1) - pll(lon,kl))
             IF(dthdp.LT.0.0_r8) THEN
                invb(lon) = MIN(kl-1,invb(lon))
                IF(dthdp.LT.dthdpc) THEN
                   IF(dthdp.LT.dthdpm(lon)) THEN
                      dthdpm(lon)=dthdp
                      klow(lon)=kl
                   ENDIF
                ENDIF
             ENDIF
          ENDIF
       END DO
    END DO
    !
    !     klow change above necessary to mark inversion cloud height
    !
    DO lon=1,ncols
       IF(dthdpm(lon).LT.dthdpc.AND.grh(lon,invb(lon)).GT.f0p6)THEN
          cinv(lon) = - f6p67 * (dthdpm(lon)-dthdpc)
          cinv(lon) = MAX(cinv(lon),0.0_r8)
          cinv(lon) = MIN(cinv(lon),1.0_r8)
          IF (grh(lon,invb(lon)) .LT. f0p8)&
               cinv(lon) = cinv(lon)*&
               (1.0_r8-(f0p8 - grh(lon,invb(lon)))/f0p2)
       ENDIF
       clow(lon)=cinv(lon)
       cdin(lon,klow(lon))=cinv(lon)
    END DO
    !
    !     clow change necessary in order to properly mark inv cloud height
    !
    !     main loop for cloud amount determination
    !
    DO kl = lcnvl+1, MIN(kmax, kmax-nls)
       DO lon = 1,ncols
          !
          !     general define cloud due to saturation
          !
          IF (pll(lon,kl) .GT. f400p) THEN
             cx(lon) = (grh(lon,kl) - f0p8) / f0p2
          ELSE
             cx(lon) = (grh(lon,kl) - f0p9) / 0.1_r8
          END IF
          cx(lon) = (MAX(cx(lon), 0.0_r8)) ** 2
          cx(lon) =  MIN(cx(lon), 1.0_r8)
          !
          !     start vertical process from bottom to top
          !
          IF (pll(lon,kl) .GT. f700p) THEN
             !
             !     2. define low cloud ***
             !     low cloud is defined one layer thick ranging from layer 3 to 700mb
             !     there are two type possible generating mechanisms. due boundary
             !     t inversion type and associated with vertical motion.
             !
             !     define low super satuated clouds but adjusted by vertical motion
             !
             IF (omg(lon,kl) .GE. f5m5) THEN
                cx(lon) = 0.0_r8
             ELSE IF (omg(lon,kl) .GE. -f5m5) THEN
                delomg(lon) = (omg(lon,kl)+f5m5)*f1e4
                cx(lon) = cx(lon) * (1.0_r8 - delomg(lon) * delomg(lon))
             END IF
             IF (cx(lon) .GT. clow(lon)) THEN
                klow(lon) = kl
                clow(lon) = cx(lon)
             END IF
          ELSE IF (pll(lon,kl) .GT. f400p) THEN
             !
             !     3. define middle cloud ***
             !     middle cloud is defined one layer thick between 700 and 400 mb.
             !
             !     define middle clouds only in supersaturate type
             !
             IF (cx(lon) .GT. cmid(lon)) THEN
                kmid(lon) = kl
                cmid(lon) = cx(lon)
             END IF
          ELSE
             !
             !     4. define high cloud
             !     high cloud is defined only one layer thick from 400 mb and up.
             !
             !     define high clouds due to satuation
             !
             IF (cx(lon) .GT. chigh(lon)) THEN
                khigh(lon) = kl
                chigh(lon) = cx(lon)
             END IF
             !
             !     end of vertical computation
             !
          END IF
       END DO
    END DO
    DO lon = 1,ncols
       css(lon,kmax-khigh(lon)+1) = chigh(lon)
       cstc(lon,khigh(lon))=chigh(lon)
       css(lon,kmax-kmid(lon)+1) = cmid(lon)
       cstc(lon,kmid(lon))=cmid(lon)
       !
       !     for very thin low cloud adding its thickness
       !     pressure thickness of low cloud layer
       !
       IF(klow(lon).GE.lcnvl) THEN
          thklow=0.5_r8*(pll(lon,klow(lon)-1)-pll(lon,klow(lon)+1))
          IF(thklow.LE.REAL(lthncl,r8)) THEN
             css(lon,kmax-klow(lon)) = clow(lon)
             cstc(lon,klow(lon)+1)=clow(lon)
          ENDIF
          css(lon,kmax-klow(lon)+1) = clow(lon)
          cstc(lon,klow(lon))=clow(lon)
       ENDIF
    END DO
    !hmjb - Correction of many bugs
    !          The way it was before, convective went out as 0.0 and
    !       strat had the maximum of convc and strat. Now this is fixed
    !
    ! Bugs.
    ! line 04 Should always be executed. shortwave subroutine need convective clouds
    ! line 13 Should always be executed as it is a numerical check only
    ! line 15 This is done inside shortwave subroutines, so we don't need to do it here.
    !         However, the values modified there will not go inside longwave subroutine,
    !         and they should... must fix this in spmrad
    ! line 16 ccon is only used for output... So it should always receive conv
    !
    !OLD CODE-------------------------------------------------------------
    !    !
    !    !     convective cloud is maximum overlaping in ir subr.
    !    !
    !01    IF (covlp .EQ. 'MAXI') THEN
    !02       DO lon = 1,ncols
    !03          DO kl = kbot(lon), ktop(lon)
    !04             ccu(lon,kmax-kl+1) = conv(lon)
    !05          END DO
    !06       END DO
    !07       !
    !08       !     convective cloud is random overlaping in ir subr.
    !09       !
    !10    ELSE IF (covlp .EQ. 'RAND') THEN
    !11       DO lon = 1,ncols
    !12          DO kl = kbot(lon), ktop(lon)
    !13             css(lon,kmax-kl+1) = MIN(1.0_r8,css(lon,kmax-kl+1))
    !14             IF(mxrdcc)THEN
    !15                css(lon,kmax-kl+1) = MAX(conv(lon),css(lon,kmax-kl+1))
    !16                ccon(lon,kl)=conv(lon)
    !17             END IF
    !18          END DO
    !19       END DO
    !20    END IF
    !NEW CODE-------------------------------------------------------------
    DO lon = 1,ncols
       DO kl = kbot(lon), ktop(lon)
          ccu(lon,kmax-kl+1) = conv(lon)
          css(lon,kmax-kl+1) = MIN(1.0_r8,css(lon,kmax-kl+1))
          ccon(lon,kl)=conv(lon)
       END DO
    END DO

    RETURN
  END SUBROUTINE cldgn3


  ! getoz  :interpolates climatological ozone data into a given latitude
  !         and model julian date.
  SUBROUTINE getoz (ncols,colrad,date  ,o3l   ,sl    ,kmax)
    !
    ! input parameters and variables:
    !     date  =  model julian date
    !     colrad=  0-3.14 from np to sp in radians
    !     ozone =  ozone mixing ratio in 18 sigma layers in 5 degree
    !     latitude interval (data)
    ! output variables:
    !     o3l   =  18 layers ozone mixing ratio in given lat and date
    !
    !==========================================================================
    ! :: kmax.....Number of grid points at vertical
    ! :: sl.......sigma coordinate at middle of layer
    ! :: pai......constant pi=3.1415926
    ! :: yrl......length of year in days
    !==========================================================================
    !
    INTEGER, INTENT(IN   ) :: ncols
    INTEGER, INTENT(IN   ) :: kmax
    REAL(KIND=r8),    INTENT(in   ) :: colrad(ncols)
    REAL(KIND=r8),    INTENT(inout) :: date
    REAL(KIND=r8),    INTENT(inout  ) :: o3l(ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: sl (kmax)
    !TO    REAL(KIND=r8),    INTENT(IN   ) :: yrl

    REAL(KIND=r8) :: a1   (nlm_getoz)
    REAL(KIND=r8) :: a2   (nlm_getoz)
    REAL(KIND=r8) :: a3   (nlm_getoz)
    REAL(KIND=r8) :: a4   (nlm_getoz)
    REAL(KIND=r8) :: b1   (nlm_getoz)
    REAL(KIND=r8) :: b2   (nlm_getoz)
    REAL(KIND=r8) :: b3   (nlm_getoz)
    REAL(KIND=r8) :: b4   (nlm_getoz)
    REAL(KIND=r8) :: do3a (nlm_getoz)
    REAL(KIND=r8) :: do3b (nlm_getoz)
    REAL(KIND=r8) :: ozo3l(ncols,nlm_getoz)
    !TO    REAL(KIND=r8) :: ozo3l(18)

    REAL(KIND=r8), PARAMETER :: rlag = 14.8125e0_r8

    INTEGER :: l
    INTEGER :: la   (ncols)
    INTEGER :: ll   (ncols)
    INTEGER :: kmx
    INTEGER :: imon
    INTEGER :: isea
    INTEGER :: k
    INTEGER :: i
    INTEGER :: kk    (ncols,kmax)
    REAL(KIND=r8)    :: theta
    REAL(KIND=r8)    :: flat
    REAL(KIND=r8)    :: rang
    REAL(KIND=r8)    :: rsin1(ncols)
    REAL(KIND=r8)    :: rcos1(ncols)
    REAL(KIND=r8)    :: rcos2(ncols)
    REAL(KIND=r8)    :: rate (ncols)
    REAL(KIND=r8)    :: aa
    REAL(KIND=r8)    :: bb
    LOGICAL :: notfound(kMax)

    kmx=nlm_getoz
    !
    !     find closest place in the data according to input slat.
    !
    IF(date.GT.year_getoz) date=date-year_getoz

    imon=date/mon_getoz + 1

    IF(imon.LT.1)imon=1

    isea=imon/3 + 1

    IF(isea.EQ.5) isea=1
    IF(isea.GT.5) THEN
       WRITE(nfprt,"('0 ERROR IN ISEA - TERMINATION IN SUBROUTINE GETOZ')")
       WRITE(nferr,"('0 ERROR IN ISEA - TERMINATION IN SUBROUTINE GETOZ')")
       STOP 9954
    END IF
    DO i=1,ncols
       theta = 90.0_r8-(180.0_r8/pai)*colrad(i) ! colatitude -> latitude
       ! the 180 degrees are divided into 37 bands with 5deg each
       ! except for the first and last, which have 2.5 deg
       ! The centers of the bands are located at:
       !   90, 85, 80, ..., 5, 0, -5, ..., -85, -90 (37 latitudes)
       flat  = 0.2_r8*theta ! indexing the latitudes: goes from -18. to +18.
       ! find the latitude index before and after each latitude
       la(i)    = 19.501e0_r8-flat !
       ll(i)    = 19.001e0_r8-flat

       !
       !     find sin and cos coefficients for time interpolation.
       !
       rang=2.0e0_r8*pai*(date-rlag)/year_getoz
       rsin1(i)=SIN(rang)
       rcos1(i)=COS(rang)
       rcos2(i)=COS(2.0e0_r8*rang)
       rate(i)=REAL(19-ll(i),r8)-flat
       !
       !     ozone interpolation in latitude and time
       !
    END DO
    DO k=1,kmx
       DO i=1,ncols
          a1(k) =2.5e-1_r8*(ozone(k,la(i),1)+ozone(k,la(i),2)+ &
               ozone(k,la(i),3)+ozone(k,la(i),4))
          a2(k) =0.5e0_r8*(ozone(k,la(i),2)-ozone(k,la(i),4))
          a3(k) =0.5e0_r8*(ozone(k,la(i),1)-ozone(k,la(i),3))
          a4(k) =2.5e-1_r8*(ozone(k,la(i),1)+ozone(k,la(i),3)- &
               ozone(k,la(i),2)-ozone(k,la(i),4))
          b1(k) =2.5e-1_r8*(ozone(k,ll(i),1)+ozone(k,ll(i),2)+ &
               ozone(k,ll(i),3)+ozone(k,ll(i),4))
          b2(k) =0.5e0_r8*(ozone(k,ll(i),2)-ozone(k,ll(i),4))
          b3(k) =0.5e0_r8*(ozone(k,ll(i),1)-ozone(k,ll(i),3))
          b4(k) =2.5e-1_r8*(ozone(k,ll(i),1)+ozone(k,ll(i),3)- &
               ozone(k,ll(i),2)-ozone(k,ll(i),4))
          do3a(k)=a1(k)+rsin1(i)*a2(k)+rcos1(i)*a3(k)+rcos2(i)*a4(k)
          do3b(k)=b1(k)+rsin1(i)*b2(k)+rcos1(i)*b3(k)+rcos2(i)*b4(k)
          ozo3l(i,k)=do3a(k)+rate(i)*(do3b(k)-do3a(k))
          ozo3l(i,k)=1.0e-04_r8*ozo3l(i,k)
       END DO
    END DO
    IF(inter_getoz)THEN
       DO l=1,kmax
          notfound(l) = sl(l) > ozsig(1)
          IF (notfound(l)) THEN
             kk(1,l)=kmx
          ELSE
             kk(1,l)=2
          END IF
       END DO
       DO l=1,kmax
          IF (notfound(l)) THEN
             DO k=2,kmx
                IF(sl(l).GT.ozsig(k-1).AND.sl(l).LE.ozsig(k))THEN
                   kk(1,l)=k
                   EXIT
                END IF
             END DO
          END IF
       END DO
       DO l = 1, kmax
          DO i= 2, ncols
             kk(i,l) = kk(1,l)
          END DO
       END DO
    END IF
    IF(inter_getoz)THEN
       DO l=1,kmax
          DO i=1,ncols
             aa=(ozo3l(i,kk(i,l))-ozo3l(i,kk(i,l)-1))/(ozsig(kk(i,l))-ozsig(kk(i,l)-1))
             bb=ozo3l(i,kk(i,l)-1)-aa*ozsig(kk(i,l)-1)
             o3l(i,kmax+1-l)=bb+aa*sl(l)
          END DO
       END DO
    END IF
    IF(.NOT.inter_getoz)THEN
       DO l=1,nlm_getoz
          DO i=1,ncols
             o3l(i,l)=ozo3l(i,l)
          END DO
       END DO
    ENDIF
  END SUBROUTINE getoz



  ! radtim :calculates the astronomical parameters: solar inclination,
  !         correction factor to local time, factor relating to the distance
  !         between earth and sun, and the julian day.



  SUBROUTINE radtim (id    ,delta ,ratio ,etime ,tod   ,xday  ,yrl)
    !
    !==========================================================================
    !
    !==========================================================================
    !  id(1)....hour(00/12)
    !  id(2)....month
    !  id(3)....day of month
    !  id(4)....year
    !  delta....solar inclination
    !  ratio....factor relating to the distance between the earth and the sun
    !  etime....correction factor to local time
    !  tod......model forecast time of day in seconds
    !  xday.....is julian day - 1 with fraction of day
    !  pai......constant pi=3.1415926
    !  yrl......length of year in days
    !  monl.....length of each month in days
    !==========================================================================
    INTEGER, INTENT(in ) :: id(4)
    REAL(KIND=r8),    INTENT(inout) :: delta
    REAL(KIND=r8),    INTENT(inout) :: ratio
    REAL(KIND=r8),    INTENT(inout) :: etime
    REAL(KIND=r8),    INTENT(in ) :: tod
    REAL(KIND=r8),    INTENT(inout) :: xday
    REAL(KIND=r8),    INTENT(in ) :: yrl

    REAL(KIND=r8),    PARAMETER :: day0=-1.0_r8
    REAL(KIND=r8),    PARAMETER :: f3600=3.6e3_r8
    REAL(KIND=r8)          :: psi

    !
    !     id is now assumed to be the current date and hour
    !
    xday=id(1)*f3600
    xday=xday+MOD(tod,f3600)
    xday=monday(id(2))+id(3)+xday/86400.0_r8

    IF (yrl == 365.25e0_r8) THEN
       xday=xday-MOD(id(4)+3,4)*0.25_r8
       IF(MOD(id(4),4).EQ.0.AND.id(2).GT.2)xday=xday+1.0e0_r8
    END IF

    xday= MOD(xday-1.0e0_r8,yrl)

    IF (xday > day0) THEN
       psi=2.0e0_r8*pai*xday/yrl
       delta=0.006918e0_r8-0.399912e0_r8*COS(   psi)+0.070257e0_r8*SIN(psi) &
            -0.006758e0_r8*COS(2.0e0_r8*psi)+0.000907e0_r8*SIN(2.0e0_r8*psi) &
            -0.002697e0_r8*COS(3.0e0_r8*psi)+0.001480e0_r8*SIN(3.0e0_r8*psi)
       ratio=1.000110e0_r8+0.034221e0_r8*COS(   psi)+0.001280e0_r8*SIN(psi) &
            +0.000719e0_r8*COS(2.0e0_r8*psi)+0.000077e0_r8*SIN(2.0e0_r8*psi)
       etime=0.000075e0_r8+0.001868e0_r8*COS(   psi)-0.032077e0_r8*SIN(psi) &
            -0.014615e0_r8*COS(2.0e0_r8*psi)-0.040849e0_r8*SIN(2.0e0_r8*psi)
    ELSE
       WRITE(nfprt,20)id,tod,xday
       WRITE(nferr,20)id,tod,xday
       STOP 2020
    END IF

20  FORMAT(' BAD DATE IN RADTIM.  ID=',4I5,' TOD=',G16.8,' XDAY=', &
         G16.8)
  END SUBROUTINE radtim






  SUBROUTINE rqvirt(pstar ,qin   ,t     ,qout  ,relhum,sl    ,ncols , &
       kmax  )
    !
    !==========================================================================
    ! rqvirt :converts in place the current model virtual temperature to
    !         thermodynamic temperature for radiation calculation; also
    !         extrapolates moisture up into model dry layers using exponential
    !         decrease up to a minimum value.
    !         This code requires moisture defined in all layers
    !==========================================================================
    !
    !     input  - sfc pres (cb)      - pstar
    !               - moisture        - qin - levh lyrs only
    !               - temperature     - t   - model virtual temperature
    !     output - levs moisture lyrs - qextp
    !               - thermodynamic temperature back into t
    !               - relative humidity relhum
    !
    !==========================================================================
    !  ncols......Number of grid points on a gaussian latitude circle
    !  kmax.......Number of grid points at vertical
    !  pstar......sfc pres (cb)
    !  qin........moisture        - qin - levh lyrs only
    !  t..........temperature     - t   - model virtual temperature
    !  qout.......extrapolates moisture up into model dry layers using
    !             exponential  decrease up to a minimum value.
    !  relhum.....relative humidity relhum
    !  sl.........sig  = sigma coordinate at middle of layer
    !  delq.......constant delq = 0.608e0
    !  qmin.......constant qmin = 1.0e-12
    !  hl.........heat of evaporation of water     (j/kg)
    !  gasr.......gas constant of dry air        (j/kg/k)
    !  rmwmd......fracao molar da agua e do ar seco
    !  rmwmdi.....fracao molar
    !  e0c........
    !  tbase......constant tbase =  273.15e00
    !==========================================================================
    INTEGER, INTENT(IN   ) :: ncols
    INTEGER, INTENT(IN   ) :: kmax
    REAL(KIND=r8),    INTENT(in   ) :: pstar (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: qin   (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout) :: t     (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: qout  (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: relhum(ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: sl    (kmax)

    REAL(KIND=r8)    :: qsat(ncols,kmax)
    REAL(KIND=r8)    :: prs (ncols,kmax)
    REAL(KIND=r8)    :: rrlrv
    REAL(KIND=r8)    :: const
    REAL(KIND=r8)    :: fac
    INTEGER :: k1
    INTEGER :: k
    INTEGER :: i
    !
    !     input - sfc pres (cb) - pstar
    !              - moisture      - qin - levh lyrs only
    !              - temperature   - t   - model virtual temperature
    !     output - levs moisture lyrs - qextp
    !               - thermodynamic temperature back into t
    !               - relative humidity relhum
    !
    rrlrv = -hl/(rmwmdi*gasr)
    const = e0c*EXP(-rrlrv/tbase)
    !
    !     convert mdl virtual temp to thermodynmic temp
    !
    WHERE (qin > 0.0_r8)
       t = t / (1.0_r8+delq*qin)
    END WHERE
    !
    !     get lyr pressure and then saturated moisture
    !
    DO k1 = 1, MOD(kmax,4)
       prs(:,k1) = pstar(:) * sl(k1)
    END DO
    DO k = k1, kmax, 4
       prs(:,k) = pstar(:) * sl(k)
       prs(:,k+1) = pstar(:) * sl(k+1)
       prs(:,k+2) = pstar(:) * sl(k+2)
       prs(:,k+3) = pstar(:) * sl(k+3)
    END DO
    DO k = 1, kmax
       DO i = 1, ncols
          fac = const*EXP(rrlrv/t(i,k))
          qsat(i,k)=rmwmd* fac/(prs(i,k)*10.0_r8- (1.0_r8-rmwmd)*fac)
       END DO
    END DO
    !
    !     limit moisture to  rh le 1. but ge .0
    !
    DO k = 1, kmax
       DO i = 1, ncols
          qout(i,k) = qin(i,k)
          relhum(i,k) = qin(i,k) / qsat(i,k)
          IF (relhum(i,k) <= 0.0_r8) THEN
             qout(i,k) = qmin
             relhum(i,k) = qmin / qsat(i,k)
          END IF
          IF (relhum(i,k) > 1.0_r8) THEN
             qout(i,k) = qsat(i,k)
             relhum(i,k) = 1.0_r8
          END IF
       END DO
    END DO
  END SUBROUTINE rqvirt



  !-----------------------------------------------------------------------
  ! Subroutine: SPMRAD
  !
  ! MAIN ROUTINE FOR RADIATION COMPUTATIONS
  ! CALLS SUBROUTINES:
  !
  !       RADTIM:   COMPUTES ASTRONOMICAL PARAMETERS
  !       GETOZ:    INTERPOLATES OZONE AMOUNT FROM CLIMATOLOGICAL VALUES
  !       CLDGEN:   COMPUTES CLOUD AMOUNTS
  !       SWRAD:    DOES SHORTWAVE RADIATION CALCULATIONS
  !       LWRAD:    DOES LONGWAVE RADIATION CALCULATIONS
  !
  !   COMPUTES COSINES OF SOLAR ZENITH ANGLE
  !   COMPUTES TOTAL CLOUD AMOUNT OF SUPERSATURATION CLOUDS
  !   PREPARES INPUT FLIPP ARRAYS FOR SWRAD AND LWRAD
  !
  !   OUTPUT:
  !
  !      the cooling rate due to long wave radiation, heating rate due to
  !      short wave radiation, downward longwave radiation at the bottom,
  !      and the following relating to downward surface fluxes: visible
  !      beam cloudy skies, visible diffuse cloudy skies, near-infrared
  !      beam cloudy skies, and near-infrared diffuse cloudy skies.
  !
  !
  !-----------------------------------------------------------------------

  SUBROUTINE spmrad ( &
       id    , jlat  , colrad, gps   , gtmp  , gwv   , gtg   , grh   ,&
       omg   , clr   , htr   , avisd , anird , avisb , anirb , dlwbot,&
       ulwtop, dswtop, sig   , sigml , rvisd , rnird , rvisb , rnirb ,&
       inalb , trint , swint , ultclr, rsclr , dlwclr, htrc  , rvisdc,&
       rnirdc, rvisbc, rnirbc, yvisdc, ynirdc, yvisbc, ynirbc, icld  ,&
       cosz  , yvisd , ynird , yvisb , ynirb , yswtop, xvisdc, xnirdc,&
       xvisbc, xnirbc, xvisd , xnird , xvisb , xnirb , cld3  , rs    ,&
       ifday , tod   , idate , cldtd , cldin , cstcin, cldcon, cldson,&
       clwd  , emisd , taud  , tsea  , yrl   , convts, convcs, convbs,&
       mxrdcc, lcnvl , lthncl, convc , convt , convb , first , co2val,&
       delt  , nfin0 , nfin1 , nfcnv0, nls   , nlcs  , ncols , jmax  ,&
       kmax  , lonrad, cos2d , intcosz,clrc,imask, o3mix) !hmjb
    !
    !
    !
    !----------------------------------------------------------------------c
    !-- input parameters --------------------------------------------------c
    !----------------------------------------------------------------------c
    !     id.......date of current data
    !     id(1)....hour(00/12)
    !     id(2)....month
    !     id(3)....day of month
    !     id(4)....year
    !     jlat.....do loop count in latitudinal direction
    !              jlat=1 is for a furthest north gaussian latitude
    !     ncols....no. of grids on a gaussian latitude
    !              i=1 is at greenich
    !     ncols....ncols+(0,1 or 2)
    !     kmax.....no. of sigma levels
    !     gps......surface pressure in mb
    !     gtmp.....temperature in kelvin
    !     gwv......specific humidity in g/g
    !     gtg......ground surface temperature in kelvin
    !     avisd....visible diffuse surface albedo
    !     anird....near-ir diffuse surface albedo
    !     sinlat...sin latitude
    !     sigml....sigma coordinate at bottom of layer
    !              sigml(1)=1.0
    !     sig......sigma coordinate at middle of layer
    !     trint....ir subr. call interval in hours
    !     swint....sw subr. call interval in hours
    !              swint has to be less than or equal to trint
    !                              and mod(trint,swint)=0
    !     ifday....model forecast day
    !     tod......model forecast time of day in seconds
    !----------------------------------------------------------------------c
    !-- output parameters -------------------------------------------------c
    !----------------------------------------------------------------------c
    !     visible = 0.0 to 0.7 mu  near-ir = 0.7 to 4.0 mu
    !
    !     clr......cooling rate due to long wave radiation in deg/sec
    !     htr......heating rate due to shrt wave radiation in deg/sec
    !     dlwbot...downward longwave radiation at the bottom in w/m**2
    !
    !     the following refer to downward surface fluxes
    !     rvisb....visible beam cloudy skies
    !     rvisd....visible diffuse cloudy skies
    !     rnirb....near-ir beam cloudy skies
    !     rnird....near-ir diffuse cloudy skies
    !----------------------------------------------------------------------c
    !-- in-subroutine parameters ------------------------------------------c
    !----------------------------------------------------------------------c
    !     ptop.....pressure at top of model( for radiation only )
    !     cosz.....cosine of solar zenith angle
    !     solcon...solar constant at mean sun-earth distance
    !     swinc....solar input at top of atmosphere
    !     o3.......layer ozone mixing ratio in g/g
    !              interpolated from climatological value
    !     cld......supersaturation cloud fraction
    !     clu......convective cloud fraction
    !               above two cloud fraction should be given either as
    !               climatological value or using diagnostic relation
    !               between cloud fraction and relative humidity etc.
    !               cloud amount in ir/sw subr. is max(cld,clu)
    !     ulwtop...long wave flux at top of atmosphere in w/m**2
    !     rs.......net surface ir radiation in w/m**2
    !----------------------------------------------------------------------c
    !.. for  gtmp,gwv,clr,htr,      k=kmax means top     layer
    !..      sig,sigml,o3,cld,clu   k=1    means surface layer
    !.. for the other variables     k=1    means top     layer
    !
    !.. for  gtmp,gwv,gps           the size of first dimension is 'ncols '
    !.. for the other variables                                    'ncols'
    !
    !==========================================================================
    !    imx.......=ncols+1 or ncols+2   :this dimension instead of ncols
    !              is used in order to avoid bank conflict of memory
    !              access in fft computation and make it efficient. the
    !              choice of 1 or 2 depends on the number of banks and
    !              the declared type of grid variable (REAL(KIND=r8)*4,REAL(KIND=r8)*8)
    !              to be fourier transformed.
    !              cyber machine has the symptom.
    !              cray machine has no bank conflict, but the argument
    !              'imx' in subr. fft991 cannot be replaced by ncols
    !    ncols......Number of grid points on a gaussian latitude circle
    !    jmax......Number of gaussian latitudes
    !    kmax......Number of sigma levels
    !    nls..... .Number of layers in the stratosphere.
    !    colrad....colatitude  colrad=0-3.14 from np to sp in radians
    !    grh.......grh   =  relative humidity  (g/g)
    !    omg.......omg   =  vertical velocity  (cb/sec)
    !    clr.......cooling rate due to long wave radiation in deg/sec
    !    htr.......heating rate due to shrt wave radiation in deg/sec
    !    avisd.....visible diffuse surface albedo
    !    anird.....near-ir diffuse surface albedo
    !    avisb.....visible beam surface albedo
    !    anirb.....near-ir beam surface albedo
    !    dlwbot....downward longwave radiation at the bottom in w/m**2
    !    ulwtop....long wave flux at top of atmosphere in w/m**2
    !    dswtop....swinc....solar input at top of atmosphere
    !    sig.......sigma coordinate at middle of layer
    !    sigml.....sigma coordinate at bottom of layer
    !              sigml(1)=1.0
    !    rvisb.....visible beam cloudy skies (refer to downward surface fluxes)
    !    rvisd.....visible diffuse cloudy skies (refer to downward surface fluxes)
    !    rnirb.....near-ir beam cloudy skies (refer to downward surface fluxes)
    !    rnird.....near-ir diffuse cloudy skies (refer to downward surface fluxes)
    !    inalb.....inalb Input two types of surface albedo
    !              >>> inalb= 1 : input two  types surfc albedo (2 diffused)
    !                  direct beam albedos are calculated by the subr.
    !              >>> inalb= 2 : input four types surfc albedo (2 diff,2 direct)

    !    trint....ir subr. call interval in hours  trint=3.0e0
    !             long  wave radiation call interval in hours
    !    swint....short wave radiation call interval in hours swint=1.0e0,
    !    ultclr...Upward lonwave flux (clear) at the top (W/m2)
    !    rsclr....Net surface longwave flux (clear) (W/m2)
    !    dlwclr...Downward longwave (clear) At the bottom (W/m2)
    !    htrc.....Heating rate due to shortwave (clear) (K/s)
    !    clrc.....Cooling rate due to shortwave (clear) (K/s)
    !    rvisdc...Visible diffuse clear sky (Refer to downward surface
    !             shortwave fluxe)
    !    rnirdc...Near-IR diffuse clear skies (Refer to downward surface
    !             shortwave fluxe)
    !    rvisbc...Visible beam clear sky (Refer to downward surface
    !             shortwave fluxe)
    !    rnirbc...Near-IR beam clear skies (Refer to downward surface
    !             shortwave fluxe)
    !    yvisdc...Downward Surface shortwave fluxe visible diffuse (clear)
    !    ynirdc...Downward Surface shortwave fluxe Near-IR diffuse (clear)
    !    yvisbc...Downward Surface shortwave fluxe visible beam (clear)
    !    ynirbc...Downward Surface shortwave fluxe Near-IR beam (clear)
    !    icld.....>>> icld = 1    : old cloud emisivity (optical depth) setting
    !         ccu :  0.05 *dp
    !         css :  0.025*dp       for ice cloud t<253.0
    !     0.05 *dp       for ice cloud t>253.0
    !  >>> icld = 2    : new cloud emisivity (optical depth) setting
    !         ccu :  (0.16)*dp
    !         css :   0.0         t<-82.5c
    !     (2.0e-6*(t-tcrit)**2)*dp    -82.5<t<-10.0c
    !     (6.949e-3*(t-273)+.08)*dp   -10.0<t< 0.0c
    !     (0.08)*dp       -10.0<t< 0.0c
    !  >>> icld = 3    : ccm3 based cloud emisivity
    !
    !    cosz.....cosine of solar zenith angle
    !    yvisd....Downward Surface shortwave fluxe visible diffuse (cloudy)
    !    ynird....Downward Surface shortwave fluxe Near-IR diffuse (cloudy)
    !    yvisb....Downward Surface shortwave fluxe visible beam (cloudy)
    !    ynirb....Downward Surface shortwave fluxe Near-IR beam (cloudy)
    !    yswtop...swinc....solar input at top of atmosphere
    !    xvisdc...Downward Surface shortwave fluxe visible diffuse (clear)
    !    xnirdc...Downward Surface shortwave fluxe Near-IR diffuse (clear)
    !    xvisbc...Downward Surface shortwave fluxe visible beam (clear)
    !    xnirbc...Downward Surface shortwave fluxe Near-IR beam (clear)
    !    xvisd....Downward Surface shortwave fluxe visible diffuse (cloudy)
    !    xnird....Downward Surface shortwave fluxe Near-IR diffuse (cloudy)
    !    xvisb....Downward Surface shortwave fluxe visible beam (cloudy)
    !    xnirb....Downward Surface shortwave fluxe Near-IR beam (cloudy)
    !    cld3.....Total saturation cloud amount
    !    rs.......net surface ir radiation in w/m**2
    !    tod......model forecast time of day in seconds
    !    idate(4)..idate(1)=initial hour of
    !   idate(2)=day of month.
    !   idate(3)=month of year.
    !   idate(4)=year.
    !    cldtd.....Large scale cloud amount
    !    cldin.....clow change necessary in order to properly mark inv
    !              cloud height
    !    cstcin
    !    cldcon....convc  =  ncols*jmax convective cloud cover in 3 hr. avrage
    !    cldson
    !    clwd......Cloud liquid water path. A copy of matrix clwp(i,k)
    !              only works if usind icld=3 or 4 (i.e. arakawa or clirad with ccm3)
    !    emisd.....emis(i,kflip) = 1.- EXP(-1.66*rkabs(i,k)*clwp(i,k))
    !    taud......Shortwave cloud optical depth
    !              only works if usind icld=3 or 4 (i.e. arakawa or clirad with ccm3)
    !                 clwp1(i,kflip)=0.70*(tauxcl(i,k)+tauxci(i,k))
    !                 clwp1(i,kflip)=1.*(tauxcl(i,k)+tauxci(i,k))
    !                 taud(i,k)=clwp1(i,kflip)
    !    tsea......effective surface radiative temperature ( tgeff )
    !    yrl.......length of year in days
    !    monl(12)..length of each month in days
    !    cp........Specific heat of air           (j/kg/k)
    !    gasr......gas constant of dry air        (j/kg/k)
    !    grav......gravity constant               (m/s**2)
    !    solcon....solar constant at mean sun-earth distance(w/m**2)
    !    co2val....co2val is wgne standard value in ppm "co2val = /345.0/
    !    delt......time interval in sec (fixed throuh the integration)
    !    nfin0.....input  file at time level t-dt
    !    nfin1.....input  file at time level t
    !    nfcnv0....initial information on convective clouds for int. radiation
    !
    !
    !
    !
    !
    !
    !
    !
    !    dodia.....Variable logical for search for combined field components.
    !    nfprt....standard print out unit
    !             0 no print, 1 less detail, 2 more detail, 3 most detail
    !    nferr....error print out unit
    !             0 no print, 1 less detail, 2 more detail, 3 most detail
    !    nfctrl....print control:
    !             0 no print, 1 less detail, 2 more detail, 3 most detail
    !    first....control logical variable .true. or .false.
    !    mxrdcc...use maximum random converage for radiative conv. clouds
    !             constant logical mxrdcc = .true.
    !    lcnvl....the lowest layer index where non-convective clouds can
    !             occur (ben says this should be 2 or more)
    !             constant lcnvl = 2
    !    lthncl...Minimum depth in mb of non-zero low level cloud
    !             constant lthncl=80
    !    convc....ncols convective cloud cover in 3 hr. avrage
    !    convt....ncols convective cloud top  (sigma layer)
    !    convb....ncols convective cloud base (sigma layer)
    !    convts
    !    convcs
    !    convbs
    !==========================================================================
    INTEGER, INTENT(IN   ) :: ncols
    INTEGER, INTENT(IN   ) :: jmax
    INTEGER, INTENT(IN   ) :: kmax
    INTEGER, INTENT(IN   ) :: nls
    INTEGER, INTENT(IN   ) :: nlcs


    INTEGER, INTENT(in   ) :: id(4)
    INTEGER, INTENT(in   ) :: jlat
    REAL(KIND=r8),    INTENT(in   ) :: colrad(ncols)
    REAL(KIND=r8),    INTENT(in   ) :: lonrad(ncols)
    REAL(KIND=r8),    INTENT(in   ) :: gps   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: gtmp  (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: gwv   (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: gtg   (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: grh   (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: omg   (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: clr   (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: htr   (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: avisd (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: anird (ncols)
    REAL(KIND=r8),    INTENT(inout) :: avisb (ncols)
    REAL(KIND=r8),    INTENT(inout) :: anirb (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dlwbot(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: ulwtop(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dswtop(ncols)
    REAL(KIND=r8),    INTENT(in   ) :: sig   (kmax)
    REAL(KIND=r8),    INTENT(in   ) :: sigml (kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: rvisd (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rnird (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rvisb (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rnirb (ncols)
    INTEGER, INTENT(in   ) :: inalb
    REAL(KIND=r8),    INTENT(in   ) :: trint
    REAL(KIND=r8),    INTENT(in   ) :: swint
    REAL(KIND=r8),    INTENT(inout  ) :: ultclr(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rsclr (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: dlwclr(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: htrc  (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: clrc  (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: rvisdc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rnirdc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rvisbc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rnirbc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: yvisdc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: ynirdc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: yvisbc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: ynirbc(ncols)
    INTEGER, INTENT(in   ) :: icld
    REAL(KIND=r8),    INTENT(inout  ) :: cosz  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: yvisd (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: ynird (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: yvisb (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: ynirb (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: yswtop(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: xvisdc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: xnirdc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: xvisbc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: xnirbc(ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: xvisd (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: xnird (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: xvisb (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: xnirb (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: cld3  (ncols)
    REAL(KIND=r8),    INTENT(inout  ) :: rs    (ncols)
    INTEGER, INTENT(in   ) :: ifday
    REAL(KIND=r8),    INTENT(in   ) :: tod
    INTEGER, INTENT(in   ) :: idate(4)
    REAL(KIND=r8),    INTENT(inout  ) :: cldtd (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: cldin (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: cstcin(ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: cldcon(ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: cldson(ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: clwd  (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: emisd (ncols,kmax)
    REAL(KIND=r8),    INTENT(inout  ) :: taud  (ncols,kmax)
    REAL(KIND=r8),    INTENT(in   ) :: tsea  (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: yrl
    REAL(KIND=r8),    INTENT(in   ) :: co2val
    REAL(KIND=r8),    INTENT(in   ) :: delt
    INTEGER, INTENT(in   ) :: nfin0
    INTEGER, INTENT(in   ) :: nfin1
    INTEGER, INTENT(in   ) :: nfcnv0
    LOGICAL, INTENT(in   ) :: first
    LOGICAL, INTENT(in   ) :: mxrdcc
    INTEGER, INTENT(in   ) :: lcnvl
    INTEGER, INTENT(in   ) :: lthncl
    REAL(KIND=r8),    INTENT(in   ) :: convc (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: convt (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: convb (ncols)
    REAL(KIND=r8),    INTENT(in   ) :: convts(ncols)
    REAL(KIND=r8),    INTENT(in   ) :: convcs(ncols)
    REAL(KIND=r8),    INTENT(in   ) :: convbs(ncols)
    REAL(KIND=r8)   , INTENT(IN   ) :: cos2d (ncols)
    LOGICAL, INTENT(IN   ) :: intcosz
    INTEGER(KIND=i8), INTENT(IN   ) :: imask (ncols)
    REAL(KIND=r8),    INTENT(INOUT) :: o3mix(ncols,kMax)
    REAL(KIND=r8) :: swinc (ncols)
    REAL(KIND=r8) :: cos2  (ncols)
    REAL(KIND=r8) :: zswtop(ncols)
    REAL(KIND=r8) :: cos1  (ncols)
    REAL(KIND=r8) :: dswclr(ncols)
    REAL(KIND=r8) :: ssclr (ncols)
    REAL(KIND=r8) :: ss    (ncols)
    !
    !     arrays temporarily for flipping sw and lw i/o
    !
    REAL(KIND=r8) :: pl20    (ncols,kmax)
    REAL(KIND=r8) :: dpl     (ncols,kmax)
    REAL(KIND=r8) :: tl      (ncols,kmax)
    REAL(KIND=r8) :: ql      (ncols,kmax)
    REAL(KIND=r8) :: o3l     (ncols,kmax)
    REAL(KIND=r8) :: cld1    (ncols,kmax)
    REAL(KIND=r8) :: clu1    (ncols,kmax)
    REAL(KIND=r8) :: asclr   (ncols,kmax)
    REAL(KIND=r8) :: asl     (ncols,kmax)
    REAL(KIND=r8) :: pl      (ncols,kmax)
    INTEGER :: idatex(4)
    REAL(KIND=r8) :: cdin    (ncols,kmax)
    REAL(KIND=r8) :: cstc    (ncols,kmax)
    REAL(KIND=r8) :: ccon    (ncols,kmax)
    REAL(KIND=r8) :: cson    (ncols,kmax)
    REAL(KIND=r8) :: zi      (ncols,kmax+1) ! height of layer bottom
    REAL(KIND=r8) :: pw      (ncols)        ! vertically integrated water vapor or precipitable water
    REAL(KIND=r8) :: hl1     (ncols)        ! cloud water scale heigh
    REAL(KIND=r8) :: rhl     (ncols)        ! 1/hl1
    REAL(KIND=r8) :: emziohl (ncols,kmax+1) ! Exponential of Minus ZI Over HL
    REAL(KIND=r8) :: clwp    (ncols,kmax)   ! Cloud Liquid Water Path
    REAL(KIND=r8) :: rei     (ncols,kmax)   ! Ice particle Effective Radius (microns)
    REAL(KIND=r8) :: fice    (ncols,kmax)   ! fractional amount of cloud that is ice
    REAL(KIND=r8) :: rel     (ncols,kmax)   ! Liquid particle Effective Radius (microns)
    REAL(KIND=r8) :: sigs    (kmax)         ! Different of sigma coordinate at bottom and top of each layer

    CHARACTER(len=4), PARAMETER :: covlp='RAND'
    LOGICAL         , PARAMETER :: noz  = .FALSE.
    REAL(KIND=r8)            , PARAMETER :: dtc3 = 1.0e0_r8
    REAL(KIND=r8)    :: delta
    REAL(KIND=r8)    :: ratio
    REAL(KIND=r8)    :: etime
    REAL(KIND=r8)    :: date
    REAL(KIND=r8)    :: s0
    REAL(KIND=r8)    :: sindel
    REAL(KIND=r8)    :: cosdel
    REAL(KIND=r8)    :: deltax
    REAL(KIND=r8)    :: ratiox
    REAL(KIND=r8)    :: etimex
    REAL(KIND=r8)    :: datex
    REAL(KIND=r8)    :: s0x
    REAL(KIND=r8)    :: sindlx
    REAL(KIND=r8)    :: cosdlx
    REAL(KIND=r8)    :: todx


    INTEGER :: ifdayx
    INTEGER :: jhr
    INTEGER :: jmon
    INTEGER :: jday
    INTEGER :: jyr
    INTEGER :: ncount
    INTEGER :: i
    INTEGER :: k
    INTEGER    :: kflip
    REAL(KIND=r8)    :: coslat (ncols)
    REAL(KIND=r8)    :: sinlat (ncols)
    REAL(KIND=r8)    :: coslatx(ncols)
    REAL(KIND=r8)    :: sinlatx(ncols)
    REAL(KIND=r8)    :: cosmax
    REAL(KIND=r8)    :: frh
    REAL(KIND=r8)    :: frhx
    REAL(KIND=r8)    :: atime
    REAL(KIND=r8)    :: atime1
    REAL(KIND=r8)    :: rgrav ! 1/gravity
    REAL(KIND=r8)    :: pptop
    REAL(KIND=r8)    :: clwc0 ! =0.21g/m3
    REAL(KIND=r8), PARAMETER :: reimin  = 10.0_r8 ! R_ei^min or Minimum of Ice particle efective radius
    REAL(KIND=r8), PARAMETER :: reirnge = 20.0_r8 ! R_ei^range or Range of Ice particle efective radius (maximum - minimum)
    REAL(KIND=r8), PARAMETER :: sigrnge = 0.4_r8  ! p_I^range or Normalized pressure range (high-low)
    REAL(KIND=r8), PARAMETER :: sigmax  = 0.4_r8  ! p_I^high is 0.4
    REAL(KIND=r8)    :: weight

    ! Initialization local variables
    pw=0.0_r8
    rgrav=0.0_r8
    IF(ABS( MOD((tod-delt)/3.6e3_r8+0.03125e0_r8,swint)).GT.0.0625e0_r8 &
         .AND..NOT.first)RETURN
    !
    !-- computation of astronomical parameters -----------------------------
    !-----------------------------------------------------------------------
    !.. delta ;solar inclination
    !.. etime ;correction factor to local time
    !.. ratio ;factor relating to the distance between the earth and the sun
    !.. date;julian day
    !
    CALL radtim (id    ,delta ,ratio ,etime ,tod   ,date  ,yrl)

    IF(jlat.EQ.1) THEN
       IF(nfctrl(87).GE.2)WRITE(nfprt,100) id,date
       IF(nfctrl(87).GE.2)WRITE(nfprt,101) delta,ratio,etime
    ENDIF

    ifdayx=ifday
    todx=tod+swint*3.6e3_r8

    IF(todx.GE.86400.0_r8)THEN
       todx= MOD(todx,86400.0_r8)
       ifdayx=ifdayx+1
    END IF

    CALL tmstmp2(idate ,ifdayx,todx  ,jhr   ,jday  ,jmon  ,jyr   )

    idatex(1)=jhr
    idatex(2)=jmon
    idatex(3)=jday
    idatex(4)=jyr

    CALL radtim(idatex,deltax,ratiox,etimex,todx  ,datex ,yrl)

    s0    =solcon*ratio
    s0x   =solcon*ratiox
    sindel=SIN(delta)
    cosdel=COS(delta)
    sindlx=SIN(deltax)
    cosdlx=COS(deltax)
    DO i=1,ncols
       coslat(i)  = cosdel*SIN(colrad(i))
       sinlat(i)  = sindel*COS(colrad(i))
       coslatx(i) = cosdlx*SIN(colrad(i))
       sinlatx(i) = sindlx*COS(colrad(i))
    END DO
    cosmax=0.0e0_r8
    ncount=0
    frh=( MOD(tod+0.03125_r8,3.6e3_r8)-0.03125_r8)/3.6e3_r8
    frhx=( MOD(todx+0.03125_r8,3.6e3_r8)-0.03125_r8)/3.6e3_r8
    DO i=1,ncols
       atime =etime+pai12*(12.0_r8-id(1)-lonrad(i)*fim24-frh)
       atime1=etimex+pai12*(12.0_r8-idatex(1)-lonrad(i)*fim24-frhx)
       cosz(i)=sinlat(i)  + coslat(i)  * COS(atime )
       cos1(i)=sinlatx(i) + coslatx(i) * COS(atime1)
       IF(cosz(i).GT.0.0e0_r8) THEN
          !  cosmax =cosmax+cosz(i)
          ncount =ncount+1
       END IF
    END DO

    IF(ncount.EQ.0) ncount=1

    IF(intcosz)THEN
       !cos2=cos2/REAL(ncount,r8)!!!!mudanca forcada
       cos2=cos2d
    ELSE
       cos2=cosz
    END IF

    !-----------------------------------------------------------------------
    !.. interpolate ozone amount from climatological value
    !..    oz   ;ozon mixing ratio in g/g
    !
    ! hmjb: Agora o3l e nao o3l18 eh passado para getoz().
    !   o3l invertido eh copiado para o3mix que sai pra fora da spmrad
    !   e eh gravado como diagnostico atraves da updia(). A chamada para
    !   updia do ozonio era feita aqui mas isso estava errado! tem que
    !   ser feito fora.
    IF (ifozone.eq.0) THEN
       CALL getoz (ncols,colrad,date  ,o3l ,sig   ,kmax)
       DO k=1,kmax
          kflip=kmax+1-k
          DO i = 1,ncols
             o3mix(i,k)=o3l(i,kflip)
          END DO
       END DO
    ELSE
       ! If ifozone!=0, then we have to use the value read from file
       ! ... but we still have to flip it for the radiation routines
       DO k=1,kmax
          kflip=kmax+1-k
          DO i = 1,ncols
             o3l(i,kflip)=o3mix(i,k)
          END DO
       END DO
    ENDIF

    !-----------------------------------------------------------------------
    !
    !.. assign cloud amount
    !..    cld  ;large scale
    !..    clu  ;cumulus

    IF (TRIM(iswrad).eq.'LCH'.OR.TRIM(iswrad).eq.'NON') THEN
       IF(icld.EQ.1) &
            CALL cldgen (covlp ,gps   ,sig   ,grh   ,omg   ,gtmp  ,cld1  , &
            clu1  ,cdin  ,cstc  ,ccon  ,cson  ,mxrdcc,lcnvl ,lthncl, &
            convc ,convt ,convb ,ncols ,kmax  ,nls     )

       IF(icld.EQ.3) &
            CALL cldgn2 ( covlp ,gps   ,sig   ,grh   ,omg   ,gtmp  ,cld1  , &
            clu1  ,cdin  ,cstc  ,ccon  ,cson  ,mxrdcc,lcnvl ,convc ,convt ,convb , &
            convts,convcs,convbs,ncols ,kmax  ,nls            )
    ELSE
       CALL cldgn3 (gps   ,sig   ,grh   ,omg   ,gtmp  ,cld1  , &
            clu1  ,cdin  ,cstc  ,ccon  ,cson  ,lcnvl ,lthncl, &
            convc ,convt ,convb ,ncols ,kmax  ,nls     )
    ENDIF
    !
    !     compute cloud cover diagnostic
    !
    DO i=1,ncols
       cld3(i) = 1.0e0_r8
       IF(icld.EQ.3.or.icld.EQ.4)pw(i)=0.0_r8
    END DO

    if (TRIM(iswrad).eq.'LCH'.OR.TRIM(iswrad).eq.'NON') then
       DO k=1,kmax
          kflip=kmax+1-k
          DO i=1,ncols
             cldtd(i,k)=cld1(i,kflip) !->cldtot (total cloud cover)
             cld3(i) = cld3(i)*(1.0e0_r8-cld1(i,k))
          END DO
       END DO
    else
       DO k=1,kmax
          kflip=kmax+1-k
          DO i=1,ncols
             cldtd(i,k)=max(cld1(i,kflip),clu1(i,kflip)) !->cldtot (total cloud cover)
             cld3(i) = cld3(i)*(1.0e0_r8-cldtd(i,k))
          END DO
       END DO
    endif

    DO i=1,ncols
       cld3(i) = 1.0e0_r8-cld3(i)
    END DO

    DO k=1,kmax
       DO i=1,ncols
          clwd(i,k)=0.0_r8
          cldin(i,k)=cdin(i,k)  ! =cldinv (outside spmrad) Inversion clouds
          cstcin(i,k)=cstc(i,k) ! =cldsat (outside spmrad) Saturation clouds
          cldcon(i,k)=ccon(i,k) ! =cldcon (outside spmrad) Convection clouds
          cldson(i,k)=cson(i,k) ! =cldson (outside spmrad) Shallow convective clouds
       END DO
    END DO
    !
    !     prepare pressure input and flip arrays for short and long wave
    !
    IF(icld.EQ.3.or.icld.EQ.4)THEN
       DO k=1,kmax-1
          sigs(k)=0.0_r8
          sigs(k)=sigml(k)-sigml(k+1)
       END DO
       sigs(kmax)=sigml(kmax)
       rgrav=1.0_r8/grav
    ENDIF
    DO k=1,kmax
       kflip=kmax+1-k
       DO i = 1,ncols
          tl(i,k)=gtmp(i,kflip)
          ql(i,k)=gwv (i,kflip)
          pl20(i,k)=gps(i)*sigml(kflip)
          pl  (i,k)=gps(i)*sig  (kflip)
          IF(icld.EQ.3.or.icld.EQ.4)pw(i) = pw(i) + sigs(k)*gwv(i,k)
       END DO
    END DO
    pptop=0.5e0_r8
    DO i = 1,ncols
       dpl(i,1)=pl20(i,1)-pptop
       ! precitable water, pw = sum_k { sigs(k) . gwv(k) } . gps . 100 / g
       !                   pw = sum_k { Dp(k) . gwv(k) } / g
       !
       ! 100 is to change from mbar to pascal
       ! Dp(k) is the difference of pressure (N/m2) between bottom and top of layer
       ! gwv(k) is specific humidity in (g/g)
       ! gravity is m/s2 => so pw is in Kg/m2
       IF(icld.EQ.3.or.icld.EQ.4)pw(i)=100.0_r8*pw(i)*gps(i)*rgrav
    END DO
    DO k=2,kmax
       DO i = 1,ncols
          dpl(i,k)=pl20(i,k)-pl20(i,k-1)
       END DO
    END DO
    ! As in the CCM2, cloud optical properties in the CCM3 are accounted for using
    ! the Slingo (1989) parameterization for liquid water droplet clouds. This
    ! scheme relates the extinction optical depth, the single-scattering albedo,
    ! and the asymmetry parameter to the cloud liquid water path and cloud drop
    ! effective radius. The latter two microphysical cloud properties were
    ! statically specified in the CCM2. In particular, in-cloud liquid water paths
    ! were evaluated from a prescribed, meridionally and height varying, but
    ! time independent, cloud liquid water density profile, rho_l(z), which
    ! was analytically determined on the basis of a meridionally specified
    ! liquid water scale height (e.g. see Kiehl et al., 1994; Kiehl, 1991).
    ! The cloud drop effective radius was simplly specified to be 10microns
    ! for all clouds. The CCM3 continues to diagnose cloud optical properties,
    ! but relaxes the rigid CCM2 framework. CCM3 employs the same exponentially
    ! decaying vertical profile for in-cloud water concentration
    !
    !             rho_l=rho_l^0*exp(-z/h_l)               eq 4.a.11
    !
    ! , where rho_l^0=0.21g/m3. Instead of specifying a zonally symmetric meridional
    ! dependence for the cloud water scale heigh, h_l, it is locally diagnosed
    ! as a function of the vertically integrated water vapor (precipitable water)
    !
    !          h_l=700 ln [1+\frac{1}{g} \int_pT^ps q dp]  eq 4.a.12
    !
    ! hmjb> It is not explained, but the units of h_l must be meters, the same
    ! hmjb> of the height, z.
    !
    ! The cloud water path (CWP) is determined by integrating the liquid
    ! water concentration using
    !
    !                 cwp = int rho_l dz     eq. 4.a.13
    !
    ! Which can be analytically evaluated for an arbitrary layer k as
    !
    !  rho_l^0 h_l [exp(-z_bot(k)/h_l) - exp(-z_top(k)/h_l)]   eq. 4.a.14
    !
    ! Where z_bot and z_top are the heights of the k'th layer interfaces.
    !
    ! hmjb> It is not explained, but the units of clwp must be g/m2
    ! hmjb> since it is the integral of rho_l*dz (eq.4.a.13)
    !
    IF(icld.EQ.3.or.icld.EQ.4)THEN
       DO i=1,ncols
          zi(i,1)=0.0_r8
       END DO
       DO k=2,kmax
          DO i=1,ncols
             zi(i,k)=zi(i,k-1)+(gasr/grav)*gtmp(i,k-1)* &
                  LOG(pl20(i,kmax+2-k)/pl20(i,kmax+1-k))
          END DO
       END DO
       !
       !     need to estimate the height of the model top
       !
       DO i=1,ncols
          zi(i,kmax+1)=zi(i,kmax)+(gasr/grav)*gtmp(i,kmax)* &
               LOG(pl20(i,1)/pptop)
       END DO
       !
       !     now to compute the cloud liquid water path
       !     set reference liquid water concentration
       !
       clwc0 = 0.21_r8 ! g/m3
       !
       !     diagnose liquid water scale height from precipitable water
       !
       DO i=1,ncols
          hl1(i)  = 700.0_r8*LOG(MAX(pw(i)+1.0_r8,1.0_r8))
          rhl(i) = 1.0_r8/hl1(i)
       END DO
       !hmjb> emziohl stands for Exponential of Minus ZI Over HL
       DO k=1,(kmax+1)
          DO i=1,ncols
             emziohl(i,k) = EXP(-zi(i,k)*rhl(i))
          END DO
       END DO

       ! WARN: clwp vector is not flipped as other arrays
       ! The units are g/m2.
       DO k=1,kmax
          DO i=1,ncols
             clwp(i,k) = clwc0*hl1(i)*(emziohl(i,k) - emziohl(i,k+1))
             clwd(i,k)=clwp(i,k)
          END DO
       END DO

       ! CCM3 Documentation, pg 50
       ! Observational studies have shown a distinct difference between
       ! maritime and continental effective cloud drop size, r_e, for warm
       ! clouds. For this reason, the CCM3 differentiates between the cloud
       ! drop effective radius for clouds diagnosed over maritime and
       ! continental regimes (Kiehl, 1994). Over the ocean, the cloud drop
       ! effective radius for liquid water clouds, r_el, is specified to be
       ! 10microns, as in the CCM3. Over land masses r_el is determined using
       !
       ! r_el = 5 microns             T > -10oC
       !      = 5-5(t+10)/20 microns  -30oC <= T <= -10oC     eq. 4.a.14.1
       !      = r_ei                  T < -30oC
       !
       ! An ice particle effective radius, r_ei, is also diagnosed by CCM3,
       ! which at the moment amounts to a specification of ice radius as a
       ! function of normalized pressure
       !
       ! r_ei = 10 microns                                 p/ps > p_I^high
       !      = r_ei^max - (r_ei^max - r_ei^min)           p/ps <= p_I^high       eq. 4.a.15.1
       !            *[(p/ps)-p_I^high/(p_I^high-p_I^low)]
       !
       ! where r_ei^max=30microns, r_ei^min=10microns, p_I^high=0.4 and p_I^low=0.0
       !
       ! hmjb>> I think there is a typo in the equation, otherwise the
       ! hmjb>> expression for r_ei is not continuous funcion of p/ps.
       ! hmjb>> For p/ps=p_I^high, r_ei should be r_ei^min and not r_ei^max.
       ! hmjb>> The correct equation is:
       ! hmjb>> r_ei = 10 microns                                 p/ps > p_I^high
       ! hmjb>>      = R_EI^MIN - (r_ei^max - r_ei^min)           p/ps <= p_I^high
       ! hmjb>>            *[(p/ps)-p_I^high/(p_I^high-p_I^low)]
       !

       ! determine Ice particle Effective Radius (rei)
       ! as function of normalized pressure
       ! docs CCM3, eq 4.a.15.1
       DO k=1,kmax
          weight   = MIN((sig(k)-sigmax)/sigrnge,0.0_r8)
          DO i=1,ncols
             rei(i,k) = reimin - reirnge*weight
          END DO
       END DO

       ! define fractional amount of cloud that is ice
       ! if warmer than -10 degrees c then water phase
       ! docs CCM3, eq 4.a.16.1
       fice=MAX(MIN((263.16_r8-gtmp)*0.05_r8,1.0_r8),0.0_r8)

       ! determine Liquid particle Effective Radius (rel)
       ! as function of normalized pressure
       ! docs CCM3, eq 4.a.15.1

       DO i=1,ncols
          IF (imask(i) .lt. 1) THEN
             rel(i,:) = 10.0_r8
          ELSE
             rel(i,:) = 5.0_r8+5.0_r8*fice(i,:)
             WHERE(fice(i,:).eq.1) rel(i,:) = rei(i,:)
          END IF
       END DO
    ENDIF
    !
    !     shortwave radiation
    !
    IF(first.AND.ifday.EQ.0.AND.tod.EQ.0.0_r8) THEN
       IF (TRIM(iswrad).eq.'LCH') THEN
          !old sw radiation routines
          CALL swrad(ncols ,kmax  ,nls   ,dtc3  ,noz   ,icld  ,s0    ,inalb , &
               avisd ,anird ,avisb ,anirb ,cos2  ,pl20  ,dpl   ,tl    , &
               ql    ,o3l   ,cld1  ,clu1  ,swinc ,dswclr,zswtop,ssclr , &
               ss    ,asclr ,asl   ,xvisbc,xvisdc,xnirbc,xnirdc,xvisb , &
               xvisd ,xnirb ,xnird ,clwp  ,fice  ,rei   ,taud  ,tsea  , rel  )
       ELSE IF (TRIM(iswrad).eq.'CRD') THEN
          !Clirad-sw radiation routines
          CALL cliradintf(&
               ncols ,kmax  ,nls   ,noz   ,icld  ,s0    ,inalb , &
               avisd ,anird ,avisb ,anirb ,cos2  ,pl20  ,dpl   ,tl    , &
               ql    ,o3l   ,cld1  ,clu1  ,swinc ,dswclr,zswtop,ssclr , &
               ss    ,asclr ,asl   ,xvisbc,xvisdc,xnirbc,xnirdc,xvisb , &
               xvisd ,xnirb ,xnird ,clwp  ,fice  ,rei   ,taud  ,tsea  , &
               gps   ,imask ,rel)
       ELSE IF (TRIM(iswrad).eq.'UKM') THEN
          WRITE(nfprt,*) 'ERROR:: UKMO not yet implemented!'
          STOP
       ELSE IF (TRIM(iswrad).eq.'NON') THEN
          WRITE(nfprt,*) 'WARN:: Skipping shortwave computation at idate=',idate
       ELSE
          WRITE(nfprt,*) 'ERROR:: WRONG OPTION iswrad=',TRIM(iswrad)
          STOP
       ENDIF

       IF(jlat.EQ.jmax/2+1.AND.nfctrl(87).GE.1)WRITE(nfprt,70)icld
    END IF

    IF(first.AND.(nfcnv0.EQ.0.OR.(nfcnv0.NE.0.AND.nfin0.EQ. &
         nfin1)))THEN
       IF (TRIM(iswrad).eq.'LCH') THEN
          !old sw radiation routines
          CALL swrad(ncols ,kmax  ,nls   ,dtc3  ,noz   ,icld  ,s0    ,inalb , &
               avisd ,anird ,avisb ,anirb ,cosz  ,pl20  ,dpl   ,tl    , &
               ql    ,o3l   ,cld1  ,clu1  ,swinc ,dswclr,zswtop,ssclr , &
               ss    ,asclr ,asl   ,rvisbc,rvisdc,rnirbc,rnirdc,rvisb , &
               rvisd ,rnirb ,rnird ,clwp  ,fice  ,rei   ,taud  ,tsea  , rel  ) !hmjb
       ELSE IF (TRIM(iswrad).eq.'CRD') THEN
          !Clirad-sw radiation routines
          CALL cliradintf(&
               ncols ,kmax  ,nls   ,noz   ,icld  ,s0    ,inalb , &
               avisd ,anird ,avisb ,anirb ,cosz  ,pl20  ,dpl   ,tl    , &
               ql    ,o3l   ,cld1  ,clu1  ,swinc ,dswclr,zswtop,ssclr , &
               ss    ,asclr ,asl   ,rvisbc,rvisdc,rnirbc,rnirdc,rvisb , &
               rvisd ,rnirb ,rnird ,clwp  ,fice  ,rei   ,taud  ,tsea  , &
               gps   ,imask ,rel)
       ELSE IF (TRIM(iswrad).eq.'UKM') THEN
          WRITE(nfprt,*) 'ERROR:: UKMO not yet implemented!'
          STOP
       ELSE IF (TRIM(iswrad).eq.'NON') THEN
          WRITE(nfprt,*) 'WARN:: Skipping shortwave computation at idate=',idate
       ELSE
          WRITE(nfprt,*) 'ERROR:: WRONG OPTION iswrad=',TRIM(iswrad)
          STOP
       ENDIF

       DO i=1,ncols
          dswtop(i)=swinc (i)
       END DO

       IF(jlat.EQ.jmax/2+1.AND.nfctrl(87).GE.1) WRITE(nfprt,765)ifday,tod

    END IF

    IF (TRIM(iswrad).eq.'LCH') THEN
       !old sw radiation routines
       CALL swrad(ncols ,kmax  ,nls   ,dtc3  ,noz   ,icld  ,s0x   ,inalb , &
            avisd ,anird ,avisb ,anirb ,cos1  ,pl20  ,dpl   ,tl    , &
            ql    ,o3l   ,cld1  ,clu1  ,swinc ,dswclr,zswtop,ssclr , &
            ss    ,asclr ,asl   ,yvisbc,yvisdc,ynirbc,ynirdc,yvisb , &
            yvisd ,ynirb ,ynird ,clwp  ,fice  ,rei   ,taud  ,tsea  , rel  ) !hmjb
    ELSE IF (TRIM(iswrad).eq.'CRD') THEN
       !Clirad-sw radiation routines
       CALL cliradintf(&
            ncols ,kmax  ,nls   ,noz   ,icld  ,s0x   ,inalb , &
            avisd ,anird ,avisb ,anirb ,cos1  ,pl20  ,dpl   ,tl    , &
            ql    ,o3l   ,cld1  ,clu1  ,swinc ,dswclr,zswtop,ssclr , &
            ss    ,asclr ,asl   ,yvisbc,yvisdc,ynirbc,ynirdc,yvisb , &
            yvisd ,ynirb ,ynird ,clwp  ,fice  ,rei   ,taud  ,tsea  , &
            gps   ,imask , rel)
    ELSE IF (TRIM(iswrad).eq.'UKM') THEN
       WRITE(nfprt,*) 'ERROR:: UKMO not yet implemented!'
       STOP
    ELSE IF (TRIM(iswrad).eq.'NON') THEN
       WRITE(nfprt,*) 'WARN:: Skipping shortwave computation at idate=',idate
    ELSE
       WRITE(nfprt,*) 'ERROR:: WRONG OPTION iswrad=',TRIM(iswrad)
       STOP
    ENDIF

    DO k=1,kmax
       DO i=1,ncols
          htr(i,k)=asl(i,kmax+1-k)    ! heating rate
          htrc(i,k)=asclr(i,kmax+1-k) ! heating rate clear
       END DO
    END DO

    DO i=1,ncols
       yswtop(i)=swinc (i)
    END DO

    IF(jlat.EQ.jmax/2+1.AND.nfctrl(87).GE.2)WRITE(nfprt,765)ifday,tod
    !
    !     longwave radiation
    !
    IF(ABS( MOD((tod-delt)/3.6e3_r8+0.03125e0_r8,trint)).LE.0.0625e0_r8 &
         .OR.first)THEN

       ! New shortwave schemes need cld and clu separately, but old longwave scheme
       ! need them maximum overlaped. If you look above, you'll see that for CRD and UKM
       ! the new cldgn3() outputs both clu and cld... Therefore, before calling
       ! old longwave, we restore the state of the cloud field.
       IF(.not.(TRIM(iswrad).eq.'LCH'.OR.TRIM(iswrad).eq.'NON')) THEN
          if (mxrdcc) then
             cld1 = MAX(cld1,clu1)
             clu1 = 0.0_r8
          else
             clu1 = 0.0_r8
          endif
       END IF

       IF (TRIM(ilwrad).ne.'NON') THEN
          CALL lwrad( dtc3  ,noz   ,icld  ,gtg   ,pl20  ,pl    ,tl    ,ql    , &
               o3l   ,cld1  ,clu1  ,ultclr,ulwtop,asclr ,asl   ,rsclr , &
               rs    ,dlwclr,dlwbot,clwp  ,fice  ,rei   ,emisd ,co2val, &
               ncols ,kmax  ,nls   ,nlcs                                   )

          DO k=1,kmax
             DO i = 1,ncols
                clr(i,k)=asl(i,kmax+1-k)    ! cooling rate
                clrc(i,k)=asclr(i,kmax+1-k) ! cooling rate clear
             END DO
          END DO
       ENDIF

    ENDIF

70  FORMAT(' SWRAD COMPUTED AT ZENITH WITH ICLD=',I2)
100 FORMAT(' RADTIM CALLED AT ID=',3I3,I5,',JULDAY=',G16.8)
101 FORMAT(' DELTA=',E12.5,' RATIO=',E12.5,' ETIME=',E12.5)
765 FORMAT(' SHORT WAVE RADIATION CALLED AT DAY=',I8,' TIME=',G13.6)
  END SUBROUTINE spmrad
END MODULE Radiation
