       !        
       !        Cray Inc. Decompilation
       !        WARNING - This output is provided for information only.
       !        
       !        Cray Inc. reserves the right to change the format of this
       !        information at any time and does not guarantee the
       !        readability or accuracy of this information.
       !        
       !        This information may not be compilable and corresponds to
       !        the internal representation of the program during the
       !        optimization phase of the compilation process.
       !        
       !        Source                :  GwddDriver.f90
       !        File                  :  GwddDriver.cg
       !        Format                :  Fortran
       !        Target                :  X86, 64-bit
       !        
   44.       
   44.       subroutine initgwdddriver( kmax, si )
   42.       call initgwddschalpert( 0[loc( si ),0].L, 0[loc( kmax ),0] )
   44.       return
   44.       end
   44.       
   86.       
   86.       subroutine gwdd_driver( ps, gu, gv, gt, chug, chvg, xdrag, ydrag, var, varcut, sigml, sig, delsig, ncols, kmax, latco )
   69.       call gwddschalpert( 0[loc( ps ),0].L, 0[loc( gu ),0].L, 0[loc( gv ),0].L, 0[loc( gt ),0].L, 0[loc( chug ),0].L, 0[loc( chvg ),0].L, 0[loc( xdrag ),0].L, 0[loc( ydrag ),0].L, 0[loc( var ),0].L, 0[loc( varcut ),0].L, 0[loc( sigml ),0].L, 0[loc( sig ),0].L, 0[loc( delsig ),0].L, 0[loc( ncols ),0], 0[loc( kmax ),0] )
   76.       if ( startstordiag /= .false. ) then
   77.          call gwdddiagnstorage( 0[loc( latco ),0], 0[loc( ncols ),0], 0[loc( kmax ),0], 0[loc( xdrag ),0].L, 0[loc( ydrag ),0].L, 0[loc( chug ),0].L, 0[loc( chvg ),0].L )
   77.       endif
   82.       t$17 = isgridhistoryon
   86.       return
   86.       end
   86.       
   88.       
   88.       subroutine gwddgridhistorystorage
   92.       return
   92.       end
   92.       
  111.       
  111.       subroutine gwdddiagnstorage( latco, ncols, kmax, xdrag, ydrag, chug, chvg )
  111.       $CARG_ncols_I1 = 0[loc( ncols ),0]
  111.       $CARG_kmax_I2 = 0[loc( kmax ),0]
  106.       $CS_dodia_0 = loc( dodia )
  106.       $MR_dodia_S1 = 7[$CS_dodia_0,0].L
  106.       $MR_dodia_S0 = 6[$CS_dodia_0,0].L
  106.       $LCS_1 = $MR_dodia_S0 + $MR_dodia_S1
  106.       if ( or( -44 + $LCS_1, 43 - $MR_dodia_S0 ) < 0 ) then
  106.          $LB_Y0 = $MR_dodia_S0
  106.          $UB_Y1 = -1 + $LCS_1
  106.          $Subscript_Y5 = 43
  106.          _bounds_error( $_File_Y40, $Line_Y42, $_Name_Y41, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y43 )
  106.       endif
  106.       $MR_dodia_S2 = 0[$CS_dodia_0,0].L
  106.       if ( 43[int( $MR_dodia_S2, 8 ),-$MR_dodia_S0] /= .false. ) then
  106. !dir$ suppress 0[loc( xdrag ),0].L
  106.          t$18 = $_StaticDV_P0
  106.          if ( $CARG_ncols_I1 <= 0 ) then
  106.             $LB_Y0 = 1
  106.             $UB_Y1 = $CARG_ncols_I1
  106.             $Subscript_Y5 = 1
  106.             _bounds_error( $_File_Y40, $Line_Y42, $_Name_Y44, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y45 )
  106.          endif
  106.          0[loc( t$18 ),0].L = pointer to array[1] of real (kind=8)( loc( 0[loc( xdrag ),0].L ) )
  106.          1[loc( t$18 ),0].L = 64
  106.          2[loc( t$18 ),0].L = or( 17, and( 0xfffffffffffffff1UL, 2[loc( t$18 ),0].L ) )
  106.          23[loc( t$18 )].B = 1
  106.          4[loc( t$18 ),0].L = 0
  106.          5[loc( t$18 ),0].L = 0
  106.          21[loc( t$18 )].B = 0
  106.          6[loc( t$18 ),0] = 13
  106.          6[loc( t$18 ),0].L = 1
  106.          7[loc( t$18 ),0].L = max( 0, $CARG_ncols_I1 )
  106.          8[loc( t$18 ),0].L = 1
  106.          2[loc( t$18 ),0].L = or( 131136, and( -4294967265UL, 2[loc( t$18 ),0].L ) )
  106.          $Con_P25 = 43
  106.          call updia1d( t$18, $Con_P25, 0[loc( latco ),0] )
  106.       endif
  107.       $MR_dodia_S4 = 7[$CS_dodia_0,0].L
  107.       $MR_dodia_S3 = 6[$CS_dodia_0,0].L
  107.       $LCS_3 = $MR_dodia_S3 + $MR_dodia_S4
  107.       if ( or( -45 + $LCS_3, 44 - $MR_dodia_S3 ) < 0 ) then
  107.          $LB_Y0 = $MR_dodia_S3
  107.          $UB_Y1 = -1 + $LCS_3
  107.          $Subscript_Y5 = 44
  107.          _bounds_error( $_File_Y40, $Line_Y46, $_Name_Y41, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y47 )
  107.       endif
  107.       $MR_dodia_S5 = 0[$CS_dodia_0,0].L
  107.       if ( 44[int( $MR_dodia_S5, 8 ),-$MR_dodia_S3] /= .false. ) then
  107. !dir$ suppress 0[loc( ydrag ),0].L
  107.          t$19 = $_StaticDV_P1
  107.          if ( $CARG_ncols_I1 <= 0 ) then
  107.             $LB_Y0 = 1
  107.             $UB_Y1 = $CARG_ncols_I1
  107.             $Subscript_Y5 = 1
  107.             _bounds_error( $_File_Y40, $Line_Y46, $_Name_Y48, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y49 )
  107.          endif
  107.          0[loc( t$19 ),0].L = pointer to array[1] of real (kind=8)( loc( 0[loc( ydrag ),0].L ) )
  107.          1[loc( t$19 ),0].L = 64
  107.          2[loc( t$19 ),0].L = or( 17, and( 0xfffffffffffffff1UL, 2[loc( t$19 ),0].L ) )
  107.          23[loc( t$19 )].B = 1
  107.          4[loc( t$19 ),0].L = 0
  107.          5[loc( t$19 ),0].L = 0
  107.          21[loc( t$19 )].B = 0
  107.          6[loc( t$19 ),0] = 13
  107.          6[loc( t$19 ),0].L = 1
  107.          7[loc( t$19 ),0].L = max( 0, $CARG_ncols_I1 )
  107.          8[loc( t$19 ),0].L = 1
  107.          2[loc( t$19 ),0].L = or( 131136, and( -4294967265UL, 2[loc( t$19 ),0].L ) )
  107.          $Con_P25 = 44
  107.          call updia1d( t$19, $Con_P25, 0[loc( latco ),0] )
  107.       endif
  108.       $MR_dodia_S7 = 7[$CS_dodia_0,0].L
  108.       $MR_dodia_S6 = 6[$CS_dodia_0,0].L
  108.       $LCS_5 = $MR_dodia_S6 + $MR_dodia_S7
  108.       if ( or( -46 + $LCS_5, 45 - $MR_dodia_S6 ) < 0 ) then
  108.          $LB_Y0 = $MR_dodia_S6
  108.          $UB_Y1 = -1 + $LCS_5
  108.          $Subscript_Y5 = 45
  108.          _bounds_error( $_File_Y40, $Line_Y50, $_Name_Y41, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y51 )
  108.       endif
  108.       $MR_dodia_S8 = 0[$CS_dodia_0,0].L
  108.       if ( 45[int( $MR_dodia_S8, 8 ),-$MR_dodia_S6] /= .false. ) then
  108. !dir$ suppress 0[loc( chug ),0].L
  108.          t$20 = $_StaticDV_P2
  108.          if ( $CARG_kmax_I2 <= 0 ) then
  108.             $LB_Y0 = 1
  108.             $UB_Y1 = $CARG_kmax_I2
  108.             $Subscript_Y5 = 1
  108.             _bounds_error( $_File_Y40, $Line_Y50, $_Name_Y52, $Dim_Y9, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y53 )
  108.          endif
  108.          if ( $CARG_ncols_I1 <= 0 ) then
  108.             $LB_Y0 = 1
  108.             $UB_Y1 = $CARG_ncols_I1
  108.             $Subscript_Y5 = 1
  108.             _bounds_error( $_File_Y40, $Line_Y50, $_Name_Y54, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y55 )
  108.          endif
  108.          0[loc( t$20 ),0].L = pointer to array[1] of array[1] of real (kind=8)( loc( 0[loc( chug ),0].L ) )
  108.          1[loc( t$20 ),0].L = 64
  108.          2[loc( t$20 ),0].L = or( 17, and( 0xfffffffffffffff1UL, 2[loc( t$20 ),0].L ) )
  108.          23[loc( t$20 )].B = 2
  108.          4[loc( t$20 ),0].L = 0
  108.          5[loc( t$20 ),0].L = 0
  108.          21[loc( t$20 )].B = 0
  108.          6[loc( t$20 ),0] = 13
  108.          6[loc( t$20 ),0].L = 1
  108.          $LCS_6 = max( 0, $CARG_ncols_I1 )
  108.          7[loc( t$20 ),0].L = $LCS_6
  108.          8[loc( t$20 ),0].L = 1
  108.          9[loc( t$20 ),0].L = 1
  108.          10[loc( t$20 ),0].L = max( 0, $CARG_kmax_I2 )
  108.          11[loc( t$20 ),0].L = $LCS_6
  108.          2[loc( t$20 ),0].L = or( 131136, and( -4294967265UL, 2[loc( t$20 ),0].L ) )
  108.          $Con_P25 = 45
  108.          call updia2d( t$20, $Con_P25, 0[loc( latco ),0] )
  108.       endif
  109.       $MR_dodia_S10 = 7[$CS_dodia_0,0].L
  109.       $MR_dodia_S9 = 6[$CS_dodia_0,0].L
  109.       $LCS_8 = $MR_dodia_S9 + $MR_dodia_S10
  109.       if ( or( -47 + $LCS_8, 46 - $MR_dodia_S9 ) < 0 ) then
  109.          $LB_Y0 = $MR_dodia_S9
  109.          $UB_Y1 = -1 + $LCS_8
  109.          $Subscript_Y5 = 46
  109.          _bounds_error( $_File_Y40, $Line_Y56, $_Name_Y41, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y57 )
  109.       endif
  109.       $MR_dodia_S11 = 0[$CS_dodia_0,0].L
  109.       if ( 46[int( $MR_dodia_S11, 8 ),-$MR_dodia_S9] /= .false. ) then
  109. !dir$ suppress 0[loc( chvg ),0].L
  109.          t$21 = $_StaticDV_P3
  109.          if ( $CARG_kmax_I2 <= 0 ) then
  109.             $LB_Y0 = 1
  109.             $UB_Y1 = $CARG_kmax_I2
  109.             $Subscript_Y5 = 1
  109.             _bounds_error( $_File_Y40, $Line_Y56, $_Name_Y58, $Dim_Y9, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y59 )
  109.          endif
  109.          if ( $CARG_ncols_I1 <= 0 ) then
  109.             $LB_Y0 = 1
  109.             $UB_Y1 = $CARG_ncols_I1
  109.             $Subscript_Y5 = 1
  109.             _bounds_error( $_File_Y40, $Line_Y56, $_Name_Y60, $Dim_Y8, $LB_Y0, $UB_Y1, $Subscript_Y5, $Err_count_Y61 )
  109.          endif
  109.          0[loc( t$21 ),0].L = pointer to array[1] of array[1] of real (kind=8)( loc( 0[loc( chvg ),0].L ) )
  109.          1[loc( t$21 ),0].L = 64
  109.          2[loc( t$21 ),0].L = or( 17, and( 0xfffffffffffffff1UL, 2[loc( t$21 ),0].L ) )
  109.          23[loc( t$21 )].B = 2
  109.          4[loc( t$21 ),0].L = 0
  109.          5[loc( t$21 ),0].L = 0
  109.          21[loc( t$21 )].B = 0
  109.          6[loc( t$21 ),0] = 13
  109.          6[loc( t$21 ),0].L = 1
  109.          $LCS_9 = max( 0, $CARG_ncols_I1 )
  109.          7[loc( t$21 ),0].L = $LCS_9
  109.          8[loc( t$21 ),0].L = 1
  109.          9[loc( t$21 ),0].L = 1
  109.          10[loc( t$21 ),0].L = max( 0, $CARG_kmax_I2 )
  109.          11[loc( t$21 ),0].L = $LCS_9
  109.          2[loc( t$21 ),0].L = or( 131136, and( -4294967265UL, 2[loc( t$21 ),0].L ) )
  109.          $Con_P25 = 46
  109.          call updia2d( t$21, $Con_P25, 0[loc( latco ),0] )
  109.       endif
  111.       return
  111.       end
  111.       
    6.       
    6.       module gwdddriver
    6.       end
    6.       
